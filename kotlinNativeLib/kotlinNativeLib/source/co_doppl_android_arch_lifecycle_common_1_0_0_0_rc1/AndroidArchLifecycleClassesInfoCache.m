//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "AndroidArchLifecycleClassesInfoCache.h"
#include "AndroidArchLifecycleLifecycle.h"
#include "AndroidArchLifecycleLifecycleOwner.h"
#include "AndroidArchLifecycleOnLifecycleEvent.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Boolean.h"
#include "java/lang/IllegalAccessException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/NoClassDefFoundError.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/Throwable.h"
#include "java/lang/reflect/InvocationTargetException.h"
#include "java/lang/reflect/Method.h"
#include "java/util/ArrayList.h"
#include "java/util/HashMap.h"
#include "java/util/List.h"
#include "java/util/Map.h"
#include "java/util/Set.h"

@interface AndroidArchLifecycleClassesInfoCache () {
 @public
  id<JavaUtilMap> mCallbackMap_;
  id<JavaUtilMap> mHasLifecycleMethods_;
}

- (IOSObjectArray *)getDeclaredMethodsWithIOSClass:(IOSClass *)klass;

- (void)verifyAndPutHandlerWithJavaUtilMap:(id<JavaUtilMap>)handlers
withAndroidArchLifecycleClassesInfoCache_MethodReference:(AndroidArchLifecycleClassesInfoCache_MethodReference *)newHandler
   withAndroidArchLifecycleLifecycle_Event:(AndroidArchLifecycleLifecycle_Event *)newEvent
                              withIOSClass:(IOSClass *)klass;

- (AndroidArchLifecycleClassesInfoCache_CallbackInfo *)createInfoWithIOSClass:(IOSClass *)klass
                                               withJavaLangReflectMethodArray:(IOSObjectArray * __nullable)declaredMethods;

@end

J2OBJC_FIELD_SETTER(AndroidArchLifecycleClassesInfoCache, mCallbackMap_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(AndroidArchLifecycleClassesInfoCache, mHasLifecycleMethods_, id<JavaUtilMap>)

inline jint AndroidArchLifecycleClassesInfoCache_get_CALL_TYPE_NO_ARG();
#define AndroidArchLifecycleClassesInfoCache_CALL_TYPE_NO_ARG 0
J2OBJC_STATIC_FIELD_CONSTANT(AndroidArchLifecycleClassesInfoCache, CALL_TYPE_NO_ARG, jint)

inline jint AndroidArchLifecycleClassesInfoCache_get_CALL_TYPE_PROVIDER();
#define AndroidArchLifecycleClassesInfoCache_CALL_TYPE_PROVIDER 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidArchLifecycleClassesInfoCache, CALL_TYPE_PROVIDER, jint)

inline jint AndroidArchLifecycleClassesInfoCache_get_CALL_TYPE_PROVIDER_WITH_EVENT();
#define AndroidArchLifecycleClassesInfoCache_CALL_TYPE_PROVIDER_WITH_EVENT 2
J2OBJC_STATIC_FIELD_CONSTANT(AndroidArchLifecycleClassesInfoCache, CALL_TYPE_PROVIDER_WITH_EVENT, jint)

__attribute__((unused)) static IOSObjectArray *AndroidArchLifecycleClassesInfoCache_getDeclaredMethodsWithIOSClass_(AndroidArchLifecycleClassesInfoCache *self, IOSClass *klass);

__attribute__((unused)) static void AndroidArchLifecycleClassesInfoCache_verifyAndPutHandlerWithJavaUtilMap_withAndroidArchLifecycleClassesInfoCache_MethodReference_withAndroidArchLifecycleLifecycle_Event_withIOSClass_(AndroidArchLifecycleClassesInfoCache *self, id<JavaUtilMap> handlers, AndroidArchLifecycleClassesInfoCache_MethodReference *newHandler, AndroidArchLifecycleLifecycle_Event *newEvent, IOSClass *klass);

__attribute__((unused)) static AndroidArchLifecycleClassesInfoCache_CallbackInfo *AndroidArchLifecycleClassesInfoCache_createInfoWithIOSClass_withJavaLangReflectMethodArray_(AndroidArchLifecycleClassesInfoCache *self, IOSClass *klass, IOSObjectArray *declaredMethods);

@interface AndroidArchLifecycleClassesInfoCache_CallbackInfo ()

+ (void)invokeMethodsForEventWithJavaUtilList:(id<JavaUtilList>)handlers
       withAndroidArchLifecycleLifecycleOwner:(id<AndroidArchLifecycleLifecycleOwner>)source
      withAndroidArchLifecycleLifecycle_Event:(AndroidArchLifecycleLifecycle_Event *)event
                                       withId:(id)mWrapped;

@end

__attribute__((unused)) static void AndroidArchLifecycleClassesInfoCache_CallbackInfo_invokeMethodsForEventWithJavaUtilList_withAndroidArchLifecycleLifecycleOwner_withAndroidArchLifecycleLifecycle_Event_withId_(id<JavaUtilList> handlers, id<AndroidArchLifecycleLifecycleOwner> source, AndroidArchLifecycleLifecycle_Event *event, id mWrapped);

J2OBJC_INITIALIZED_DEFN(AndroidArchLifecycleClassesInfoCache)

AndroidArchLifecycleClassesInfoCache *AndroidArchLifecycleClassesInfoCache_sInstance;

@implementation AndroidArchLifecycleClassesInfoCache

+ (AndroidArchLifecycleClassesInfoCache *)sInstance {
  return AndroidArchLifecycleClassesInfoCache_sInstance;
}

+ (void)setSInstance:(AndroidArchLifecycleClassesInfoCache *)value {
  JreStrongAssign(&AndroidArchLifecycleClassesInfoCache_sInstance, value);
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  AndroidArchLifecycleClassesInfoCache_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (jboolean)hasLifecycleMethodsWithIOSClass:(IOSClass *)klass {
  if ([((id<JavaUtilMap>) nil_chk(mHasLifecycleMethods_)) containsKeyWithId:klass]) {
    return [((JavaLangBoolean *) nil_chk([mHasLifecycleMethods_ getWithId:klass])) booleanValue];
  }
  IOSObjectArray *methods = AndroidArchLifecycleClassesInfoCache_getDeclaredMethodsWithIOSClass_(self, klass);
  {
    IOSObjectArray *a__ = methods;
    JavaLangReflectMethod * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    JavaLangReflectMethod * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      JavaLangReflectMethod *method = *b__++;
      id<AndroidArchLifecycleOnLifecycleEvent> annotation = ((id<AndroidArchLifecycleOnLifecycleEvent>) [((JavaLangReflectMethod *) nil_chk(method)) getAnnotationWithIOSClass:AndroidArchLifecycleOnLifecycleEvent_class_()]);
      if (annotation != nil) {
        AndroidArchLifecycleClassesInfoCache_createInfoWithIOSClass_withJavaLangReflectMethodArray_(self, klass, methods);
        return true;
      }
    }
  }
  [mHasLifecycleMethods_ putWithId:klass withId:JavaLangBoolean_valueOfWithBoolean_(false)];
  return false;
}

- (IOSObjectArray *)getDeclaredMethodsWithIOSClass:(IOSClass *)klass {
  return AndroidArchLifecycleClassesInfoCache_getDeclaredMethodsWithIOSClass_(self, klass);
}

- (AndroidArchLifecycleClassesInfoCache_CallbackInfo *)getInfoWithIOSClass:(IOSClass *)klass {
  AndroidArchLifecycleClassesInfoCache_CallbackInfo *existing = [((id<JavaUtilMap>) nil_chk(mCallbackMap_)) getWithId:klass];
  if (existing != nil) {
    return existing;
  }
  existing = AndroidArchLifecycleClassesInfoCache_createInfoWithIOSClass_withJavaLangReflectMethodArray_(self, klass, nil);
  return existing;
}

- (void)verifyAndPutHandlerWithJavaUtilMap:(id<JavaUtilMap>)handlers
withAndroidArchLifecycleClassesInfoCache_MethodReference:(AndroidArchLifecycleClassesInfoCache_MethodReference *)newHandler
   withAndroidArchLifecycleLifecycle_Event:(AndroidArchLifecycleLifecycle_Event *)newEvent
                              withIOSClass:(IOSClass *)klass {
  AndroidArchLifecycleClassesInfoCache_verifyAndPutHandlerWithJavaUtilMap_withAndroidArchLifecycleClassesInfoCache_MethodReference_withAndroidArchLifecycleLifecycle_Event_withIOSClass_(self, handlers, newHandler, newEvent, klass);
}

- (AndroidArchLifecycleClassesInfoCache_CallbackInfo *)createInfoWithIOSClass:(IOSClass *)klass
                                               withJavaLangReflectMethodArray:(IOSObjectArray * __nullable)declaredMethods {
  return AndroidArchLifecycleClassesInfoCache_createInfoWithIOSClass_withJavaLangReflectMethodArray_(self, klass, declaredMethods);
}

- (void)dealloc {
  RELEASE_(mCallbackMap_);
  RELEASE_(mHasLifecycleMethods_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 0, 1, -1, -1, -1, -1 },
    { NULL, "[LJavaLangReflectMethod;", 0x2, 2, 1, -1, -1, -1, -1 },
    { NULL, "LAndroidArchLifecycleClassesInfoCache_CallbackInfo;", 0x0, 3, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 4, 5, -1, 6, -1, -1 },
    { NULL, "LAndroidArchLifecycleClassesInfoCache_CallbackInfo;", 0x2, 7, 8, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(hasLifecycleMethodsWithIOSClass:);
  methods[2].selector = @selector(getDeclaredMethodsWithIOSClass:);
  methods[3].selector = @selector(getInfoWithIOSClass:);
  methods[4].selector = @selector(verifyAndPutHandlerWithJavaUtilMap:withAndroidArchLifecycleClassesInfoCache_MethodReference:withAndroidArchLifecycleLifecycle_Event:withIOSClass:);
  methods[5].selector = @selector(createInfoWithIOSClass:withJavaLangReflectMethodArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "sInstance", "LAndroidArchLifecycleClassesInfoCache;", .constantValue.asLong = 0, 0x8, -1, 9, -1, -1 },
    { "CALL_TYPE_NO_ARG", "I", .constantValue.asInt = AndroidArchLifecycleClassesInfoCache_CALL_TYPE_NO_ARG, 0x1a, -1, -1, -1, -1 },
    { "CALL_TYPE_PROVIDER", "I", .constantValue.asInt = AndroidArchLifecycleClassesInfoCache_CALL_TYPE_PROVIDER, 0x1a, -1, -1, -1, -1 },
    { "CALL_TYPE_PROVIDER_WITH_EVENT", "I", .constantValue.asInt = AndroidArchLifecycleClassesInfoCache_CALL_TYPE_PROVIDER_WITH_EVENT, 0x1a, -1, -1, -1, -1 },
    { "mCallbackMap_", "LJavaUtilMap;", .constantValue.asLong = 0, 0x12, -1, -1, 10, -1 },
    { "mHasLifecycleMethods_", "LJavaUtilMap;", .constantValue.asLong = 0, 0x12, -1, -1, 11, -1 },
  };
  static const void *ptrTable[] = { "hasLifecycleMethods", "LIOSClass;", "getDeclaredMethods", "getInfo", "verifyAndPutHandler", "LJavaUtilMap;LAndroidArchLifecycleClassesInfoCache_MethodReference;LAndroidArchLifecycleLifecycle_Event;LIOSClass;", "(Ljava/util/Map<Landroid/arch/lifecycle/ClassesInfoCache$MethodReference;Landroid/arch/lifecycle/Lifecycle$Event;>;Landroid/arch/lifecycle/ClassesInfoCache$MethodReference;Landroid/arch/lifecycle/Lifecycle$Event;Ljava/lang/Class;)V", "createInfo", "LIOSClass;[LJavaLangReflectMethod;", &AndroidArchLifecycleClassesInfoCache_sInstance, "Ljava/util/Map<Ljava/lang/Class;Landroid/arch/lifecycle/ClassesInfoCache$CallbackInfo;>;", "Ljava/util/Map<Ljava/lang/Class;Ljava/lang/Boolean;>;", "LAndroidArchLifecycleClassesInfoCache_CallbackInfo;LAndroidArchLifecycleClassesInfoCache_MethodReference;" };
  static const J2ObjcClassInfo _AndroidArchLifecycleClassesInfoCache = { "ClassesInfoCache", "android.arch.lifecycle", ptrTable, methods, fields, 7, 0x0, 6, 6, -1, 12, -1, -1, -1 };
  return &_AndroidArchLifecycleClassesInfoCache;
}

+ (void)initialize {
  if (self == [AndroidArchLifecycleClassesInfoCache class]) {
    JreStrongAssignAndConsume(&AndroidArchLifecycleClassesInfoCache_sInstance, new_AndroidArchLifecycleClassesInfoCache_init());
    J2OBJC_SET_INITIALIZED(AndroidArchLifecycleClassesInfoCache)
  }
}

@end

void AndroidArchLifecycleClassesInfoCache_init(AndroidArchLifecycleClassesInfoCache *self) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->mCallbackMap_, new_JavaUtilHashMap_init());
  JreStrongAssignAndConsume(&self->mHasLifecycleMethods_, new_JavaUtilHashMap_init());
}

AndroidArchLifecycleClassesInfoCache *new_AndroidArchLifecycleClassesInfoCache_init() {
  J2OBJC_NEW_IMPL(AndroidArchLifecycleClassesInfoCache, init)
}

AndroidArchLifecycleClassesInfoCache *create_AndroidArchLifecycleClassesInfoCache_init() {
  J2OBJC_CREATE_IMPL(AndroidArchLifecycleClassesInfoCache, init)
}

IOSObjectArray *AndroidArchLifecycleClassesInfoCache_getDeclaredMethodsWithIOSClass_(AndroidArchLifecycleClassesInfoCache *self, IOSClass *klass) {
  @try {
    return [((IOSClass *) nil_chk(klass)) getDeclaredMethods];
  }
  @catch (JavaLangNoClassDefFoundError *e) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_withJavaLangThrowable_(@"The observer class has some methods that use newer APIs which are not available in the current OS version. Lifecycles cannot access even other methods so you should make sure that your observer classes only access framework classes that are available in your min API level OR use lifecycle:compiler annotation processor.", e);
  }
}

void AndroidArchLifecycleClassesInfoCache_verifyAndPutHandlerWithJavaUtilMap_withAndroidArchLifecycleClassesInfoCache_MethodReference_withAndroidArchLifecycleLifecycle_Event_withIOSClass_(AndroidArchLifecycleClassesInfoCache *self, id<JavaUtilMap> handlers, AndroidArchLifecycleClassesInfoCache_MethodReference *newHandler, AndroidArchLifecycleLifecycle_Event *newEvent, IOSClass *klass) {
  AndroidArchLifecycleLifecycle_Event *event = [((id<JavaUtilMap>) nil_chk(handlers)) getWithId:newHandler];
  if (event != nil && newEvent != event) {
    JavaLangReflectMethod *method = ((AndroidArchLifecycleClassesInfoCache_MethodReference *) nil_chk(newHandler))->mMethod_;
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$$$$@$@", @"Method ", [((JavaLangReflectMethod *) nil_chk(method)) getName], @" in ", [((IOSClass *) nil_chk(klass)) getName], @" already declared with different @OnLifecycleEvent value: previous value ", event, @", new value ", newEvent));
  }
  if (event == nil) {
    [handlers putWithId:newHandler withId:newEvent];
  }
}

AndroidArchLifecycleClassesInfoCache_CallbackInfo *AndroidArchLifecycleClassesInfoCache_createInfoWithIOSClass_withJavaLangReflectMethodArray_(AndroidArchLifecycleClassesInfoCache *self, IOSClass *klass, IOSObjectArray *declaredMethods) {
  IOSClass *superclass_ = [((IOSClass *) nil_chk(klass)) getSuperclass];
  id<JavaUtilMap> handlerToEvent = create_JavaUtilHashMap_init();
  if (superclass_ != nil) {
    AndroidArchLifecycleClassesInfoCache_CallbackInfo *superInfo = [self getInfoWithIOSClass:superclass_];
    if (superInfo != nil) {
      [handlerToEvent putAllWithJavaUtilMap:superInfo->mHandlerToEvent_];
    }
  }
  IOSObjectArray *interfaces = [klass getInterfaces];
  {
    IOSObjectArray *a__ = interfaces;
    IOSClass * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    IOSClass * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      IOSClass *intrfc = *b__++;
      for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([((id<JavaUtilMap>) nil_chk(((AndroidArchLifecycleClassesInfoCache_CallbackInfo *) nil_chk([self getInfoWithIOSClass:intrfc]))->mHandlerToEvent_)) entrySet])) {
        AndroidArchLifecycleClassesInfoCache_verifyAndPutHandlerWithJavaUtilMap_withAndroidArchLifecycleClassesInfoCache_MethodReference_withAndroidArchLifecycleLifecycle_Event_withIOSClass_(self, handlerToEvent, [((id<JavaUtilMap_Entry>) nil_chk(entry_)) getKey], [entry_ getValue], klass);
      }
    }
  }
  IOSObjectArray *methods = declaredMethods != nil ? declaredMethods : AndroidArchLifecycleClassesInfoCache_getDeclaredMethodsWithIOSClass_(self, klass);
  jboolean hasLifecycleMethods = false;
  {
    IOSObjectArray *a__ = methods;
    JavaLangReflectMethod * const *b__ = a__->buffer_;
    JavaLangReflectMethod * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      JavaLangReflectMethod *method = *b__++;
      id<AndroidArchLifecycleOnLifecycleEvent> annotation = ((id<AndroidArchLifecycleOnLifecycleEvent>) [((JavaLangReflectMethod *) nil_chk(method)) getAnnotationWithIOSClass:AndroidArchLifecycleOnLifecycleEvent_class_()]);
      if (annotation == nil) {
        continue;
      }
      hasLifecycleMethods = true;
      IOSObjectArray *params = [method getParameterTypes];
      jint callType = AndroidArchLifecycleClassesInfoCache_CALL_TYPE_NO_ARG;
      if (((IOSObjectArray *) nil_chk(params))->size_ > 0) {
        callType = AndroidArchLifecycleClassesInfoCache_CALL_TYPE_PROVIDER;
        if (![((IOSClass *) nil_chk(IOSObjectArray_Get(params, 0))) isAssignableFrom:AndroidArchLifecycleLifecycleOwner_class_()]) {
          @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"invalid parameter type. Must be one and instanceof LifecycleOwner");
        }
      }
      AndroidArchLifecycleLifecycle_Event *event = [annotation value];
      if (params->size_ > 1) {
        callType = AndroidArchLifecycleClassesInfoCache_CALL_TYPE_PROVIDER_WITH_EVENT;
        if (![((IOSClass *) nil_chk(IOSObjectArray_Get(params, 1))) isAssignableFrom:AndroidArchLifecycleLifecycle_Event_class_()]) {
          @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"invalid parameter type. second arg must be an event");
        }
        if (event != JreLoadEnum(AndroidArchLifecycleLifecycle_Event, ON_ANY)) {
          @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Second arg is supported only for ON_ANY value");
        }
      }
      if (params->size_ > 2) {
        @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"cannot have more than 2 params");
      }
      AndroidArchLifecycleClassesInfoCache_MethodReference *methodReference = create_AndroidArchLifecycleClassesInfoCache_MethodReference_initWithInt_withJavaLangReflectMethod_(callType, method);
      AndroidArchLifecycleClassesInfoCache_verifyAndPutHandlerWithJavaUtilMap_withAndroidArchLifecycleClassesInfoCache_MethodReference_withAndroidArchLifecycleLifecycle_Event_withIOSClass_(self, handlerToEvent, methodReference, event, klass);
    }
  }
  AndroidArchLifecycleClassesInfoCache_CallbackInfo *info = create_AndroidArchLifecycleClassesInfoCache_CallbackInfo_initWithJavaUtilMap_(handlerToEvent);
  [((id<JavaUtilMap>) nil_chk(self->mCallbackMap_)) putWithId:klass withId:info];
  [((id<JavaUtilMap>) nil_chk(self->mHasLifecycleMethods_)) putWithId:klass withId:JavaLangBoolean_valueOfWithBoolean_(hasLifecycleMethods)];
  return info;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidArchLifecycleClassesInfoCache)

@implementation AndroidArchLifecycleClassesInfoCache_CallbackInfo

- (instancetype)initWithJavaUtilMap:(id<JavaUtilMap>)handlerToEvent {
  AndroidArchLifecycleClassesInfoCache_CallbackInfo_initWithJavaUtilMap_(self, handlerToEvent);
  return self;
}

- (void)invokeCallbacksWithAndroidArchLifecycleLifecycleOwner:(id<AndroidArchLifecycleLifecycleOwner>)source
                      withAndroidArchLifecycleLifecycle_Event:(AndroidArchLifecycleLifecycle_Event *)event
                                                       withId:(id)target {
  AndroidArchLifecycleClassesInfoCache_CallbackInfo_invokeMethodsForEventWithJavaUtilList_withAndroidArchLifecycleLifecycleOwner_withAndroidArchLifecycleLifecycle_Event_withId_([((id<JavaUtilMap>) nil_chk(mEventToHandlers_)) getWithId:event], source, event, target);
  AndroidArchLifecycleClassesInfoCache_CallbackInfo_invokeMethodsForEventWithJavaUtilList_withAndroidArchLifecycleLifecycleOwner_withAndroidArchLifecycleLifecycle_Event_withId_([mEventToHandlers_ getWithId:JreLoadEnum(AndroidArchLifecycleLifecycle_Event, ON_ANY)], source, event, target);
}

+ (void)invokeMethodsForEventWithJavaUtilList:(id<JavaUtilList>)handlers
       withAndroidArchLifecycleLifecycleOwner:(id<AndroidArchLifecycleLifecycleOwner>)source
      withAndroidArchLifecycleLifecycle_Event:(AndroidArchLifecycleLifecycle_Event *)event
                                       withId:(id)mWrapped {
  AndroidArchLifecycleClassesInfoCache_CallbackInfo_invokeMethodsForEventWithJavaUtilList_withAndroidArchLifecycleLifecycleOwner_withAndroidArchLifecycleLifecycle_Event_withId_(handlers, source, event, mWrapped);
}

- (void)dealloc {
  RELEASE_(mEventToHandlers_);
  RELEASE_(mHandlerToEvent_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, 1, -1, -1 },
    { NULL, "V", 0x0, 2, 3, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 4, 5, -1, 6, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaUtilMap:);
  methods[1].selector = @selector(invokeCallbacksWithAndroidArchLifecycleLifecycleOwner:withAndroidArchLifecycleLifecycle_Event:withId:);
  methods[2].selector = @selector(invokeMethodsForEventWithJavaUtilList:withAndroidArchLifecycleLifecycleOwner:withAndroidArchLifecycleLifecycle_Event:withId:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "mEventToHandlers_", "LJavaUtilMap;", .constantValue.asLong = 0, 0x10, -1, -1, 7, -1 },
    { "mHandlerToEvent_", "LJavaUtilMap;", .constantValue.asLong = 0, 0x10, -1, -1, 8, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilMap;", "(Ljava/util/Map<Landroid/arch/lifecycle/ClassesInfoCache$MethodReference;Landroid/arch/lifecycle/Lifecycle$Event;>;)V", "invokeCallbacks", "LAndroidArchLifecycleLifecycleOwner;LAndroidArchLifecycleLifecycle_Event;LNSObject;", "invokeMethodsForEvent", "LJavaUtilList;LAndroidArchLifecycleLifecycleOwner;LAndroidArchLifecycleLifecycle_Event;LNSObject;", "(Ljava/util/List<Landroid/arch/lifecycle/ClassesInfoCache$MethodReference;>;Landroid/arch/lifecycle/LifecycleOwner;Landroid/arch/lifecycle/Lifecycle$Event;Ljava/lang/Object;)V", "Ljava/util/Map<Landroid/arch/lifecycle/Lifecycle$Event;Ljava/util/List<Landroid/arch/lifecycle/ClassesInfoCache$MethodReference;>;>;", "Ljava/util/Map<Landroid/arch/lifecycle/ClassesInfoCache$MethodReference;Landroid/arch/lifecycle/Lifecycle$Event;>;", "LAndroidArchLifecycleClassesInfoCache;" };
  static const J2ObjcClassInfo _AndroidArchLifecycleClassesInfoCache_CallbackInfo = { "CallbackInfo", "android.arch.lifecycle", ptrTable, methods, fields, 7, 0x8, 3, 2, 9, -1, -1, -1, -1 };
  return &_AndroidArchLifecycleClassesInfoCache_CallbackInfo;
}

@end

void AndroidArchLifecycleClassesInfoCache_CallbackInfo_initWithJavaUtilMap_(AndroidArchLifecycleClassesInfoCache_CallbackInfo *self, id<JavaUtilMap> handlerToEvent) {
  NSObject_init(self);
  JreStrongAssign(&self->mHandlerToEvent_, handlerToEvent);
  JreStrongAssignAndConsume(&self->mEventToHandlers_, new_JavaUtilHashMap_init());
  for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([((id<JavaUtilMap>) nil_chk(handlerToEvent)) entrySet])) {
    AndroidArchLifecycleLifecycle_Event *event = [((id<JavaUtilMap_Entry>) nil_chk(entry_)) getValue];
    id<JavaUtilList> methodReferences = [self->mEventToHandlers_ getWithId:event];
    if (methodReferences == nil) {
      methodReferences = create_JavaUtilArrayList_init();
      [self->mEventToHandlers_ putWithId:event withId:methodReferences];
    }
    [methodReferences addWithId:[entry_ getKey]];
  }
}

AndroidArchLifecycleClassesInfoCache_CallbackInfo *new_AndroidArchLifecycleClassesInfoCache_CallbackInfo_initWithJavaUtilMap_(id<JavaUtilMap> handlerToEvent) {
  J2OBJC_NEW_IMPL(AndroidArchLifecycleClassesInfoCache_CallbackInfo, initWithJavaUtilMap_, handlerToEvent)
}

AndroidArchLifecycleClassesInfoCache_CallbackInfo *create_AndroidArchLifecycleClassesInfoCache_CallbackInfo_initWithJavaUtilMap_(id<JavaUtilMap> handlerToEvent) {
  J2OBJC_CREATE_IMPL(AndroidArchLifecycleClassesInfoCache_CallbackInfo, initWithJavaUtilMap_, handlerToEvent)
}

void AndroidArchLifecycleClassesInfoCache_CallbackInfo_invokeMethodsForEventWithJavaUtilList_withAndroidArchLifecycleLifecycleOwner_withAndroidArchLifecycleLifecycle_Event_withId_(id<JavaUtilList> handlers, id<AndroidArchLifecycleLifecycleOwner> source, AndroidArchLifecycleLifecycle_Event *event, id mWrapped) {
  AndroidArchLifecycleClassesInfoCache_CallbackInfo_initialize();
  if (handlers != nil) {
    for (jint i = [handlers size] - 1; i >= 0; i--) {
      [((AndroidArchLifecycleClassesInfoCache_MethodReference *) nil_chk([handlers getWithInt:i])) invokeCallbackWithAndroidArchLifecycleLifecycleOwner:source withAndroidArchLifecycleLifecycle_Event:event withId:mWrapped];
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidArchLifecycleClassesInfoCache_CallbackInfo)

@implementation AndroidArchLifecycleClassesInfoCache_MethodReference

- (instancetype)initWithInt:(jint)callType
  withJavaLangReflectMethod:(JavaLangReflectMethod *)method {
  AndroidArchLifecycleClassesInfoCache_MethodReference_initWithInt_withJavaLangReflectMethod_(self, callType, method);
  return self;
}

- (void)invokeCallbackWithAndroidArchLifecycleLifecycleOwner:(id<AndroidArchLifecycleLifecycleOwner>)source
                     withAndroidArchLifecycleLifecycle_Event:(AndroidArchLifecycleLifecycle_Event *)event
                                                      withId:(id)target {
  @try {
    switch (mCallType_) {
      case AndroidArchLifecycleClassesInfoCache_CALL_TYPE_NO_ARG:
      [((JavaLangReflectMethod *) nil_chk(mMethod_)) invokeWithId:target withNSObjectArray:[IOSObjectArray arrayWithLength:0 type:NSObject_class_()]];
      break;
      case AndroidArchLifecycleClassesInfoCache_CALL_TYPE_PROVIDER:
      [((JavaLangReflectMethod *) nil_chk(mMethod_)) invokeWithId:target withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ source } count:1 type:NSObject_class_()]];
      break;
      case AndroidArchLifecycleClassesInfoCache_CALL_TYPE_PROVIDER_WITH_EVENT:
      [((JavaLangReflectMethod *) nil_chk(mMethod_)) invokeWithId:target withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ source, event } count:2 type:NSObject_class_()]];
      break;
    }
  }
  @catch (JavaLangReflectInvocationTargetException *e) {
    @throw create_JavaLangRuntimeException_initWithNSString_withJavaLangThrowable_(@"Failed to call observer method", [e getCause]);
  }
  @catch (JavaLangIllegalAccessException *e) {
    @throw create_JavaLangRuntimeException_initWithJavaLangThrowable_(e);
  }
}

- (jboolean)isEqual:(id)o {
  if (self == o) {
    return true;
  }
  if (o == nil || [self java_getClass] != [o java_getClass]) {
    return false;
  }
  AndroidArchLifecycleClassesInfoCache_MethodReference *that = (AndroidArchLifecycleClassesInfoCache_MethodReference *) cast_chk(o, [AndroidArchLifecycleClassesInfoCache_MethodReference class]);
  return mCallType_ == that->mCallType_ && [((NSString *) nil_chk([((JavaLangReflectMethod *) nil_chk(mMethod_)) getName])) isEqual:[that->mMethod_ getName]];
}

- (NSUInteger)hash {
  return 31 * mCallType_ + ((jint) [((NSString *) nil_chk([((JavaLangReflectMethod *) nil_chk(mMethod_)) getName])) hash]);
}

- (void)dealloc {
  RELEASE_(mMethod_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 1, 2, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 5, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithInt:withJavaLangReflectMethod:);
  methods[1].selector = @selector(invokeCallbackWithAndroidArchLifecycleLifecycleOwner:withAndroidArchLifecycleLifecycle_Event:withId:);
  methods[2].selector = @selector(isEqual:);
  methods[3].selector = @selector(hash);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "mCallType_", "I", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "mMethod_", "LJavaLangReflectMethod;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "ILJavaLangReflectMethod;", "invokeCallback", "LAndroidArchLifecycleLifecycleOwner;LAndroidArchLifecycleLifecycle_Event;LNSObject;", "equals", "LNSObject;", "hashCode", "LAndroidArchLifecycleClassesInfoCache;" };
  static const J2ObjcClassInfo _AndroidArchLifecycleClassesInfoCache_MethodReference = { "MethodReference", "android.arch.lifecycle", ptrTable, methods, fields, 7, 0x8, 4, 2, 6, -1, -1, -1, -1 };
  return &_AndroidArchLifecycleClassesInfoCache_MethodReference;
}

@end

void AndroidArchLifecycleClassesInfoCache_MethodReference_initWithInt_withJavaLangReflectMethod_(AndroidArchLifecycleClassesInfoCache_MethodReference *self, jint callType, JavaLangReflectMethod *method) {
  NSObject_init(self);
  self->mCallType_ = callType;
  JreStrongAssign(&self->mMethod_, method);
  [((JavaLangReflectMethod *) nil_chk(self->mMethod_)) setAccessibleWithBoolean:true];
}

AndroidArchLifecycleClassesInfoCache_MethodReference *new_AndroidArchLifecycleClassesInfoCache_MethodReference_initWithInt_withJavaLangReflectMethod_(jint callType, JavaLangReflectMethod *method) {
  J2OBJC_NEW_IMPL(AndroidArchLifecycleClassesInfoCache_MethodReference, initWithInt_withJavaLangReflectMethod_, callType, method)
}

AndroidArchLifecycleClassesInfoCache_MethodReference *create_AndroidArchLifecycleClassesInfoCache_MethodReference_initWithInt_withJavaLangReflectMethod_(jint callType, JavaLangReflectMethod *method) {
  J2OBJC_CREATE_IMPL(AndroidArchLifecycleClassesInfoCache_MethodReference, initWithInt_withJavaLangReflectMethod_, callType, method)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidArchLifecycleClassesInfoCache_MethodReference)
