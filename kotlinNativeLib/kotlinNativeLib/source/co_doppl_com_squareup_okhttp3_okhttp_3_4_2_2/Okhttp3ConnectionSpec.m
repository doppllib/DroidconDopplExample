//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "Okhttp3CipherSuite.h"
#include "Okhttp3ConnectionSpec.h"
#include "Okhttp3InternalUtil.h"
#include "Okhttp3TlsVersion.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/util/Arrays.h"
#include "java/util/List.h"
#include "javax/net/ssl/SSLSocket.h"

@interface Okhttp3ConnectionSpec () {
 @public
  jboolean tls_;
  jboolean supportsTlsExtensions_;
  IOSObjectArray *cipherSuites_;
  IOSObjectArray *tlsVersions_;
}

- (instancetype)initWithOkhttp3ConnectionSpec_Builder:(Okhttp3ConnectionSpec_Builder *)builder;

- (Okhttp3ConnectionSpec *)supportedSpecWithJavaxNetSslSSLSocket:(JavaxNetSslSSLSocket *)sslSocket
                                                     withBoolean:(jboolean)isFallback;

+ (jboolean)nonEmptyIntersectionWithNSStringArray:(IOSObjectArray *)a
                                withNSStringArray:(IOSObjectArray *)b;

@end

J2OBJC_FIELD_SETTER(Okhttp3ConnectionSpec, cipherSuites_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(Okhttp3ConnectionSpec, tlsVersions_, IOSObjectArray *)

inline IOSObjectArray *Okhttp3ConnectionSpec_get_APPROVED_CIPHER_SUITES();
static IOSObjectArray *Okhttp3ConnectionSpec_APPROVED_CIPHER_SUITES;
J2OBJC_STATIC_FIELD_OBJ_FINAL(Okhttp3ConnectionSpec, APPROVED_CIPHER_SUITES, IOSObjectArray *)

__attribute__((unused)) static void Okhttp3ConnectionSpec_initWithOkhttp3ConnectionSpec_Builder_(Okhttp3ConnectionSpec *self, Okhttp3ConnectionSpec_Builder *builder);

__attribute__((unused)) static Okhttp3ConnectionSpec *new_Okhttp3ConnectionSpec_initWithOkhttp3ConnectionSpec_Builder_(Okhttp3ConnectionSpec_Builder *builder) NS_RETURNS_RETAINED;

__attribute__((unused)) static Okhttp3ConnectionSpec *create_Okhttp3ConnectionSpec_initWithOkhttp3ConnectionSpec_Builder_(Okhttp3ConnectionSpec_Builder *builder);

__attribute__((unused)) static Okhttp3ConnectionSpec *Okhttp3ConnectionSpec_supportedSpecWithJavaxNetSslSSLSocket_withBoolean_(Okhttp3ConnectionSpec *self, JavaxNetSslSSLSocket *sslSocket, jboolean isFallback);

__attribute__((unused)) static jboolean Okhttp3ConnectionSpec_nonEmptyIntersectionWithNSStringArray_withNSStringArray_(IOSObjectArray *a, IOSObjectArray *b);

@interface Okhttp3ConnectionSpec_Builder () {
 @public
  jboolean tls_;
  IOSObjectArray *cipherSuites_;
  IOSObjectArray *tlsVersions_;
  jboolean supportsTlsExtensions_;
}

@end

J2OBJC_FIELD_SETTER(Okhttp3ConnectionSpec_Builder, cipherSuites_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(Okhttp3ConnectionSpec_Builder, tlsVersions_, IOSObjectArray *)

J2OBJC_INITIALIZED_DEFN(Okhttp3ConnectionSpec)

Okhttp3ConnectionSpec *Okhttp3ConnectionSpec_MODERN_TLS;
Okhttp3ConnectionSpec *Okhttp3ConnectionSpec_COMPATIBLE_TLS;
Okhttp3ConnectionSpec *Okhttp3ConnectionSpec_CLEARTEXT;

@implementation Okhttp3ConnectionSpec

+ (Okhttp3ConnectionSpec *)MODERN_TLS {
  return Okhttp3ConnectionSpec_MODERN_TLS;
}

+ (Okhttp3ConnectionSpec *)COMPATIBLE_TLS {
  return Okhttp3ConnectionSpec_COMPATIBLE_TLS;
}

+ (Okhttp3ConnectionSpec *)CLEARTEXT {
  return Okhttp3ConnectionSpec_CLEARTEXT;
}

- (instancetype)initWithOkhttp3ConnectionSpec_Builder:(Okhttp3ConnectionSpec_Builder *)builder {
  Okhttp3ConnectionSpec_initWithOkhttp3ConnectionSpec_Builder_(self, builder);
  return self;
}

- (jboolean)isTls {
  return tls_;
}

- (id<JavaUtilList>)cipherSuites {
  if (cipherSuites_ == nil) return nil;
  IOSObjectArray *result = [IOSObjectArray arrayWithLength:cipherSuites_->size_ type:Okhttp3CipherSuite_class_()];
  for (jint i = 0; i < cipherSuites_->size_; i++) {
    IOSObjectArray_Set(result, i, Okhttp3CipherSuite_forJavaNameWithNSString_(IOSObjectArray_Get(cipherSuites_, i)));
  }
  return Okhttp3InternalUtil_immutableListWithNSObjectArray_(result);
}

- (id<JavaUtilList>)tlsVersions {
  if (tlsVersions_ == nil) return nil;
  IOSObjectArray *result = [IOSObjectArray arrayWithLength:tlsVersions_->size_ type:Okhttp3TlsVersion_class_()];
  for (jint i = 0; i < tlsVersions_->size_; i++) {
    IOSObjectArray_Set(result, i, Okhttp3TlsVersion_forJavaNameWithNSString_(IOSObjectArray_Get(tlsVersions_, i)));
  }
  return Okhttp3InternalUtil_immutableListWithNSObjectArray_(result);
}

- (jboolean)supportsTlsExtensions {
  return supportsTlsExtensions_;
}

- (void)applyWithJavaxNetSslSSLSocket:(JavaxNetSslSSLSocket *)sslSocket
                          withBoolean:(jboolean)isFallback {
  Okhttp3ConnectionSpec *specToApply = Okhttp3ConnectionSpec_supportedSpecWithJavaxNetSslSSLSocket_withBoolean_(self, sslSocket, isFallback);
  if (((Okhttp3ConnectionSpec *) nil_chk(specToApply))->tlsVersions_ != nil) {
    [((JavaxNetSslSSLSocket *) nil_chk(sslSocket)) setEnabledProtocolsWithNSStringArray:specToApply->tlsVersions_];
  }
  if (specToApply->cipherSuites_ != nil) {
    [((JavaxNetSslSSLSocket *) nil_chk(sslSocket)) setEnabledCipherSuitesWithNSStringArray:specToApply->cipherSuites_];
  }
}

- (Okhttp3ConnectionSpec *)supportedSpecWithJavaxNetSslSSLSocket:(JavaxNetSslSSLSocket *)sslSocket
                                                     withBoolean:(jboolean)isFallback {
  return Okhttp3ConnectionSpec_supportedSpecWithJavaxNetSslSSLSocket_withBoolean_(self, sslSocket, isFallback);
}

- (jboolean)isCompatibleWithJavaxNetSslSSLSocket:(JavaxNetSslSSLSocket *)socket {
  if (!tls_) {
    return false;
  }
  if (tlsVersions_ != nil && !Okhttp3ConnectionSpec_nonEmptyIntersectionWithNSStringArray_withNSStringArray_(tlsVersions_, [((JavaxNetSslSSLSocket *) nil_chk(socket)) getEnabledProtocols])) {
    return false;
  }
  if (cipherSuites_ != nil && !Okhttp3ConnectionSpec_nonEmptyIntersectionWithNSStringArray_withNSStringArray_(cipherSuites_, [((JavaxNetSslSSLSocket *) nil_chk(socket)) getEnabledCipherSuites])) {
    return false;
  }
  return true;
}

+ (jboolean)nonEmptyIntersectionWithNSStringArray:(IOSObjectArray *)a
                                withNSStringArray:(IOSObjectArray *)b {
  return Okhttp3ConnectionSpec_nonEmptyIntersectionWithNSStringArray_withNSStringArray_(a, b);
}

- (jboolean)isEqual:(id)other {
  if (!([other isKindOfClass:[Okhttp3ConnectionSpec class]])) return false;
  if (other == self) return true;
  Okhttp3ConnectionSpec *that = (Okhttp3ConnectionSpec *) cast_chk(other, [Okhttp3ConnectionSpec class]);
  if (self->tls_ != ((Okhttp3ConnectionSpec *) nil_chk(that))->tls_) return false;
  if (tls_) {
    if (!JavaUtilArrays_equalsWithNSObjectArray_withNSObjectArray_(self->cipherSuites_, that->cipherSuites_)) return false;
    if (!JavaUtilArrays_equalsWithNSObjectArray_withNSObjectArray_(self->tlsVersions_, that->tlsVersions_)) return false;
    if (self->supportsTlsExtensions_ != that->supportsTlsExtensions_) return false;
  }
  return true;
}

- (NSUInteger)hash {
  jint result = 17;
  if (tls_) {
    result = 31 * result + JavaUtilArrays_hashCodeWithNSObjectArray_(cipherSuites_);
    result = 31 * result + JavaUtilArrays_hashCodeWithNSObjectArray_(tlsVersions_);
    result = 31 * result + (supportsTlsExtensions_ ? 0 : 1);
  }
  return result;
}

- (NSString *)description {
  if (!tls_) {
    return @"ConnectionSpec()";
  }
  NSString *cipherSuitesString = cipherSuites_ != nil ? [((id<JavaUtilList>) nil_chk([self cipherSuites])) description] : @"[all enabled]";
  NSString *tlsVersionsString = tlsVersions_ != nil ? [((id<JavaUtilList>) nil_chk([self tlsVersions])) description] : @"[all enabled]";
  return JreStrcat("$$$$$ZC", @"ConnectionSpec(cipherSuites=", cipherSuitesString, @", tlsVersions=", tlsVersionsString, @", supportsTlsExtensions=", supportsTlsExtensions_, ')');
}

- (void)dealloc {
  RELEASE_(cipherSuites_);
  RELEASE_(tlsVersions_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, -1, -1, -1, 1, -1, -1 },
    { NULL, "LJavaUtilList;", 0x1, -1, -1, -1, 2, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 3, 4, -1, -1, -1, -1 },
    { NULL, "LOkhttp3ConnectionSpec;", 0x2, 5, 4, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "Z", 0xa, 8, 9, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 12, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 13, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOkhttp3ConnectionSpec_Builder:);
  methods[1].selector = @selector(isTls);
  methods[2].selector = @selector(cipherSuites);
  methods[3].selector = @selector(tlsVersions);
  methods[4].selector = @selector(supportsTlsExtensions);
  methods[5].selector = @selector(applyWithJavaxNetSslSSLSocket:withBoolean:);
  methods[6].selector = @selector(supportedSpecWithJavaxNetSslSSLSocket:withBoolean:);
  methods[7].selector = @selector(isCompatibleWithJavaxNetSslSSLSocket:);
  methods[8].selector = @selector(nonEmptyIntersectionWithNSStringArray:withNSStringArray:);
  methods[9].selector = @selector(isEqual:);
  methods[10].selector = @selector(hash);
  methods[11].selector = @selector(description);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "APPROVED_CIPHER_SUITES", "[LOkhttp3CipherSuite;", .constantValue.asLong = 0, 0x1a, -1, 14, -1, -1 },
    { "MODERN_TLS", "LOkhttp3ConnectionSpec;", .constantValue.asLong = 0, 0x19, -1, 15, -1, -1 },
    { "COMPATIBLE_TLS", "LOkhttp3ConnectionSpec;", .constantValue.asLong = 0, 0x19, -1, 16, -1, -1 },
    { "CLEARTEXT", "LOkhttp3ConnectionSpec;", .constantValue.asLong = 0, 0x19, -1, 17, -1, -1 },
    { "tls_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "supportsTlsExtensions_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "cipherSuites_", "[LNSString;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "tlsVersions_", "[LNSString;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOkhttp3ConnectionSpec_Builder;", "()Ljava/util/List<Lokhttp3/CipherSuite;>;", "()Ljava/util/List<Lokhttp3/TlsVersion;>;", "apply", "LJavaxNetSslSSLSocket;Z", "supportedSpec", "isCompatible", "LJavaxNetSslSSLSocket;", "nonEmptyIntersection", "[LNSString;[LNSString;", "equals", "LNSObject;", "hashCode", "toString", &Okhttp3ConnectionSpec_APPROVED_CIPHER_SUITES, &Okhttp3ConnectionSpec_MODERN_TLS, &Okhttp3ConnectionSpec_COMPATIBLE_TLS, &Okhttp3ConnectionSpec_CLEARTEXT };
  static const J2ObjcClassInfo _Okhttp3ConnectionSpec = { "ConnectionSpec", "okhttp3", ptrTable, methods, fields, 7, 0x11, 12, 8, -1, 0, -1, -1, -1 };
  return &_Okhttp3ConnectionSpec;
}

+ (void)initialize {
  if (self == [Okhttp3ConnectionSpec class]) {
    JreStrongAssignAndConsume(&Okhttp3ConnectionSpec_APPROVED_CIPHER_SUITES, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadStatic(Okhttp3CipherSuite, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256), JreLoadStatic(Okhttp3CipherSuite, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256), JreLoadStatic(Okhttp3CipherSuite, TLS_DHE_RSA_WITH_AES_128_GCM_SHA256), JreLoadStatic(Okhttp3CipherSuite, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA), JreLoadStatic(Okhttp3CipherSuite, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA), JreLoadStatic(Okhttp3CipherSuite, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA), JreLoadStatic(Okhttp3CipherSuite, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA), JreLoadStatic(Okhttp3CipherSuite, TLS_DHE_RSA_WITH_AES_128_CBC_SHA), JreLoadStatic(Okhttp3CipherSuite, TLS_DHE_RSA_WITH_AES_256_CBC_SHA), JreLoadStatic(Okhttp3CipherSuite, TLS_RSA_WITH_AES_128_GCM_SHA256), JreLoadStatic(Okhttp3CipherSuite, TLS_RSA_WITH_AES_128_CBC_SHA), JreLoadStatic(Okhttp3CipherSuite, TLS_RSA_WITH_AES_256_CBC_SHA), JreLoadStatic(Okhttp3CipherSuite, TLS_RSA_WITH_3DES_EDE_CBC_SHA) } count:13 type:Okhttp3CipherSuite_class_()]);
    JreStrongAssign(&Okhttp3ConnectionSpec_MODERN_TLS, [((Okhttp3ConnectionSpec_Builder *) nil_chk([((Okhttp3ConnectionSpec_Builder *) nil_chk(([((Okhttp3ConnectionSpec_Builder *) nil_chk([create_Okhttp3ConnectionSpec_Builder_initWithBoolean_(true) cipherSuitesWithOkhttp3CipherSuiteArray:Okhttp3ConnectionSpec_APPROVED_CIPHER_SUITES])) tlsVersionsWithOkhttp3TlsVersionArray:[IOSObjectArray arrayWithObjects:(id[]){ JreLoadEnum(Okhttp3TlsVersion, TLS_1_2), JreLoadEnum(Okhttp3TlsVersion, TLS_1_1), JreLoadEnum(Okhttp3TlsVersion, TLS_1_0) } count:3 type:Okhttp3TlsVersion_class_()]]))) supportsTlsExtensionsWithBoolean:true])) build]);
    JreStrongAssign(&Okhttp3ConnectionSpec_COMPATIBLE_TLS, [((Okhttp3ConnectionSpec_Builder *) nil_chk([((Okhttp3ConnectionSpec_Builder *) nil_chk(([create_Okhttp3ConnectionSpec_Builder_initWithOkhttp3ConnectionSpec_(Okhttp3ConnectionSpec_MODERN_TLS) tlsVersionsWithOkhttp3TlsVersionArray:[IOSObjectArray arrayWithObjects:(id[]){ JreLoadEnum(Okhttp3TlsVersion, TLS_1_0) } count:1 type:Okhttp3TlsVersion_class_()]]))) supportsTlsExtensionsWithBoolean:true])) build]);
    JreStrongAssign(&Okhttp3ConnectionSpec_CLEARTEXT, [create_Okhttp3ConnectionSpec_Builder_initWithBoolean_(false) build]);
    J2OBJC_SET_INITIALIZED(Okhttp3ConnectionSpec)
  }
}

@end

void Okhttp3ConnectionSpec_initWithOkhttp3ConnectionSpec_Builder_(Okhttp3ConnectionSpec *self, Okhttp3ConnectionSpec_Builder *builder) {
  NSObject_init(self);
  self->tls_ = ((Okhttp3ConnectionSpec_Builder *) nil_chk(builder))->tls_;
  JreStrongAssign(&self->cipherSuites_, builder->cipherSuites_);
  JreStrongAssign(&self->tlsVersions_, builder->tlsVersions_);
  self->supportsTlsExtensions_ = builder->supportsTlsExtensions_;
}

Okhttp3ConnectionSpec *new_Okhttp3ConnectionSpec_initWithOkhttp3ConnectionSpec_Builder_(Okhttp3ConnectionSpec_Builder *builder) {
  J2OBJC_NEW_IMPL(Okhttp3ConnectionSpec, initWithOkhttp3ConnectionSpec_Builder_, builder)
}

Okhttp3ConnectionSpec *create_Okhttp3ConnectionSpec_initWithOkhttp3ConnectionSpec_Builder_(Okhttp3ConnectionSpec_Builder *builder) {
  J2OBJC_CREATE_IMPL(Okhttp3ConnectionSpec, initWithOkhttp3ConnectionSpec_Builder_, builder)
}

Okhttp3ConnectionSpec *Okhttp3ConnectionSpec_supportedSpecWithJavaxNetSslSSLSocket_withBoolean_(Okhttp3ConnectionSpec *self, JavaxNetSslSSLSocket *sslSocket, jboolean isFallback) {
  IOSObjectArray *cipherSuitesIntersection = self->cipherSuites_ != nil ? Okhttp3InternalUtil_intersectWithIOSClass_withNSObjectArray_withNSObjectArray_(NSString_class_(), self->cipherSuites_, [((JavaxNetSslSSLSocket *) nil_chk(sslSocket)) getEnabledCipherSuites]) : [((JavaxNetSslSSLSocket *) nil_chk(sslSocket)) getEnabledCipherSuites];
  IOSObjectArray *tlsVersionsIntersection = self->tlsVersions_ != nil ? Okhttp3InternalUtil_intersectWithIOSClass_withNSObjectArray_withNSObjectArray_(NSString_class_(), self->tlsVersions_, [sslSocket getEnabledProtocols]) : [sslSocket getEnabledProtocols];
  if (isFallback && Okhttp3InternalUtil_indexOfWithNSObjectArray_withId_([sslSocket getSupportedCipherSuites], @"TLS_FALLBACK_SCSV") != -1) {
    cipherSuitesIntersection = Okhttp3InternalUtil_concatWithNSStringArray_withNSString_(cipherSuitesIntersection, @"TLS_FALLBACK_SCSV");
  }
  return [((Okhttp3ConnectionSpec_Builder *) nil_chk([((Okhttp3ConnectionSpec_Builder *) nil_chk([create_Okhttp3ConnectionSpec_Builder_initWithOkhttp3ConnectionSpec_(self) cipherSuitesWithNSStringArray:cipherSuitesIntersection])) tlsVersionsWithNSStringArray:tlsVersionsIntersection])) build];
}

jboolean Okhttp3ConnectionSpec_nonEmptyIntersectionWithNSStringArray_withNSStringArray_(IOSObjectArray *a, IOSObjectArray *b) {
  Okhttp3ConnectionSpec_initialize();
  if (a == nil || b == nil || a->size_ == 0 || b->size_ == 0) {
    return false;
  }
  {
    IOSObjectArray *a__ = a;
    NSString * const *b__ = a__->buffer_;
    NSString * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      NSString *toFind = *b__++;
      if (Okhttp3InternalUtil_indexOfWithNSObjectArray_withId_(b, toFind) != -1) {
        return true;
      }
    }
  }
  return false;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(Okhttp3ConnectionSpec)

@implementation Okhttp3ConnectionSpec_Builder

- (instancetype)initWithBoolean:(jboolean)tls {
  Okhttp3ConnectionSpec_Builder_initWithBoolean_(self, tls);
  return self;
}

- (instancetype)initWithOkhttp3ConnectionSpec:(Okhttp3ConnectionSpec *)connectionSpec {
  Okhttp3ConnectionSpec_Builder_initWithOkhttp3ConnectionSpec_(self, connectionSpec);
  return self;
}

- (Okhttp3ConnectionSpec_Builder *)allEnabledCipherSuites {
  if (!tls_) @throw create_JavaLangIllegalStateException_initWithNSString_(@"no cipher suites for cleartext connections");
  JreStrongAssign(&self->cipherSuites_, nil);
  return self;
}

- (Okhttp3ConnectionSpec_Builder *)cipherSuitesWithOkhttp3CipherSuiteArray:(IOSObjectArray *)cipherSuites {
  if (!tls_) @throw create_JavaLangIllegalStateException_initWithNSString_(@"no cipher suites for cleartext connections");
  IOSObjectArray *strings = [IOSObjectArray arrayWithLength:((IOSObjectArray *) nil_chk(cipherSuites))->size_ type:NSString_class_()];
  for (jint i = 0; i < cipherSuites->size_; i++) {
    IOSObjectArray_Set(strings, i, ((Okhttp3CipherSuite *) nil_chk(IOSObjectArray_Get(cipherSuites, i)))->javaName_);
  }
  return [self cipherSuitesWithNSStringArray:strings];
}

- (Okhttp3ConnectionSpec_Builder *)cipherSuitesWithNSStringArray:(IOSObjectArray *)cipherSuites {
  if (!tls_) @throw create_JavaLangIllegalStateException_initWithNSString_(@"no cipher suites for cleartext connections");
  if (((IOSObjectArray *) nil_chk(cipherSuites))->size_ == 0) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"At least one cipher suite is required");
  }
  JreStrongAssign(&self->cipherSuites_, [cipherSuites java_clone]);
  return self;
}

- (Okhttp3ConnectionSpec_Builder *)allEnabledTlsVersions {
  if (!tls_) @throw create_JavaLangIllegalStateException_initWithNSString_(@"no TLS versions for cleartext connections");
  JreStrongAssign(&self->tlsVersions_, nil);
  return self;
}

- (Okhttp3ConnectionSpec_Builder *)tlsVersionsWithOkhttp3TlsVersionArray:(IOSObjectArray *)tlsVersions {
  if (!tls_) @throw create_JavaLangIllegalStateException_initWithNSString_(@"no TLS versions for cleartext connections");
  IOSObjectArray *strings = [IOSObjectArray arrayWithLength:((IOSObjectArray *) nil_chk(tlsVersions))->size_ type:NSString_class_()];
  for (jint i = 0; i < tlsVersions->size_; i++) {
    IOSObjectArray_Set(strings, i, ((Okhttp3TlsVersion *) nil_chk(IOSObjectArray_Get(tlsVersions, i)))->javaName_);
  }
  return [self tlsVersionsWithNSStringArray:strings];
}

- (Okhttp3ConnectionSpec_Builder *)tlsVersionsWithNSStringArray:(IOSObjectArray *)tlsVersions {
  if (!tls_) @throw create_JavaLangIllegalStateException_initWithNSString_(@"no TLS versions for cleartext connections");
  if (((IOSObjectArray *) nil_chk(tlsVersions))->size_ == 0) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"At least one TLS version is required");
  }
  JreStrongAssign(&self->tlsVersions_, [tlsVersions java_clone]);
  return self;
}

- (Okhttp3ConnectionSpec_Builder *)supportsTlsExtensionsWithBoolean:(jboolean)supportsTlsExtensions {
  if (!tls_) @throw create_JavaLangIllegalStateException_initWithNSString_(@"no TLS extensions for cleartext connections");
  self->supportsTlsExtensions_ = supportsTlsExtensions;
  return self;
}

- (Okhttp3ConnectionSpec *)build {
  return create_Okhttp3ConnectionSpec_initWithOkhttp3ConnectionSpec_Builder_(self);
}

- (void)dealloc {
  RELEASE_(cipherSuites_);
  RELEASE_(tlsVersions_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "LOkhttp3ConnectionSpec_Builder;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOkhttp3ConnectionSpec_Builder;", 0x81, 2, 3, -1, -1, -1, -1 },
    { NULL, "LOkhttp3ConnectionSpec_Builder;", 0x81, 2, 4, -1, -1, -1, -1 },
    { NULL, "LOkhttp3ConnectionSpec_Builder;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOkhttp3ConnectionSpec_Builder;", 0x81, 5, 6, -1, -1, -1, -1 },
    { NULL, "LOkhttp3ConnectionSpec_Builder;", 0x81, 5, 4, -1, -1, -1, -1 },
    { NULL, "LOkhttp3ConnectionSpec_Builder;", 0x1, 7, 0, -1, -1, -1, -1 },
    { NULL, "LOkhttp3ConnectionSpec;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithBoolean:);
  methods[1].selector = @selector(initWithOkhttp3ConnectionSpec:);
  methods[2].selector = @selector(allEnabledCipherSuites);
  methods[3].selector = @selector(cipherSuitesWithOkhttp3CipherSuiteArray:);
  methods[4].selector = @selector(cipherSuitesWithNSStringArray:);
  methods[5].selector = @selector(allEnabledTlsVersions);
  methods[6].selector = @selector(tlsVersionsWithOkhttp3TlsVersionArray:);
  methods[7].selector = @selector(tlsVersionsWithNSStringArray:);
  methods[8].selector = @selector(supportsTlsExtensionsWithBoolean:);
  methods[9].selector = @selector(build);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "tls_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "cipherSuites_", "[LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "tlsVersions_", "[LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "supportsTlsExtensions_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "Z", "LOkhttp3ConnectionSpec;", "cipherSuites", "[LOkhttp3CipherSuite;", "[LNSString;", "tlsVersions", "[LOkhttp3TlsVersion;", "supportsTlsExtensions" };
  static const J2ObjcClassInfo _Okhttp3ConnectionSpec_Builder = { "Builder", "okhttp3", ptrTable, methods, fields, 7, 0x19, 10, 4, 1, -1, -1, -1, -1 };
  return &_Okhttp3ConnectionSpec_Builder;
}

@end

void Okhttp3ConnectionSpec_Builder_initWithBoolean_(Okhttp3ConnectionSpec_Builder *self, jboolean tls) {
  NSObject_init(self);
  self->tls_ = tls;
}

Okhttp3ConnectionSpec_Builder *new_Okhttp3ConnectionSpec_Builder_initWithBoolean_(jboolean tls) {
  J2OBJC_NEW_IMPL(Okhttp3ConnectionSpec_Builder, initWithBoolean_, tls)
}

Okhttp3ConnectionSpec_Builder *create_Okhttp3ConnectionSpec_Builder_initWithBoolean_(jboolean tls) {
  J2OBJC_CREATE_IMPL(Okhttp3ConnectionSpec_Builder, initWithBoolean_, tls)
}

void Okhttp3ConnectionSpec_Builder_initWithOkhttp3ConnectionSpec_(Okhttp3ConnectionSpec_Builder *self, Okhttp3ConnectionSpec *connectionSpec) {
  NSObject_init(self);
  self->tls_ = ((Okhttp3ConnectionSpec *) nil_chk(connectionSpec))->tls_;
  JreStrongAssign(&self->cipherSuites_, connectionSpec->cipherSuites_);
  JreStrongAssign(&self->tlsVersions_, connectionSpec->tlsVersions_);
  self->supportsTlsExtensions_ = connectionSpec->supportsTlsExtensions_;
}

Okhttp3ConnectionSpec_Builder *new_Okhttp3ConnectionSpec_Builder_initWithOkhttp3ConnectionSpec_(Okhttp3ConnectionSpec *connectionSpec) {
  J2OBJC_NEW_IMPL(Okhttp3ConnectionSpec_Builder, initWithOkhttp3ConnectionSpec_, connectionSpec)
}

Okhttp3ConnectionSpec_Builder *create_Okhttp3ConnectionSpec_Builder_initWithOkhttp3ConnectionSpec_(Okhttp3ConnectionSpec *connectionSpec) {
  J2OBJC_CREATE_IMPL(Okhttp3ConnectionSpec_Builder, initWithOkhttp3ConnectionSpec_, connectionSpec)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(Okhttp3ConnectionSpec_Builder)
