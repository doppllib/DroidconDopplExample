//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "J2ObjC_source.h"
#include "Okhttp3HttpUrl.h"
#include "Okhttp3InternalConnectionRouteException.h"
#include "Okhttp3InternalHttpUnrepeatableRequestBody.h"
#include "Okhttp3InternalUtil.h"
#include "Okhttp3Request.h"
#include "Okhttp3RequestBody.h"
#include "Okhttp3Response.h"
#include "Okhttp3ResponseBody.h"
#include "Retrofit2IosInterceptor.h"
#include "Retrofit2IosIosCallFactory.h"
#include "Retrofit2IosIosRetryAndFollowUpInterceptor.h"
#include "Retrofit2IosRealInterceptorChain.h"
#include "java/io/IOException.h"
#include "java/io/InterruptedIOException.h"
#include "java/lang/Throwable.h"
#include "java/net/HttpRetryException.h"
#include "java/net/HttpURLConnection.h"
#include "java/net/ProtocolException.h"
#include "java/net/SocketTimeoutException.h"
#include "java/security/cert/CertificateException.h"
#include "javax/net/ssl/SSLHandshakeException.h"
#include "javax/net/ssl/SSLPeerUnverifiedException.h"

@interface Retrofit2IosIosRetryAndFollowUpInterceptor () {
 @public
  Retrofit2IosIosCallFactory *client_;
  volatile_jboolean canceled_;
  JavaNetHttpURLConnection *connection_;
}

- (jboolean)recoverWithJavaIoIOException:(JavaIoIOException *)e
                             withBoolean:(jboolean)routeException
                      withOkhttp3Request:(Okhttp3Request *)userRequest;

- (jboolean)isRecoverableWithJavaIoIOException:(JavaIoIOException *)e
                                   withBoolean:(jboolean)routeException;

- (jboolean)sameConnectionWithOkhttp3Response:(Okhttp3Response *)response
                           withOkhttp3HttpUrl:(Okhttp3HttpUrl *)followUp;

@end

J2OBJC_FIELD_SETTER(Retrofit2IosIosRetryAndFollowUpInterceptor, client_, Retrofit2IosIosCallFactory *)
J2OBJC_FIELD_SETTER(Retrofit2IosIosRetryAndFollowUpInterceptor, connection_, JavaNetHttpURLConnection *)

inline jint Retrofit2IosIosRetryAndFollowUpInterceptor_get_MAX_FOLLOW_UPS();
#define Retrofit2IosIosRetryAndFollowUpInterceptor_MAX_FOLLOW_UPS 20
J2OBJC_STATIC_FIELD_CONSTANT(Retrofit2IosIosRetryAndFollowUpInterceptor, MAX_FOLLOW_UPS, jint)

__attribute__((unused)) static jboolean Retrofit2IosIosRetryAndFollowUpInterceptor_recoverWithJavaIoIOException_withBoolean_withOkhttp3Request_(Retrofit2IosIosRetryAndFollowUpInterceptor *self, JavaIoIOException *e, jboolean routeException, Okhttp3Request *userRequest);

__attribute__((unused)) static jboolean Retrofit2IosIosRetryAndFollowUpInterceptor_isRecoverableWithJavaIoIOException_withBoolean_(Retrofit2IosIosRetryAndFollowUpInterceptor *self, JavaIoIOException *e, jboolean routeException);

__attribute__((unused)) static jboolean Retrofit2IosIosRetryAndFollowUpInterceptor_sameConnectionWithOkhttp3Response_withOkhttp3HttpUrl_(Retrofit2IosIosRetryAndFollowUpInterceptor *self, Okhttp3Response *response, Okhttp3HttpUrl *followUp);

@implementation Retrofit2IosIosRetryAndFollowUpInterceptor

- (instancetype)initWithRetrofit2IosIosCallFactory:(Retrofit2IosIosCallFactory *)client {
  Retrofit2IosIosRetryAndFollowUpInterceptor_initWithRetrofit2IosIosCallFactory_(self, client);
  return self;
}

- (void)cancel {
  JreAssignVolatileBoolean(&canceled_, true);
  JavaNetHttpURLConnection *streamAllocation = self->connection_;
  if (streamAllocation != nil) [streamAllocation disconnect];
}

- (jboolean)isCanceled {
  return JreLoadVolatileBoolean(&canceled_);
}

- (Retrofit2IosIosCallFactory *)client {
  return client_;
}

- (Okhttp3Response *)interceptWithRetrofit2IosInterceptor_Chain:(id<Retrofit2IosInterceptor_Chain>)chain {
  Okhttp3Request *request = [((id<Retrofit2IosInterceptor_Chain>) nil_chk(chain)) request];
  jint followUpCount = 0;
  Okhttp3Response *priorResponse = nil;
  while (true) {
    if (JreLoadVolatileBoolean(&canceled_)) {
      @throw create_JavaIoIOException_initWithNSString_(@"Canceled");
    }
    Okhttp3Response *response = nil;
    jboolean releaseConnection = true;
    @try {
      response = [((Retrofit2IosRealInterceptorChain *) cast_chk(chain, [Retrofit2IosRealInterceptorChain class])) proceedWithOkhttp3Request:request withJavaNetHttpURLConnection:connection_];
      releaseConnection = false;
    }
    @catch (Okhttp3InternalConnectionRouteException *e) {
      if (!Retrofit2IosIosRetryAndFollowUpInterceptor_recoverWithJavaIoIOException_withBoolean_withOkhttp3Request_(self, [e getLastConnectException], true, request)) @throw nil_chk([e getLastConnectException]);
      releaseConnection = false;
      continue;
    }
    @catch (JavaIoIOException *e) {
      if (!Retrofit2IosIosRetryAndFollowUpInterceptor_recoverWithJavaIoIOException_withBoolean_withOkhttp3Request_(self, e, false, request)) @throw e;
      releaseConnection = false;
      continue;
    }
    @finally {
      if (releaseConnection) {
      }
    }
    if (priorResponse != nil) {
      response = [((Okhttp3Response_Builder *) nil_chk([((Okhttp3Response_Builder *) nil_chk([((Okhttp3Response *) nil_chk(response)) newBuilder])) priorResponseWithOkhttp3Response:[((Okhttp3Response_Builder *) nil_chk([((Okhttp3Response_Builder *) nil_chk([priorResponse newBuilder])) bodyWithOkhttp3ResponseBody:nil])) build]])) build];
    }
    Okhttp3Request *followUp = nil;
    if (followUp == nil) {
      return response;
    }
    Okhttp3InternalUtil_closeQuietlyWithJavaIoCloseable_([((Okhttp3Response *) nil_chk(response)) body]);
    if (++followUpCount > Retrofit2IosIosRetryAndFollowUpInterceptor_MAX_FOLLOW_UPS) {
      @throw create_JavaNetProtocolException_initWithNSString_(JreStrcat("$I", @"Too many follow-up requests: ", followUpCount));
    }
    if ([Okhttp3InternalHttpUnrepeatableRequestBody_class_() isInstance:[followUp body]]) {
      @throw create_JavaNetHttpRetryException_initWithNSString_withInt_(@"Cannot retry streamed HTTP body", [response code]);
    }
    if (!Retrofit2IosIosRetryAndFollowUpInterceptor_sameConnectionWithOkhttp3Response_withOkhttp3HttpUrl_(self, response, [followUp url])) {
    }
    request = followUp;
    priorResponse = response;
  }
}

- (jboolean)recoverWithJavaIoIOException:(JavaIoIOException *)e
                             withBoolean:(jboolean)routeException
                      withOkhttp3Request:(Okhttp3Request *)userRequest {
  return Retrofit2IosIosRetryAndFollowUpInterceptor_recoverWithJavaIoIOException_withBoolean_withOkhttp3Request_(self, e, routeException, userRequest);
}

- (jboolean)isRecoverableWithJavaIoIOException:(JavaIoIOException *)e
                                   withBoolean:(jboolean)routeException {
  return Retrofit2IosIosRetryAndFollowUpInterceptor_isRecoverableWithJavaIoIOException_withBoolean_(self, e, routeException);
}

- (jboolean)sameConnectionWithOkhttp3Response:(Okhttp3Response *)response
                           withOkhttp3HttpUrl:(Okhttp3HttpUrl *)followUp {
  return Retrofit2IosIosRetryAndFollowUpInterceptor_sameConnectionWithOkhttp3Response_withOkhttp3HttpUrl_(self, response, followUp);
}

- (void)dealloc {
  RELEASE_(client_);
  RELEASE_(connection_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LRetrofit2IosIosCallFactory;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOkhttp3Response;", 0x1, 1, 2, 3, -1, -1, -1 },
    { NULL, "Z", 0x2, 4, 5, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 6, 7, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 8, 9, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithRetrofit2IosIosCallFactory:);
  methods[1].selector = @selector(cancel);
  methods[2].selector = @selector(isCanceled);
  methods[3].selector = @selector(client);
  methods[4].selector = @selector(interceptWithRetrofit2IosInterceptor_Chain:);
  methods[5].selector = @selector(recoverWithJavaIoIOException:withBoolean:withOkhttp3Request:);
  methods[6].selector = @selector(isRecoverableWithJavaIoIOException:withBoolean:);
  methods[7].selector = @selector(sameConnectionWithOkhttp3Response:withOkhttp3HttpUrl:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "MAX_FOLLOW_UPS", "I", .constantValue.asInt = Retrofit2IosIosRetryAndFollowUpInterceptor_MAX_FOLLOW_UPS, 0x1a, -1, -1, -1, -1 },
    { "client_", "LRetrofit2IosIosCallFactory;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "canceled_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
    { "connection_", "LJavaNetHttpURLConnection;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LRetrofit2IosIosCallFactory;", "intercept", "LRetrofit2IosInterceptor_Chain;", "LJavaIoIOException;", "recover", "LJavaIoIOException;ZLOkhttp3Request;", "isRecoverable", "LJavaIoIOException;Z", "sameConnection", "LOkhttp3Response;LOkhttp3HttpUrl;" };
  static const J2ObjcClassInfo _Retrofit2IosIosRetryAndFollowUpInterceptor = { "IosRetryAndFollowUpInterceptor", "retrofit2.ios", ptrTable, methods, fields, 7, 0x1, 8, 4, -1, -1, -1, -1, -1 };
  return &_Retrofit2IosIosRetryAndFollowUpInterceptor;
}

@end

void Retrofit2IosIosRetryAndFollowUpInterceptor_initWithRetrofit2IosIosCallFactory_(Retrofit2IosIosRetryAndFollowUpInterceptor *self, Retrofit2IosIosCallFactory *client) {
  NSObject_init(self);
  JreStrongAssign(&self->client_, client);
}

Retrofit2IosIosRetryAndFollowUpInterceptor *new_Retrofit2IosIosRetryAndFollowUpInterceptor_initWithRetrofit2IosIosCallFactory_(Retrofit2IosIosCallFactory *client) {
  J2OBJC_NEW_IMPL(Retrofit2IosIosRetryAndFollowUpInterceptor, initWithRetrofit2IosIosCallFactory_, client)
}

Retrofit2IosIosRetryAndFollowUpInterceptor *create_Retrofit2IosIosRetryAndFollowUpInterceptor_initWithRetrofit2IosIosCallFactory_(Retrofit2IosIosCallFactory *client) {
  J2OBJC_CREATE_IMPL(Retrofit2IosIosRetryAndFollowUpInterceptor, initWithRetrofit2IosIosCallFactory_, client)
}

jboolean Retrofit2IosIosRetryAndFollowUpInterceptor_recoverWithJavaIoIOException_withBoolean_withOkhttp3Request_(Retrofit2IosIosRetryAndFollowUpInterceptor *self, JavaIoIOException *e, jboolean routeException, Okhttp3Request *userRequest) {
  if (![((Retrofit2IosIosCallFactory *) nil_chk(self->client_)) retryOnConnectionFailure]) return false;
  if (!routeException && [Okhttp3InternalHttpUnrepeatableRequestBody_class_() isInstance:[((Okhttp3Request *) nil_chk(userRequest)) body]]) return false;
  if (!Retrofit2IosIosRetryAndFollowUpInterceptor_isRecoverableWithJavaIoIOException_withBoolean_(self, e, routeException)) return false;
  return false;
}

jboolean Retrofit2IosIosRetryAndFollowUpInterceptor_isRecoverableWithJavaIoIOException_withBoolean_(Retrofit2IosIosRetryAndFollowUpInterceptor *self, JavaIoIOException *e, jboolean routeException) {
  if ([e isKindOfClass:[JavaNetProtocolException class]]) {
    return false;
  }
  if ([e isKindOfClass:[JavaIoInterruptedIOException class]]) {
    return [e isKindOfClass:[JavaNetSocketTimeoutException class]] && routeException;
  }
  if ([e isKindOfClass:[JavaxNetSslSSLHandshakeException class]]) {
    if ([[((JavaIoIOException *) nil_chk(e)) getCause] isKindOfClass:[JavaSecurityCertCertificateException class]]) {
      return false;
    }
  }
  if ([e isKindOfClass:[JavaxNetSslSSLPeerUnverifiedException class]]) {
    return false;
  }
  return true;
}

jboolean Retrofit2IosIosRetryAndFollowUpInterceptor_sameConnectionWithOkhttp3Response_withOkhttp3HttpUrl_(Retrofit2IosIosRetryAndFollowUpInterceptor *self, Okhttp3Response *response, Okhttp3HttpUrl *followUp) {
  Okhttp3HttpUrl *url = [((Okhttp3Request *) nil_chk([((Okhttp3Response *) nil_chk(response)) request])) url];
  return [((NSString *) nil_chk([((Okhttp3HttpUrl *) nil_chk(url)) host])) isEqual:[((Okhttp3HttpUrl *) nil_chk(followUp)) host]] && [url port] == [followUp port] && [((NSString *) nil_chk([url scheme])) isEqual:[followUp scheme]];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(Retrofit2IosIosRetryAndFollowUpInterceptor)
