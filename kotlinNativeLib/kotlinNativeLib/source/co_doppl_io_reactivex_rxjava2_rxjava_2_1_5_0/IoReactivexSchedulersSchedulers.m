//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "IoReactivexInternalSchedulersComputationScheduler.h"
#include "IoReactivexInternalSchedulersExecutorScheduler.h"
#include "IoReactivexInternalSchedulersIoScheduler.h"
#include "IoReactivexInternalSchedulersNewThreadScheduler.h"
#include "IoReactivexInternalSchedulersSchedulerPoolFactory.h"
#include "IoReactivexInternalSchedulersSingleScheduler.h"
#include "IoReactivexInternalSchedulersTrampolineScheduler.h"
#include "IoReactivexPluginsRxJavaPlugins.h"
#include "IoReactivexScheduler.h"
#include "IoReactivexSchedulersSchedulers.h"
#include "J2ObjC_source.h"
#include "java/lang/IllegalStateException.h"
#include "java/util/concurrent/Executor.h"

@interface IoReactivexSchedulersSchedulers ()

- (instancetype)init;

@end

__attribute__((unused)) static void IoReactivexSchedulersSchedulers_init(IoReactivexSchedulersSchedulers *self);

__attribute__((unused)) static IoReactivexSchedulersSchedulers *new_IoReactivexSchedulersSchedulers_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static IoReactivexSchedulersSchedulers *create_IoReactivexSchedulersSchedulers_init();

J2OBJC_INITIALIZED_DEFN(IoReactivexSchedulersSchedulers)

IoReactivexScheduler *IoReactivexSchedulersSchedulers_SINGLE;
IoReactivexScheduler *IoReactivexSchedulersSchedulers_COMPUTATION;
IoReactivexScheduler *IoReactivexSchedulersSchedulers_IO;
IoReactivexScheduler *IoReactivexSchedulersSchedulers_TRAMPOLINE;
IoReactivexScheduler *IoReactivexSchedulersSchedulers_NEW_THREAD;

@implementation IoReactivexSchedulersSchedulers

+ (IoReactivexScheduler *)SINGLE {
  return IoReactivexSchedulersSchedulers_SINGLE;
}

+ (IoReactivexScheduler *)COMPUTATION {
  return IoReactivexSchedulersSchedulers_COMPUTATION;
}

+ (IoReactivexScheduler *)IO {
  return IoReactivexSchedulersSchedulers_IO;
}

+ (IoReactivexScheduler *)TRAMPOLINE {
  return IoReactivexSchedulersSchedulers_TRAMPOLINE;
}

+ (IoReactivexScheduler *)NEW_THREAD {
  return IoReactivexSchedulersSchedulers_NEW_THREAD;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexSchedulersSchedulers_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (IoReactivexScheduler * __nonnull)computation {
  return IoReactivexSchedulersSchedulers_computation();
}

+ (IoReactivexScheduler * __nonnull)io {
  return IoReactivexSchedulersSchedulers_io();
}

+ (IoReactivexScheduler * __nonnull)trampoline {
  return IoReactivexSchedulersSchedulers_trampoline();
}

+ (IoReactivexScheduler * __nonnull)newThread {
  return IoReactivexSchedulersSchedulers_newThread();
}

+ (IoReactivexScheduler * __nonnull)single {
  return IoReactivexSchedulersSchedulers_single();
}

+ (IoReactivexScheduler * __nonnull)fromWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor {
  return IoReactivexSchedulersSchedulers_fromWithJavaUtilConcurrentExecutor_(executor);
}

+ (void)shutdown {
  IoReactivexSchedulersSchedulers_shutdown();
}

+ (void)start {
  IoReactivexSchedulersSchedulers_start();
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler;", 0x9, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(computation);
  methods[2].selector = @selector(io);
  methods[3].selector = @selector(trampoline);
  methods[4].selector = @selector(newThread);
  methods[5].selector = @selector(single);
  methods[6].selector = @selector(fromWithJavaUtilConcurrentExecutor:);
  methods[7].selector = @selector(shutdown);
  methods[8].selector = @selector(start);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "SINGLE", "LIoReactivexScheduler;", .constantValue.asLong = 0, 0x18, -1, 2, -1, -1 },
    { "COMPUTATION", "LIoReactivexScheduler;", .constantValue.asLong = 0, 0x18, -1, 3, -1, -1 },
    { "IO", "LIoReactivexScheduler;", .constantValue.asLong = 0, 0x18, -1, 4, -1, -1 },
    { "TRAMPOLINE", "LIoReactivexScheduler;", .constantValue.asLong = 0, 0x18, -1, 5, -1, -1 },
    { "NEW_THREAD", "LIoReactivexScheduler;", .constantValue.asLong = 0, 0x18, -1, 6, -1, -1 },
  };
  static const void *ptrTable[] = { "from", "LJavaUtilConcurrentExecutor;", &IoReactivexSchedulersSchedulers_SINGLE, &IoReactivexSchedulersSchedulers_COMPUTATION, &IoReactivexSchedulersSchedulers_IO, &IoReactivexSchedulersSchedulers_TRAMPOLINE, &IoReactivexSchedulersSchedulers_NEW_THREAD, "LIoReactivexSchedulersSchedulers_SingleHolder;LIoReactivexSchedulersSchedulers_ComputationHolder;LIoReactivexSchedulersSchedulers_IoHolder;LIoReactivexSchedulersSchedulers_NewThreadHolder;LIoReactivexSchedulersSchedulers_IOTask;LIoReactivexSchedulersSchedulers_NewThreadTask;LIoReactivexSchedulersSchedulers_SingleTask;LIoReactivexSchedulersSchedulers_ComputationTask;" };
  static const J2ObjcClassInfo _IoReactivexSchedulersSchedulers = { "Schedulers", "io.reactivex.schedulers", ptrTable, methods, fields, 7, 0x11, 9, 5, -1, 7, -1, -1, -1 };
  return &_IoReactivexSchedulersSchedulers;
}

+ (void)initialize {
  if (self == [IoReactivexSchedulersSchedulers class]) {
    {
      JreStrongAssign(&IoReactivexSchedulersSchedulers_SINGLE, IoReactivexPluginsRxJavaPlugins_initSingleSchedulerWithJavaUtilConcurrentCallable_(create_IoReactivexSchedulersSchedulers_SingleTask_init()));
      JreStrongAssign(&IoReactivexSchedulersSchedulers_COMPUTATION, IoReactivexPluginsRxJavaPlugins_initComputationSchedulerWithJavaUtilConcurrentCallable_(create_IoReactivexSchedulersSchedulers_ComputationTask_init()));
      JreStrongAssign(&IoReactivexSchedulersSchedulers_IO, IoReactivexPluginsRxJavaPlugins_initIoSchedulerWithJavaUtilConcurrentCallable_(create_IoReactivexSchedulersSchedulers_IOTask_init()));
      JreStrongAssign(&IoReactivexSchedulersSchedulers_TRAMPOLINE, IoReactivexInternalSchedulersTrampolineScheduler_instance());
      JreStrongAssign(&IoReactivexSchedulersSchedulers_NEW_THREAD, IoReactivexPluginsRxJavaPlugins_initNewThreadSchedulerWithJavaUtilConcurrentCallable_(create_IoReactivexSchedulersSchedulers_NewThreadTask_init()));
    }
    J2OBJC_SET_INITIALIZED(IoReactivexSchedulersSchedulers)
  }
}

@end

void IoReactivexSchedulersSchedulers_init(IoReactivexSchedulersSchedulers *self) {
  NSObject_init(self);
  @throw create_JavaLangIllegalStateException_initWithNSString_(@"No instances!");
}

IoReactivexSchedulersSchedulers *new_IoReactivexSchedulersSchedulers_init() {
  J2OBJC_NEW_IMPL(IoReactivexSchedulersSchedulers, init)
}

IoReactivexSchedulersSchedulers *create_IoReactivexSchedulersSchedulers_init() {
  J2OBJC_CREATE_IMPL(IoReactivexSchedulersSchedulers, init)
}

IoReactivexScheduler *IoReactivexSchedulersSchedulers_computation() {
  IoReactivexSchedulersSchedulers_initialize();
  return IoReactivexPluginsRxJavaPlugins_onComputationSchedulerWithIoReactivexScheduler_(IoReactivexSchedulersSchedulers_COMPUTATION);
}

IoReactivexScheduler *IoReactivexSchedulersSchedulers_io() {
  IoReactivexSchedulersSchedulers_initialize();
  return IoReactivexPluginsRxJavaPlugins_onIoSchedulerWithIoReactivexScheduler_(IoReactivexSchedulersSchedulers_IO);
}

IoReactivexScheduler *IoReactivexSchedulersSchedulers_trampoline() {
  IoReactivexSchedulersSchedulers_initialize();
  return IoReactivexSchedulersSchedulers_TRAMPOLINE;
}

IoReactivexScheduler *IoReactivexSchedulersSchedulers_newThread() {
  IoReactivexSchedulersSchedulers_initialize();
  return IoReactivexPluginsRxJavaPlugins_onNewThreadSchedulerWithIoReactivexScheduler_(IoReactivexSchedulersSchedulers_NEW_THREAD);
}

IoReactivexScheduler *IoReactivexSchedulersSchedulers_single() {
  IoReactivexSchedulersSchedulers_initialize();
  return IoReactivexPluginsRxJavaPlugins_onSingleSchedulerWithIoReactivexScheduler_(IoReactivexSchedulersSchedulers_SINGLE);
}

IoReactivexScheduler *IoReactivexSchedulersSchedulers_fromWithJavaUtilConcurrentExecutor_(id<JavaUtilConcurrentExecutor> executor) {
  IoReactivexSchedulersSchedulers_initialize();
  return create_IoReactivexInternalSchedulersExecutorScheduler_initWithJavaUtilConcurrentExecutor_(executor);
}

void IoReactivexSchedulersSchedulers_shutdown() {
  IoReactivexSchedulersSchedulers_initialize();
  [((IoReactivexScheduler *) nil_chk(IoReactivexSchedulersSchedulers_computation())) shutdown];
  [((IoReactivexScheduler *) nil_chk(IoReactivexSchedulersSchedulers_io())) shutdown];
  [((IoReactivexScheduler *) nil_chk(IoReactivexSchedulersSchedulers_newThread())) shutdown];
  [((IoReactivexScheduler *) nil_chk(IoReactivexSchedulersSchedulers_single())) shutdown];
  [((IoReactivexScheduler *) nil_chk(IoReactivexSchedulersSchedulers_trampoline())) shutdown];
  IoReactivexInternalSchedulersSchedulerPoolFactory_shutdown();
}

void IoReactivexSchedulersSchedulers_start() {
  IoReactivexSchedulersSchedulers_initialize();
  [((IoReactivexScheduler *) nil_chk(IoReactivexSchedulersSchedulers_computation())) start];
  [((IoReactivexScheduler *) nil_chk(IoReactivexSchedulersSchedulers_io())) start];
  [((IoReactivexScheduler *) nil_chk(IoReactivexSchedulersSchedulers_newThread())) start];
  [((IoReactivexScheduler *) nil_chk(IoReactivexSchedulersSchedulers_single())) start];
  [((IoReactivexScheduler *) nil_chk(IoReactivexSchedulersSchedulers_trampoline())) start];
  IoReactivexInternalSchedulersSchedulerPoolFactory_start();
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexSchedulersSchedulers)

J2OBJC_INITIALIZED_DEFN(IoReactivexSchedulersSchedulers_SingleHolder)

IoReactivexScheduler *IoReactivexSchedulersSchedulers_SingleHolder_DEFAULT;

@implementation IoReactivexSchedulersSchedulers_SingleHolder

+ (IoReactivexScheduler *)DEFAULT {
  return IoReactivexSchedulersSchedulers_SingleHolder_DEFAULT;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexSchedulersSchedulers_SingleHolder_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEFAULT", "LIoReactivexScheduler;", .constantValue.asLong = 0, 0x18, -1, 0, -1, -1 },
  };
  static const void *ptrTable[] = { &IoReactivexSchedulersSchedulers_SingleHolder_DEFAULT, "LIoReactivexSchedulersSchedulers;" };
  static const J2ObjcClassInfo _IoReactivexSchedulersSchedulers_SingleHolder = { "SingleHolder", "io.reactivex.schedulers", ptrTable, methods, fields, 7, 0x18, 1, 1, 1, -1, -1, -1, -1 };
  return &_IoReactivexSchedulersSchedulers_SingleHolder;
}

+ (void)initialize {
  if (self == [IoReactivexSchedulersSchedulers_SingleHolder class]) {
    JreStrongAssignAndConsume(&IoReactivexSchedulersSchedulers_SingleHolder_DEFAULT, new_IoReactivexInternalSchedulersSingleScheduler_init());
    J2OBJC_SET_INITIALIZED(IoReactivexSchedulersSchedulers_SingleHolder)
  }
}

@end

void IoReactivexSchedulersSchedulers_SingleHolder_init(IoReactivexSchedulersSchedulers_SingleHolder *self) {
  NSObject_init(self);
}

IoReactivexSchedulersSchedulers_SingleHolder *new_IoReactivexSchedulersSchedulers_SingleHolder_init() {
  J2OBJC_NEW_IMPL(IoReactivexSchedulersSchedulers_SingleHolder, init)
}

IoReactivexSchedulersSchedulers_SingleHolder *create_IoReactivexSchedulersSchedulers_SingleHolder_init() {
  J2OBJC_CREATE_IMPL(IoReactivexSchedulersSchedulers_SingleHolder, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexSchedulersSchedulers_SingleHolder)

J2OBJC_INITIALIZED_DEFN(IoReactivexSchedulersSchedulers_ComputationHolder)

IoReactivexScheduler *IoReactivexSchedulersSchedulers_ComputationHolder_DEFAULT;

@implementation IoReactivexSchedulersSchedulers_ComputationHolder

+ (IoReactivexScheduler *)DEFAULT {
  return IoReactivexSchedulersSchedulers_ComputationHolder_DEFAULT;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexSchedulersSchedulers_ComputationHolder_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEFAULT", "LIoReactivexScheduler;", .constantValue.asLong = 0, 0x18, -1, 0, -1, -1 },
  };
  static const void *ptrTable[] = { &IoReactivexSchedulersSchedulers_ComputationHolder_DEFAULT, "LIoReactivexSchedulersSchedulers;" };
  static const J2ObjcClassInfo _IoReactivexSchedulersSchedulers_ComputationHolder = { "ComputationHolder", "io.reactivex.schedulers", ptrTable, methods, fields, 7, 0x18, 1, 1, 1, -1, -1, -1, -1 };
  return &_IoReactivexSchedulersSchedulers_ComputationHolder;
}

+ (void)initialize {
  if (self == [IoReactivexSchedulersSchedulers_ComputationHolder class]) {
    JreStrongAssignAndConsume(&IoReactivexSchedulersSchedulers_ComputationHolder_DEFAULT, new_IoReactivexInternalSchedulersComputationScheduler_init());
    J2OBJC_SET_INITIALIZED(IoReactivexSchedulersSchedulers_ComputationHolder)
  }
}

@end

void IoReactivexSchedulersSchedulers_ComputationHolder_init(IoReactivexSchedulersSchedulers_ComputationHolder *self) {
  NSObject_init(self);
}

IoReactivexSchedulersSchedulers_ComputationHolder *new_IoReactivexSchedulersSchedulers_ComputationHolder_init() {
  J2OBJC_NEW_IMPL(IoReactivexSchedulersSchedulers_ComputationHolder, init)
}

IoReactivexSchedulersSchedulers_ComputationHolder *create_IoReactivexSchedulersSchedulers_ComputationHolder_init() {
  J2OBJC_CREATE_IMPL(IoReactivexSchedulersSchedulers_ComputationHolder, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexSchedulersSchedulers_ComputationHolder)

J2OBJC_INITIALIZED_DEFN(IoReactivexSchedulersSchedulers_IoHolder)

IoReactivexScheduler *IoReactivexSchedulersSchedulers_IoHolder_DEFAULT;

@implementation IoReactivexSchedulersSchedulers_IoHolder

+ (IoReactivexScheduler *)DEFAULT {
  return IoReactivexSchedulersSchedulers_IoHolder_DEFAULT;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexSchedulersSchedulers_IoHolder_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEFAULT", "LIoReactivexScheduler;", .constantValue.asLong = 0, 0x18, -1, 0, -1, -1 },
  };
  static const void *ptrTable[] = { &IoReactivexSchedulersSchedulers_IoHolder_DEFAULT, "LIoReactivexSchedulersSchedulers;" };
  static const J2ObjcClassInfo _IoReactivexSchedulersSchedulers_IoHolder = { "IoHolder", "io.reactivex.schedulers", ptrTable, methods, fields, 7, 0x18, 1, 1, 1, -1, -1, -1, -1 };
  return &_IoReactivexSchedulersSchedulers_IoHolder;
}

+ (void)initialize {
  if (self == [IoReactivexSchedulersSchedulers_IoHolder class]) {
    JreStrongAssignAndConsume(&IoReactivexSchedulersSchedulers_IoHolder_DEFAULT, new_IoReactivexInternalSchedulersIoScheduler_init());
    J2OBJC_SET_INITIALIZED(IoReactivexSchedulersSchedulers_IoHolder)
  }
}

@end

void IoReactivexSchedulersSchedulers_IoHolder_init(IoReactivexSchedulersSchedulers_IoHolder *self) {
  NSObject_init(self);
}

IoReactivexSchedulersSchedulers_IoHolder *new_IoReactivexSchedulersSchedulers_IoHolder_init() {
  J2OBJC_NEW_IMPL(IoReactivexSchedulersSchedulers_IoHolder, init)
}

IoReactivexSchedulersSchedulers_IoHolder *create_IoReactivexSchedulersSchedulers_IoHolder_init() {
  J2OBJC_CREATE_IMPL(IoReactivexSchedulersSchedulers_IoHolder, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexSchedulersSchedulers_IoHolder)

J2OBJC_INITIALIZED_DEFN(IoReactivexSchedulersSchedulers_NewThreadHolder)

IoReactivexScheduler *IoReactivexSchedulersSchedulers_NewThreadHolder_DEFAULT;

@implementation IoReactivexSchedulersSchedulers_NewThreadHolder

+ (IoReactivexScheduler *)DEFAULT {
  return IoReactivexSchedulersSchedulers_NewThreadHolder_DEFAULT;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexSchedulersSchedulers_NewThreadHolder_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEFAULT", "LIoReactivexScheduler;", .constantValue.asLong = 0, 0x18, -1, 0, -1, -1 },
  };
  static const void *ptrTable[] = { &IoReactivexSchedulersSchedulers_NewThreadHolder_DEFAULT, "LIoReactivexSchedulersSchedulers;" };
  static const J2ObjcClassInfo _IoReactivexSchedulersSchedulers_NewThreadHolder = { "NewThreadHolder", "io.reactivex.schedulers", ptrTable, methods, fields, 7, 0x18, 1, 1, 1, -1, -1, -1, -1 };
  return &_IoReactivexSchedulersSchedulers_NewThreadHolder;
}

+ (void)initialize {
  if (self == [IoReactivexSchedulersSchedulers_NewThreadHolder class]) {
    JreStrongAssignAndConsume(&IoReactivexSchedulersSchedulers_NewThreadHolder_DEFAULT, new_IoReactivexInternalSchedulersNewThreadScheduler_init());
    J2OBJC_SET_INITIALIZED(IoReactivexSchedulersSchedulers_NewThreadHolder)
  }
}

@end

void IoReactivexSchedulersSchedulers_NewThreadHolder_init(IoReactivexSchedulersSchedulers_NewThreadHolder *self) {
  NSObject_init(self);
}

IoReactivexSchedulersSchedulers_NewThreadHolder *new_IoReactivexSchedulersSchedulers_NewThreadHolder_init() {
  J2OBJC_NEW_IMPL(IoReactivexSchedulersSchedulers_NewThreadHolder, init)
}

IoReactivexSchedulersSchedulers_NewThreadHolder *create_IoReactivexSchedulersSchedulers_NewThreadHolder_init() {
  J2OBJC_CREATE_IMPL(IoReactivexSchedulersSchedulers_NewThreadHolder, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexSchedulersSchedulers_NewThreadHolder)

@implementation IoReactivexSchedulersSchedulers_IOTask

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexSchedulersSchedulers_IOTask_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (IoReactivexScheduler *)call {
  return JreLoadStatic(IoReactivexSchedulersSchedulers_IoHolder, DEFAULT);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler;", 0x1, -1, -1, 0, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(call);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LJavaLangException;", "LIoReactivexSchedulersSchedulers;", "Ljava/lang/Object;Ljava/util/concurrent/Callable<Lio/reactivex/Scheduler;>;" };
  static const J2ObjcClassInfo _IoReactivexSchedulersSchedulers_IOTask = { "IOTask", "io.reactivex.schedulers", ptrTable, methods, NULL, 7, 0x18, 2, 0, 1, -1, -1, 2, -1 };
  return &_IoReactivexSchedulersSchedulers_IOTask;
}

@end

void IoReactivexSchedulersSchedulers_IOTask_init(IoReactivexSchedulersSchedulers_IOTask *self) {
  NSObject_init(self);
}

IoReactivexSchedulersSchedulers_IOTask *new_IoReactivexSchedulersSchedulers_IOTask_init() {
  J2OBJC_NEW_IMPL(IoReactivexSchedulersSchedulers_IOTask, init)
}

IoReactivexSchedulersSchedulers_IOTask *create_IoReactivexSchedulersSchedulers_IOTask_init() {
  J2OBJC_CREATE_IMPL(IoReactivexSchedulersSchedulers_IOTask, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexSchedulersSchedulers_IOTask)

@implementation IoReactivexSchedulersSchedulers_NewThreadTask

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexSchedulersSchedulers_NewThreadTask_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (IoReactivexScheduler *)call {
  return JreLoadStatic(IoReactivexSchedulersSchedulers_NewThreadHolder, DEFAULT);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler;", 0x1, -1, -1, 0, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(call);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LJavaLangException;", "LIoReactivexSchedulersSchedulers;", "Ljava/lang/Object;Ljava/util/concurrent/Callable<Lio/reactivex/Scheduler;>;" };
  static const J2ObjcClassInfo _IoReactivexSchedulersSchedulers_NewThreadTask = { "NewThreadTask", "io.reactivex.schedulers", ptrTable, methods, NULL, 7, 0x18, 2, 0, 1, -1, -1, 2, -1 };
  return &_IoReactivexSchedulersSchedulers_NewThreadTask;
}

@end

void IoReactivexSchedulersSchedulers_NewThreadTask_init(IoReactivexSchedulersSchedulers_NewThreadTask *self) {
  NSObject_init(self);
}

IoReactivexSchedulersSchedulers_NewThreadTask *new_IoReactivexSchedulersSchedulers_NewThreadTask_init() {
  J2OBJC_NEW_IMPL(IoReactivexSchedulersSchedulers_NewThreadTask, init)
}

IoReactivexSchedulersSchedulers_NewThreadTask *create_IoReactivexSchedulersSchedulers_NewThreadTask_init() {
  J2OBJC_CREATE_IMPL(IoReactivexSchedulersSchedulers_NewThreadTask, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexSchedulersSchedulers_NewThreadTask)

@implementation IoReactivexSchedulersSchedulers_SingleTask

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexSchedulersSchedulers_SingleTask_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (IoReactivexScheduler *)call {
  return JreLoadStatic(IoReactivexSchedulersSchedulers_SingleHolder, DEFAULT);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler;", 0x1, -1, -1, 0, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(call);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LJavaLangException;", "LIoReactivexSchedulersSchedulers;", "Ljava/lang/Object;Ljava/util/concurrent/Callable<Lio/reactivex/Scheduler;>;" };
  static const J2ObjcClassInfo _IoReactivexSchedulersSchedulers_SingleTask = { "SingleTask", "io.reactivex.schedulers", ptrTable, methods, NULL, 7, 0x18, 2, 0, 1, -1, -1, 2, -1 };
  return &_IoReactivexSchedulersSchedulers_SingleTask;
}

@end

void IoReactivexSchedulersSchedulers_SingleTask_init(IoReactivexSchedulersSchedulers_SingleTask *self) {
  NSObject_init(self);
}

IoReactivexSchedulersSchedulers_SingleTask *new_IoReactivexSchedulersSchedulers_SingleTask_init() {
  J2OBJC_NEW_IMPL(IoReactivexSchedulersSchedulers_SingleTask, init)
}

IoReactivexSchedulersSchedulers_SingleTask *create_IoReactivexSchedulersSchedulers_SingleTask_init() {
  J2OBJC_CREATE_IMPL(IoReactivexSchedulersSchedulers_SingleTask, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexSchedulersSchedulers_SingleTask)

@implementation IoReactivexSchedulersSchedulers_ComputationTask

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexSchedulersSchedulers_ComputationTask_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (IoReactivexScheduler *)call {
  return JreLoadStatic(IoReactivexSchedulersSchedulers_ComputationHolder, DEFAULT);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler;", 0x1, -1, -1, 0, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(call);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LJavaLangException;", "LIoReactivexSchedulersSchedulers;", "Ljava/lang/Object;Ljava/util/concurrent/Callable<Lio/reactivex/Scheduler;>;" };
  static const J2ObjcClassInfo _IoReactivexSchedulersSchedulers_ComputationTask = { "ComputationTask", "io.reactivex.schedulers", ptrTable, methods, NULL, 7, 0x18, 2, 0, 1, -1, -1, 2, -1 };
  return &_IoReactivexSchedulersSchedulers_ComputationTask;
}

@end

void IoReactivexSchedulersSchedulers_ComputationTask_init(IoReactivexSchedulersSchedulers_ComputationTask *self) {
  NSObject_init(self);
}

IoReactivexSchedulersSchedulers_ComputationTask *new_IoReactivexSchedulersSchedulers_ComputationTask_init() {
  J2OBJC_NEW_IMPL(IoReactivexSchedulersSchedulers_ComputationTask, init)
}

IoReactivexSchedulersSchedulers_ComputationTask *create_IoReactivexSchedulersSchedulers_ComputationTask_init() {
  J2OBJC_CREATE_IMPL(IoReactivexSchedulersSchedulers_ComputationTask, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexSchedulersSchedulers_ComputationTask)
