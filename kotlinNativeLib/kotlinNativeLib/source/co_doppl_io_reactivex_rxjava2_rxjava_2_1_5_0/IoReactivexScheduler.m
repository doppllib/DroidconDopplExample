//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "IoReactivexDisposablesDisposable.h"
#include "IoReactivexExceptionsExceptions.h"
#include "IoReactivexFunctionsFunction.h"
#include "IoReactivexInternalDisposablesEmptyDisposable.h"
#include "IoReactivexInternalDisposablesSequentialDisposable.h"
#include "IoReactivexInternalSchedulersNewThreadWorker.h"
#include "IoReactivexInternalSchedulersSchedulerWhen.h"
#include "IoReactivexInternalUtilExceptionHelper.h"
#include "IoReactivexPluginsRxJavaPlugins.h"
#include "IoReactivexScheduler.h"
#include "J2ObjC_source.h"
#include "java/lang/Long.h"
#include "java/lang/Runnable.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/System.h"
#include "java/lang/Thread.h"
#include "java/lang/Throwable.h"
#include "java/util/concurrent/TimeUnit.h"

#pragma clang diagnostic ignored "-Wprotocol"

@interface IoReactivexScheduler_Worker_PeriodicTask () {
 @public
  IoReactivexScheduler_Worker *this$0_;
}

@end

J2OBJC_INITIALIZED_DEFN(IoReactivexScheduler)

jlong IoReactivexScheduler_CLOCK_DRIFT_TOLERANCE_NANOSECONDS;

@implementation IoReactivexScheduler

+ (jlong)CLOCK_DRIFT_TOLERANCE_NANOSECONDS {
  return IoReactivexScheduler_CLOCK_DRIFT_TOLERANCE_NANOSECONDS;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexScheduler_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (jlong)clockDriftTolerance {
  return IoReactivexScheduler_clockDriftTolerance();
}

- (IoReactivexScheduler_Worker * __nonnull)createWorker {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (jlong)nowWithJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit {
  return [((JavaUtilConcurrentTimeUnit *) nil_chk(unit)) convertWithLong:JavaLangSystem_currentTimeMillis() withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, MILLISECONDS)];
}

- (void)start {
}

- (void)shutdown {
}

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleDirectWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)run {
  return [self scheduleDirectWithJavaLangRunnable:run withLong:0LL withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, NANOSECONDS)];
}

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleDirectWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)run
                                                                            withLong:(jlong)delay
                                                      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit {
  IoReactivexScheduler_Worker *w = [self createWorker];
  id<JavaLangRunnable> decoratedRun = IoReactivexPluginsRxJavaPlugins_onScheduleWithJavaLangRunnable_(run);
  IoReactivexScheduler_DisposeTask *task = create_IoReactivexScheduler_DisposeTask_initWithJavaLangRunnable_withIoReactivexScheduler_Worker_(decoratedRun, w);
  [((IoReactivexScheduler_Worker *) nil_chk(w)) scheduleWithJavaLangRunnable:task withLong:delay withJavaUtilConcurrentTimeUnit:unit];
  return task;
}

- (id<IoReactivexDisposablesDisposable> __nonnull)schedulePeriodicallyDirectWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)run
                                                                                        withLong:(jlong)initialDelay
                                                                                        withLong:(jlong)period
                                                                  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit {
  IoReactivexScheduler_Worker *w = [self createWorker];
  id<JavaLangRunnable> decoratedRun = IoReactivexPluginsRxJavaPlugins_onScheduleWithJavaLangRunnable_(run);
  IoReactivexScheduler_PeriodicDirectTask *periodicTask = create_IoReactivexScheduler_PeriodicDirectTask_initWithJavaLangRunnable_withIoReactivexScheduler_Worker_(decoratedRun, w);
  id<IoReactivexDisposablesDisposable> d = [((IoReactivexScheduler_Worker *) nil_chk(w)) schedulePeriodicallyWithJavaLangRunnable:periodicTask withLong:initialDelay withLong:period withJavaUtilConcurrentTimeUnit:unit];
  if (d == JreLoadEnum(IoReactivexInternalDisposablesEmptyDisposable, INSTANCE)) {
    return d;
  }
  return periodicTask;
}

- (IoReactivexScheduler<IoReactivexDisposablesDisposable> * __nonnull)whenWithIoReactivexFunctionsFunction:(id<IoReactivexFunctionsFunction> __nonnull)combine {
  return create_IoReactivexInternalSchedulersSchedulerWhen_initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_(combine, self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler_Worker;", 0x401, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 2, 4, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 5, 6, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler;", 0x1, 7, 8, -1, 9, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(clockDriftTolerance);
  methods[2].selector = @selector(createWorker);
  methods[3].selector = @selector(nowWithJavaUtilConcurrentTimeUnit:);
  methods[4].selector = @selector(start);
  methods[5].selector = @selector(shutdown);
  methods[6].selector = @selector(scheduleDirectWithJavaLangRunnable:);
  methods[7].selector = @selector(scheduleDirectWithJavaLangRunnable:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[8].selector = @selector(schedulePeriodicallyDirectWithJavaLangRunnable:withLong:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[9].selector = @selector(whenWithIoReactivexFunctionsFunction:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "CLOCK_DRIFT_TOLERANCE_NANOSECONDS", "J", .constantValue.asLong = 0, 0x18, -1, 10, -1, -1 },
  };
  static const void *ptrTable[] = { "now", "LJavaUtilConcurrentTimeUnit;", "scheduleDirect", "LJavaLangRunnable;", "LJavaLangRunnable;JLJavaUtilConcurrentTimeUnit;", "schedulePeriodicallyDirect", "LJavaLangRunnable;JJLJavaUtilConcurrentTimeUnit;", "when", "LIoReactivexFunctionsFunction;", "<S:Lio/reactivex/Scheduler;:Lio/reactivex/disposables/Disposable;>(Lio/reactivex/functions/Function<Lio/reactivex/Flowable<Lio/reactivex/Flowable<Lio/reactivex/Completable;>;>;Lio/reactivex/Completable;>;)TS;", &IoReactivexScheduler_CLOCK_DRIFT_TOLERANCE_NANOSECONDS, "LIoReactivexScheduler_Worker;LIoReactivexScheduler_PeriodicDirectTask;LIoReactivexScheduler_DisposeTask;" };
  static const J2ObjcClassInfo _IoReactivexScheduler = { "Scheduler", "io.reactivex", ptrTable, methods, fields, 7, 0x401, 10, 1, -1, 11, -1, -1, -1 };
  return &_IoReactivexScheduler;
}

+ (void)initialize {
  if (self == [IoReactivexScheduler class]) {
    {
      IoReactivexScheduler_CLOCK_DRIFT_TOLERANCE_NANOSECONDS = [((JavaUtilConcurrentTimeUnit *) nil_chk(JreLoadEnum(JavaUtilConcurrentTimeUnit, MINUTES))) toNanosWithLong:[((JavaLangLong *) nil_chk(JavaLangLong_getLongWithNSString_withLong_(@"rx2.scheduler.drift-tolerance", 15))) longLongValue]];
    }
    J2OBJC_SET_INITIALIZED(IoReactivexScheduler)
  }
}

@end

void IoReactivexScheduler_init(IoReactivexScheduler *self) {
  NSObject_init(self);
}

jlong IoReactivexScheduler_clockDriftTolerance() {
  IoReactivexScheduler_initialize();
  return IoReactivexScheduler_CLOCK_DRIFT_TOLERANCE_NANOSECONDS;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexScheduler)

@implementation IoReactivexScheduler_Worker

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexScheduler_Worker_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)run {
  return [self scheduleWithJavaLangRunnable:run withLong:0LL withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, NANOSECONDS)];
}

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)run
                                                                      withLong:(jlong)delay
                                                withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id<IoReactivexDisposablesDisposable> __nonnull)schedulePeriodicallyWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)run
                                                                                  withLong:(jlong)initialDelay
                                                                                  withLong:(jlong)period
                                                            withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit {
  IoReactivexInternalDisposablesSequentialDisposable *first = create_IoReactivexInternalDisposablesSequentialDisposable_init();
  IoReactivexInternalDisposablesSequentialDisposable *sd = create_IoReactivexInternalDisposablesSequentialDisposable_initWithIoReactivexDisposablesDisposable_(first);
  id<JavaLangRunnable> decoratedRun = IoReactivexPluginsRxJavaPlugins_onScheduleWithJavaLangRunnable_(run);
  jlong periodInNanoseconds = [((JavaUtilConcurrentTimeUnit *) nil_chk(unit)) toNanosWithLong:period];
  jlong firstNowNanoseconds = [self nowWithJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, NANOSECONDS)];
  jlong firstStartInNanoseconds = firstNowNanoseconds + [unit toNanosWithLong:initialDelay];
  id<IoReactivexDisposablesDisposable> d = [self scheduleWithJavaLangRunnable:create_IoReactivexScheduler_Worker_PeriodicTask_initWithIoReactivexScheduler_Worker_withLong_withJavaLangRunnable_withLong_withIoReactivexInternalDisposablesSequentialDisposable_withLong_(self, firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd, periodInNanoseconds) withLong:initialDelay withJavaUtilConcurrentTimeUnit:unit];
  if (d == JreLoadEnum(IoReactivexInternalDisposablesEmptyDisposable, INSTANCE)) {
    return d;
  }
  [first replaceWithIoReactivexDisposablesDisposable:d];
  return sd;
}

- (jlong)nowWithJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit {
  return [((JavaUtilConcurrentTimeUnit *) nil_chk(unit)) convertWithLong:JavaLangSystem_currentTimeMillis() withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, MILLISECONDS)];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x401, 0, 2, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "J", 0x1, 5, 6, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(scheduleWithJavaLangRunnable:);
  methods[2].selector = @selector(scheduleWithJavaLangRunnable:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[3].selector = @selector(schedulePeriodicallyWithJavaLangRunnable:withLong:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[4].selector = @selector(nowWithJavaUtilConcurrentTimeUnit:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "schedule", "LJavaLangRunnable;", "LJavaLangRunnable;JLJavaUtilConcurrentTimeUnit;", "schedulePeriodically", "LJavaLangRunnable;JJLJavaUtilConcurrentTimeUnit;", "now", "LJavaUtilConcurrentTimeUnit;", "LIoReactivexScheduler;", "LIoReactivexScheduler_Worker_PeriodicTask;" };
  static const J2ObjcClassInfo _IoReactivexScheduler_Worker = { "Worker", "io.reactivex", ptrTable, methods, NULL, 7, 0x409, 5, 0, 7, 8, -1, -1, -1 };
  return &_IoReactivexScheduler_Worker;
}

@end

void IoReactivexScheduler_Worker_init(IoReactivexScheduler_Worker *self) {
  NSObject_init(self);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexScheduler_Worker)

@implementation IoReactivexScheduler_Worker_PeriodicTask

- (instancetype)initWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)outer$
                                           withLong:(jlong)firstStartInNanoseconds
                               withJavaLangRunnable:(id<JavaLangRunnable> __nonnull)decoratedRun
                                           withLong:(jlong)firstNowNanoseconds
withIoReactivexInternalDisposablesSequentialDisposable:(IoReactivexInternalDisposablesSequentialDisposable * __nonnull)sd
                                           withLong:(jlong)periodInNanoseconds {
  IoReactivexScheduler_Worker_PeriodicTask_initWithIoReactivexScheduler_Worker_withLong_withJavaLangRunnable_withLong_withIoReactivexInternalDisposablesSequentialDisposable_withLong_(self, outer$, firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd, periodInNanoseconds);
  return self;
}

- (void)run {
  [((id<JavaLangRunnable>) nil_chk(decoratedRun_)) run];
  if (![((IoReactivexInternalDisposablesSequentialDisposable *) nil_chk(sd_)) isDisposed]) {
    jlong nextTick;
    jlong nowNanoseconds = [this$0_ nowWithJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, NANOSECONDS)];
    if (nowNanoseconds + JreLoadStatic(IoReactivexScheduler, CLOCK_DRIFT_TOLERANCE_NANOSECONDS) < lastNowNanoseconds_ || nowNanoseconds >= lastNowNanoseconds_ + periodInNanoseconds_ + JreLoadStatic(IoReactivexScheduler, CLOCK_DRIFT_TOLERANCE_NANOSECONDS)) {
      nextTick = nowNanoseconds + periodInNanoseconds_;
      startInNanoseconds_ = nextTick - (periodInNanoseconds_ * (++count_));
    }
    else {
      nextTick = startInNanoseconds_ + (++count_ * periodInNanoseconds_);
    }
    lastNowNanoseconds_ = nowNanoseconds;
    jlong delay = nextTick - nowNanoseconds;
    [sd_ replaceWithIoReactivexDisposablesDisposable:[this$0_ scheduleWithJavaLangRunnable:self withLong:delay withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, NANOSECONDS)]];
  }
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(decoratedRun_);
  RELEASE_(sd_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithIoReactivexScheduler_Worker:withLong:withJavaLangRunnable:withLong:withIoReactivexInternalDisposablesSequentialDisposable:withLong:);
  methods[1].selector = @selector(run);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LIoReactivexScheduler_Worker;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "decoratedRun_", "LJavaLangRunnable;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "sd_", "LIoReactivexInternalDisposablesSequentialDisposable;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "periodInNanoseconds_", "J", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "count_", "J", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "lastNowNanoseconds_", "J", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "startInNanoseconds_", "J", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "JLJavaLangRunnable;JLIoReactivexInternalDisposablesSequentialDisposable;J", "LIoReactivexScheduler_Worker;" };
  static const J2ObjcClassInfo _IoReactivexScheduler_Worker_PeriodicTask = { "PeriodicTask", "io.reactivex", ptrTable, methods, fields, 7, 0x10, 2, 7, 1, -1, -1, -1, -1 };
  return &_IoReactivexScheduler_Worker_PeriodicTask;
}

@end

void IoReactivexScheduler_Worker_PeriodicTask_initWithIoReactivexScheduler_Worker_withLong_withJavaLangRunnable_withLong_withIoReactivexInternalDisposablesSequentialDisposable_withLong_(IoReactivexScheduler_Worker_PeriodicTask *self, IoReactivexScheduler_Worker *outer$, jlong firstStartInNanoseconds, id<JavaLangRunnable> decoratedRun, jlong firstNowNanoseconds, IoReactivexInternalDisposablesSequentialDisposable *sd, jlong periodInNanoseconds) {
  JreStrongAssign(&self->this$0_, outer$);
  NSObject_init(self);
  JreStrongAssign(&self->decoratedRun_, decoratedRun);
  JreStrongAssign(&self->sd_, sd);
  self->periodInNanoseconds_ = periodInNanoseconds;
  self->lastNowNanoseconds_ = firstNowNanoseconds;
  self->startInNanoseconds_ = firstStartInNanoseconds;
}

IoReactivexScheduler_Worker_PeriodicTask *new_IoReactivexScheduler_Worker_PeriodicTask_initWithIoReactivexScheduler_Worker_withLong_withJavaLangRunnable_withLong_withIoReactivexInternalDisposablesSequentialDisposable_withLong_(IoReactivexScheduler_Worker *outer$, jlong firstStartInNanoseconds, id<JavaLangRunnable> decoratedRun, jlong firstNowNanoseconds, IoReactivexInternalDisposablesSequentialDisposable *sd, jlong periodInNanoseconds) {
  J2OBJC_NEW_IMPL(IoReactivexScheduler_Worker_PeriodicTask, initWithIoReactivexScheduler_Worker_withLong_withJavaLangRunnable_withLong_withIoReactivexInternalDisposablesSequentialDisposable_withLong_, outer$, firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd, periodInNanoseconds)
}

IoReactivexScheduler_Worker_PeriodicTask *create_IoReactivexScheduler_Worker_PeriodicTask_initWithIoReactivexScheduler_Worker_withLong_withJavaLangRunnable_withLong_withIoReactivexInternalDisposablesSequentialDisposable_withLong_(IoReactivexScheduler_Worker *outer$, jlong firstStartInNanoseconds, id<JavaLangRunnable> decoratedRun, jlong firstNowNanoseconds, IoReactivexInternalDisposablesSequentialDisposable *sd, jlong periodInNanoseconds) {
  J2OBJC_CREATE_IMPL(IoReactivexScheduler_Worker_PeriodicTask, initWithIoReactivexScheduler_Worker_withLong_withJavaLangRunnable_withLong_withIoReactivexInternalDisposablesSequentialDisposable_withLong_, outer$, firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd, periodInNanoseconds)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexScheduler_Worker_PeriodicTask)

@implementation IoReactivexScheduler_PeriodicDirectTask

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)run
         withIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker * __nonnull)worker {
  IoReactivexScheduler_PeriodicDirectTask_initWithJavaLangRunnable_withIoReactivexScheduler_Worker_(self, run, worker);
  return self;
}

- (void)run {
  if (!JreLoadVolatileBoolean(&disposed_)) {
    @try {
      [((id<JavaLangRunnable>) nil_chk(run_)) run];
    }
    @catch (JavaLangThrowable *ex) {
      IoReactivexExceptionsExceptions_throwIfFatalWithJavaLangThrowable_(ex);
      [((IoReactivexScheduler_Worker *) nil_chk(worker_)) dispose];
      @throw nil_chk(IoReactivexInternalUtilExceptionHelper_wrapOrThrowWithJavaLangThrowable_(ex));
    }
  }
}

- (void)dispose {
  JreAssignVolatileBoolean(&disposed_, true);
  [((IoReactivexScheduler_Worker *) nil_chk(worker_)) dispose];
}

- (jboolean)isDisposed {
  return JreLoadVolatileBoolean(&disposed_);
}

- (void)dealloc {
  RELEASE_(run_);
  RELEASE_(worker_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaLangRunnable:withIoReactivexScheduler_Worker:);
  methods[1].selector = @selector(run);
  methods[2].selector = @selector(dispose);
  methods[3].selector = @selector(isDisposed);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "run_", "LJavaLangRunnable;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "worker_", "LIoReactivexScheduler_Worker;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "disposed_", "Z", .constantValue.asLong = 0, 0x40, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaLangRunnable;LIoReactivexScheduler_Worker;", "LIoReactivexScheduler;" };
  static const J2ObjcClassInfo _IoReactivexScheduler_PeriodicDirectTask = { "PeriodicDirectTask", "io.reactivex", ptrTable, methods, fields, 7, 0x8, 4, 3, 1, -1, -1, -1, -1 };
  return &_IoReactivexScheduler_PeriodicDirectTask;
}

@end

void IoReactivexScheduler_PeriodicDirectTask_initWithJavaLangRunnable_withIoReactivexScheduler_Worker_(IoReactivexScheduler_PeriodicDirectTask *self, id<JavaLangRunnable> run, IoReactivexScheduler_Worker *worker) {
  NSObject_init(self);
  JreStrongAssign(&self->run_, run);
  JreStrongAssign(&self->worker_, worker);
}

IoReactivexScheduler_PeriodicDirectTask *new_IoReactivexScheduler_PeriodicDirectTask_initWithJavaLangRunnable_withIoReactivexScheduler_Worker_(id<JavaLangRunnable> run, IoReactivexScheduler_Worker *worker) {
  J2OBJC_NEW_IMPL(IoReactivexScheduler_PeriodicDirectTask, initWithJavaLangRunnable_withIoReactivexScheduler_Worker_, run, worker)
}

IoReactivexScheduler_PeriodicDirectTask *create_IoReactivexScheduler_PeriodicDirectTask_initWithJavaLangRunnable_withIoReactivexScheduler_Worker_(id<JavaLangRunnable> run, IoReactivexScheduler_Worker *worker) {
  J2OBJC_CREATE_IMPL(IoReactivexScheduler_PeriodicDirectTask, initWithJavaLangRunnable_withIoReactivexScheduler_Worker_, run, worker)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexScheduler_PeriodicDirectTask)

@implementation IoReactivexScheduler_DisposeTask

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)decoratedRun
         withIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)w {
  IoReactivexScheduler_DisposeTask_initWithJavaLangRunnable_withIoReactivexScheduler_Worker_(self, decoratedRun, w);
  return self;
}

- (void)run {
  JreStrongAssign(&runner_, JavaLangThread_currentThread());
  @try {
    [((id<JavaLangRunnable>) nil_chk(decoratedRun_)) run];
  }
  @finally {
    [self dispose];
    JreStrongAssign(&runner_, nil);
  }
}

- (void)dispose {
  if (runner_ == JavaLangThread_currentThread() && [w_ isKindOfClass:[IoReactivexInternalSchedulersNewThreadWorker class]]) {
    [((IoReactivexInternalSchedulersNewThreadWorker *) nil_chk(((IoReactivexInternalSchedulersNewThreadWorker *) cast_chk(w_, [IoReactivexInternalSchedulersNewThreadWorker class])))) shutdown];
  }
  else {
    [((IoReactivexScheduler_Worker *) nil_chk(w_)) dispose];
  }
}

- (jboolean)isDisposed {
  return [((IoReactivexScheduler_Worker *) nil_chk(w_)) isDisposed];
}

- (void)dealloc {
  RELEASE_(decoratedRun_);
  RELEASE_(w_);
  RELEASE_(runner_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaLangRunnable:withIoReactivexScheduler_Worker:);
  methods[1].selector = @selector(run);
  methods[2].selector = @selector(dispose);
  methods[3].selector = @selector(isDisposed);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "decoratedRun_", "LJavaLangRunnable;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "w_", "LIoReactivexScheduler_Worker;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "runner_", "LJavaLangThread;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaLangRunnable;LIoReactivexScheduler_Worker;", "LIoReactivexScheduler;" };
  static const J2ObjcClassInfo _IoReactivexScheduler_DisposeTask = { "DisposeTask", "io.reactivex", ptrTable, methods, fields, 7, 0x18, 4, 3, 1, -1, -1, -1, -1 };
  return &_IoReactivexScheduler_DisposeTask;
}

@end

void IoReactivexScheduler_DisposeTask_initWithJavaLangRunnable_withIoReactivexScheduler_Worker_(IoReactivexScheduler_DisposeTask *self, id<JavaLangRunnable> decoratedRun, IoReactivexScheduler_Worker *w) {
  NSObject_init(self);
  JreStrongAssign(&self->decoratedRun_, decoratedRun);
  JreStrongAssign(&self->w_, w);
}

IoReactivexScheduler_DisposeTask *new_IoReactivexScheduler_DisposeTask_initWithJavaLangRunnable_withIoReactivexScheduler_Worker_(id<JavaLangRunnable> decoratedRun, IoReactivexScheduler_Worker *w) {
  J2OBJC_NEW_IMPL(IoReactivexScheduler_DisposeTask, initWithJavaLangRunnable_withIoReactivexScheduler_Worker_, decoratedRun, w)
}

IoReactivexScheduler_DisposeTask *create_IoReactivexScheduler_DisposeTask_initWithJavaLangRunnable_withIoReactivexScheduler_Worker_(id<JavaLangRunnable> decoratedRun, IoReactivexScheduler_Worker *w) {
  J2OBJC_CREATE_IMPL(IoReactivexScheduler_DisposeTask, initWithJavaLangRunnable_withIoReactivexScheduler_Worker_, decoratedRun, w)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexScheduler_DisposeTask)
