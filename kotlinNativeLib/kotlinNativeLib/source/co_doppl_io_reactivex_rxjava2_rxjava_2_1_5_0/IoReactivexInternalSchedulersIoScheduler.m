//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "IoReactivexDisposablesCompositeDisposable.h"
#include "IoReactivexDisposablesDisposable.h"
#include "IoReactivexInternalDisposablesEmptyDisposable.h"
#include "IoReactivexInternalSchedulersIoScheduler.h"
#include "IoReactivexInternalSchedulersNewThreadWorker.h"
#include "IoReactivexInternalSchedulersRxThreadFactory.h"
#include "IoReactivexInternalSchedulersScheduledRunnable.h"
#include "IoReactivexScheduler.h"
#include "J2ObjC_source.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/lang/Runnable.h"
#include "java/lang/System.h"
#include "java/lang/Thread.h"
#include "java/util/List.h"
#include "java/util/concurrent/ConcurrentLinkedQueue.h"
#include "java/util/concurrent/Executors.h"
#include "java/util/concurrent/Future.h"
#include "java/util/concurrent/ScheduledExecutorService.h"
#include "java/util/concurrent/ScheduledFuture.h"
#include "java/util/concurrent/ThreadFactory.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/util/concurrent/atomic/AtomicBoolean.h"
#include "java/util/concurrent/atomic/AtomicReference.h"

inline NSString *IoReactivexInternalSchedulersIoScheduler_get_WORKER_THREAD_NAME_PREFIX();
static NSString *IoReactivexInternalSchedulersIoScheduler_WORKER_THREAD_NAME_PREFIX = @"RxCachedThreadScheduler";
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersIoScheduler, WORKER_THREAD_NAME_PREFIX, NSString *)

inline NSString *IoReactivexInternalSchedulersIoScheduler_get_EVICTOR_THREAD_NAME_PREFIX();
static NSString *IoReactivexInternalSchedulersIoScheduler_EVICTOR_THREAD_NAME_PREFIX = @"RxCachedWorkerPoolEvictor";
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersIoScheduler, EVICTOR_THREAD_NAME_PREFIX, NSString *)

inline jlong IoReactivexInternalSchedulersIoScheduler_get_KEEP_ALIVE_TIME();
#define IoReactivexInternalSchedulersIoScheduler_KEEP_ALIVE_TIME 60LL
J2OBJC_STATIC_FIELD_CONSTANT(IoReactivexInternalSchedulersIoScheduler, KEEP_ALIVE_TIME, jlong)

inline JavaUtilConcurrentTimeUnit *IoReactivexInternalSchedulersIoScheduler_get_KEEP_ALIVE_UNIT();
static JavaUtilConcurrentTimeUnit *IoReactivexInternalSchedulersIoScheduler_KEEP_ALIVE_UNIT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersIoScheduler, KEEP_ALIVE_UNIT, JavaUtilConcurrentTimeUnit *)

inline NSString *IoReactivexInternalSchedulersIoScheduler_get_KEY_IO_PRIORITY();
static NSString *IoReactivexInternalSchedulersIoScheduler_KEY_IO_PRIORITY = @"rx2.io-priority";
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersIoScheduler, KEY_IO_PRIORITY, NSString *)

@interface IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool () {
 @public
  jlong keepAliveTime_;
  JavaUtilConcurrentConcurrentLinkedQueue *expiringWorkerQueue_;
  id<JavaUtilConcurrentScheduledExecutorService> evictorService_;
  id<JavaUtilConcurrentFuture> evictorTask_;
  id<JavaUtilConcurrentThreadFactory> threadFactory_;
}

@end

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool, expiringWorkerQueue_, JavaUtilConcurrentConcurrentLinkedQueue *)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool, evictorService_, id<JavaUtilConcurrentScheduledExecutorService>)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool, evictorTask_, id<JavaUtilConcurrentFuture>)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool, threadFactory_, id<JavaUtilConcurrentThreadFactory>)

@interface IoReactivexInternalSchedulersIoScheduler_EventLoopWorker () {
 @public
  IoReactivexDisposablesCompositeDisposable *tasks_;
  IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *pool_;
  IoReactivexInternalSchedulersIoScheduler_ThreadWorker *threadWorker_;
}

@end

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersIoScheduler_EventLoopWorker, tasks_, IoReactivexDisposablesCompositeDisposable *)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersIoScheduler_EventLoopWorker, pool_, IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersIoScheduler_EventLoopWorker, threadWorker_, IoReactivexInternalSchedulersIoScheduler_ThreadWorker *)

@interface IoReactivexInternalSchedulersIoScheduler_ThreadWorker () {
 @public
  jlong expirationTime_;
}

@end

J2OBJC_INITIALIZED_DEFN(IoReactivexInternalSchedulersIoScheduler)

IoReactivexInternalSchedulersRxThreadFactory *IoReactivexInternalSchedulersIoScheduler_WORKER_THREAD_FACTORY;
IoReactivexInternalSchedulersRxThreadFactory *IoReactivexInternalSchedulersIoScheduler_EVICTOR_THREAD_FACTORY;
IoReactivexInternalSchedulersIoScheduler_ThreadWorker *IoReactivexInternalSchedulersIoScheduler_SHUTDOWN_THREAD_WORKER;
IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *IoReactivexInternalSchedulersIoScheduler_NONE;

@implementation IoReactivexInternalSchedulersIoScheduler

+ (IoReactivexInternalSchedulersRxThreadFactory *)WORKER_THREAD_FACTORY {
  return IoReactivexInternalSchedulersIoScheduler_WORKER_THREAD_FACTORY;
}

+ (IoReactivexInternalSchedulersRxThreadFactory *)EVICTOR_THREAD_FACTORY {
  return IoReactivexInternalSchedulersIoScheduler_EVICTOR_THREAD_FACTORY;
}

+ (IoReactivexInternalSchedulersIoScheduler_ThreadWorker *)SHUTDOWN_THREAD_WORKER {
  return IoReactivexInternalSchedulersIoScheduler_SHUTDOWN_THREAD_WORKER;
}

+ (IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *)NONE {
  return IoReactivexInternalSchedulersIoScheduler_NONE;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexInternalSchedulersIoScheduler_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory {
  IoReactivexInternalSchedulersIoScheduler_initWithJavaUtilConcurrentThreadFactory_(self, threadFactory);
  return self;
}

- (void)start {
  IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *update = create_IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_initWithLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentThreadFactory_(IoReactivexInternalSchedulersIoScheduler_KEEP_ALIVE_TIME, IoReactivexInternalSchedulersIoScheduler_KEEP_ALIVE_UNIT, threadFactory_);
  if (![((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(pool_)) compareAndSetWithId:IoReactivexInternalSchedulersIoScheduler_NONE withId:update]) {
    [update shutdown];
  }
}

- (void)shutdown {
  for (; ; ) {
    IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *curr = [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(pool_)) get];
    if (curr == IoReactivexInternalSchedulersIoScheduler_NONE) {
      return;
    }
    if ([pool_ compareAndSetWithId:curr withId:IoReactivexInternalSchedulersIoScheduler_NONE]) {
      [((IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *) nil_chk(curr)) shutdown];
      return;
    }
  }
}

- (IoReactivexScheduler_Worker * __nonnull)createWorker {
  return create_IoReactivexInternalSchedulersIoScheduler_EventLoopWorker_initWithIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_([((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(pool_)) get]);
}

- (jint)size {
  return [((IoReactivexDisposablesCompositeDisposable *) nil_chk(((IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *) nil_chk([((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(pool_)) get]))->allWorkers_)) size];
}

- (void)dealloc {
  RELEASE_(threadFactory_);
  RELEASE_(pool_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler_Worker;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initWithJavaUtilConcurrentThreadFactory:);
  methods[2].selector = @selector(start);
  methods[3].selector = @selector(shutdown);
  methods[4].selector = @selector(createWorker);
  methods[5].selector = @selector(size);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "WORKER_THREAD_NAME_PREFIX", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 1, -1, -1 },
    { "WORKER_THREAD_FACTORY", "LIoReactivexInternalSchedulersRxThreadFactory;", .constantValue.asLong = 0, 0x18, -1, 2, -1, -1 },
    { "EVICTOR_THREAD_NAME_PREFIX", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 3, -1, -1 },
    { "EVICTOR_THREAD_FACTORY", "LIoReactivexInternalSchedulersRxThreadFactory;", .constantValue.asLong = 0, 0x18, -1, 4, -1, -1 },
    { "KEEP_ALIVE_TIME", "J", .constantValue.asLong = IoReactivexInternalSchedulersIoScheduler_KEEP_ALIVE_TIME, 0x1a, -1, -1, -1, -1 },
    { "KEEP_ALIVE_UNIT", "LJavaUtilConcurrentTimeUnit;", .constantValue.asLong = 0, 0x1a, -1, 5, -1, -1 },
    { "SHUTDOWN_THREAD_WORKER", "LIoReactivexInternalSchedulersIoScheduler_ThreadWorker;", .constantValue.asLong = 0, 0x18, -1, 6, -1, -1 },
    { "threadFactory_", "LJavaUtilConcurrentThreadFactory;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "pool_", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x10, -1, -1, 7, -1 },
    { "KEY_IO_PRIORITY", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 8, -1, -1 },
    { "NONE", "LIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool;", .constantValue.asLong = 0, 0x18, -1, 9, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilConcurrentThreadFactory;", &IoReactivexInternalSchedulersIoScheduler_WORKER_THREAD_NAME_PREFIX, &IoReactivexInternalSchedulersIoScheduler_WORKER_THREAD_FACTORY, &IoReactivexInternalSchedulersIoScheduler_EVICTOR_THREAD_NAME_PREFIX, &IoReactivexInternalSchedulersIoScheduler_EVICTOR_THREAD_FACTORY, &IoReactivexInternalSchedulersIoScheduler_KEEP_ALIVE_UNIT, &IoReactivexInternalSchedulersIoScheduler_SHUTDOWN_THREAD_WORKER, "Ljava/util/concurrent/atomic/AtomicReference<Lio/reactivex/internal/schedulers/IoScheduler$CachedWorkerPool;>;", &IoReactivexInternalSchedulersIoScheduler_KEY_IO_PRIORITY, &IoReactivexInternalSchedulersIoScheduler_NONE, "LIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool;LIoReactivexInternalSchedulersIoScheduler_EventLoopWorker;LIoReactivexInternalSchedulersIoScheduler_ThreadWorker;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersIoScheduler = { "IoScheduler", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x11, 6, 11, -1, 10, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersIoScheduler;
}

+ (void)initialize {
  if (self == [IoReactivexInternalSchedulersIoScheduler class]) {
    JreStrongAssign(&IoReactivexInternalSchedulersIoScheduler_KEEP_ALIVE_UNIT, JreLoadEnum(JavaUtilConcurrentTimeUnit, SECONDS));
    {
      JreStrongAssignAndConsume(&IoReactivexInternalSchedulersIoScheduler_SHUTDOWN_THREAD_WORKER, new_IoReactivexInternalSchedulersIoScheduler_ThreadWorker_initWithJavaUtilConcurrentThreadFactory_(create_IoReactivexInternalSchedulersRxThreadFactory_initWithNSString_(@"RxCachedThreadSchedulerShutdown")));
      [IoReactivexInternalSchedulersIoScheduler_SHUTDOWN_THREAD_WORKER dispose];
      jint priority = JavaLangMath_maxWithInt_withInt_(JavaLangThread_MIN_PRIORITY, JavaLangMath_minWithInt_withInt_(JavaLangThread_MAX_PRIORITY, [((JavaLangInteger *) nil_chk(JavaLangInteger_getIntegerWithNSString_withInt_(IoReactivexInternalSchedulersIoScheduler_KEY_IO_PRIORITY, JavaLangThread_NORM_PRIORITY))) intValue]));
      JreStrongAssignAndConsume(&IoReactivexInternalSchedulersIoScheduler_WORKER_THREAD_FACTORY, new_IoReactivexInternalSchedulersRxThreadFactory_initWithNSString_withInt_(IoReactivexInternalSchedulersIoScheduler_WORKER_THREAD_NAME_PREFIX, priority));
      JreStrongAssignAndConsume(&IoReactivexInternalSchedulersIoScheduler_EVICTOR_THREAD_FACTORY, new_IoReactivexInternalSchedulersRxThreadFactory_initWithNSString_withInt_(IoReactivexInternalSchedulersIoScheduler_EVICTOR_THREAD_NAME_PREFIX, priority));
      JreStrongAssignAndConsume(&IoReactivexInternalSchedulersIoScheduler_NONE, new_IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_initWithLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentThreadFactory_(0, nil, IoReactivexInternalSchedulersIoScheduler_WORKER_THREAD_FACTORY));
      [IoReactivexInternalSchedulersIoScheduler_NONE shutdown];
    }
    J2OBJC_SET_INITIALIZED(IoReactivexInternalSchedulersIoScheduler)
  }
}

@end

void IoReactivexInternalSchedulersIoScheduler_init(IoReactivexInternalSchedulersIoScheduler *self) {
  IoReactivexInternalSchedulersIoScheduler_initWithJavaUtilConcurrentThreadFactory_(self, IoReactivexInternalSchedulersIoScheduler_WORKER_THREAD_FACTORY);
}

IoReactivexInternalSchedulersIoScheduler *new_IoReactivexInternalSchedulersIoScheduler_init() {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersIoScheduler, init)
}

IoReactivexInternalSchedulersIoScheduler *create_IoReactivexInternalSchedulersIoScheduler_init() {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersIoScheduler, init)
}

void IoReactivexInternalSchedulersIoScheduler_initWithJavaUtilConcurrentThreadFactory_(IoReactivexInternalSchedulersIoScheduler *self, id<JavaUtilConcurrentThreadFactory> threadFactory) {
  IoReactivexScheduler_init(self);
  JreStrongAssign(&self->threadFactory_, threadFactory);
  JreStrongAssignAndConsume(&self->pool_, new_JavaUtilConcurrentAtomicAtomicReference_initWithId_(IoReactivexInternalSchedulersIoScheduler_NONE));
  [self start];
}

IoReactivexInternalSchedulersIoScheduler *new_IoReactivexInternalSchedulersIoScheduler_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersIoScheduler, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

IoReactivexInternalSchedulersIoScheduler *create_IoReactivexInternalSchedulersIoScheduler_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersIoScheduler, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersIoScheduler)

@implementation IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool

- (instancetype)initWithLong:(jlong)keepAliveTime
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
withJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory {
  IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_initWithLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentThreadFactory_(self, keepAliveTime, unit, threadFactory);
  return self;
}

- (void)run {
  [self evictExpiredWorkers];
}

- (IoReactivexInternalSchedulersIoScheduler_ThreadWorker *)get {
  if ([((IoReactivexDisposablesCompositeDisposable *) nil_chk(allWorkers_)) isDisposed]) {
    return JreLoadStatic(IoReactivexInternalSchedulersIoScheduler, SHUTDOWN_THREAD_WORKER);
  }
  while (![((JavaUtilConcurrentConcurrentLinkedQueue *) nil_chk(expiringWorkerQueue_)) isEmpty]) {
    IoReactivexInternalSchedulersIoScheduler_ThreadWorker *threadWorker = [expiringWorkerQueue_ poll];
    if (threadWorker != nil) {
      return threadWorker;
    }
  }
  IoReactivexInternalSchedulersIoScheduler_ThreadWorker *w = create_IoReactivexInternalSchedulersIoScheduler_ThreadWorker_initWithJavaUtilConcurrentThreadFactory_(threadFactory_);
  [allWorkers_ addWithIoReactivexDisposablesDisposable:w];
  return w;
}

- (void)release__WithIoReactivexInternalSchedulersIoScheduler_ThreadWorker:(IoReactivexInternalSchedulersIoScheduler_ThreadWorker *)threadWorker {
  [((IoReactivexInternalSchedulersIoScheduler_ThreadWorker *) nil_chk(threadWorker)) setExpirationTimeWithLong:[self now] + keepAliveTime_];
  [((JavaUtilConcurrentConcurrentLinkedQueue *) nil_chk(expiringWorkerQueue_)) offerWithId:threadWorker];
}

- (void)evictExpiredWorkers {
  if (![((JavaUtilConcurrentConcurrentLinkedQueue *) nil_chk(expiringWorkerQueue_)) isEmpty]) {
    jlong currentTimestamp = [self now];
    for (IoReactivexInternalSchedulersIoScheduler_ThreadWorker * __strong threadWorker in expiringWorkerQueue_) {
      if ([((IoReactivexInternalSchedulersIoScheduler_ThreadWorker *) nil_chk(threadWorker)) getExpirationTime] <= currentTimestamp) {
        if ([expiringWorkerQueue_ removeWithId:threadWorker]) {
          [((IoReactivexDisposablesCompositeDisposable *) nil_chk(allWorkers_)) removeWithIoReactivexDisposablesDisposable:threadWorker];
        }
      }
      else {
        break;
      }
    }
  }
}

- (jlong)now {
  return JavaLangSystem_nanoTime();
}

- (void)shutdown {
  [((IoReactivexDisposablesCompositeDisposable *) nil_chk(allWorkers_)) dispose];
  if (evictorTask_ != nil) {
    [evictorTask_ cancelWithBoolean:true];
  }
  if (evictorService_ != nil) {
    [evictorService_ shutdownNow];
  }
}

- (void)dealloc {
  RELEASE_(expiringWorkerQueue_);
  RELEASE_(allWorkers_);
  RELEASE_(evictorService_);
  RELEASE_(evictorTask_);
  RELEASE_(threadFactory_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexInternalSchedulersIoScheduler_ThreadWorker;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithLong:withJavaUtilConcurrentTimeUnit:withJavaUtilConcurrentThreadFactory:);
  methods[1].selector = @selector(run);
  methods[2].selector = @selector(get);
  methods[3].selector = @selector(release__WithIoReactivexInternalSchedulersIoScheduler_ThreadWorker:);
  methods[4].selector = @selector(evictExpiredWorkers);
  methods[5].selector = @selector(now);
  methods[6].selector = @selector(shutdown);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "keepAliveTime_", "J", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "expiringWorkerQueue_", "LJavaUtilConcurrentConcurrentLinkedQueue;", .constantValue.asLong = 0, 0x12, -1, -1, 3, -1 },
    { "allWorkers_", "LIoReactivexDisposablesCompositeDisposable;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "evictorService_", "LJavaUtilConcurrentScheduledExecutorService;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "evictorTask_", "LJavaUtilConcurrentFuture;", .constantValue.asLong = 0, 0x12, -1, -1, 4, -1 },
    { "threadFactory_", "LJavaUtilConcurrentThreadFactory;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "JLJavaUtilConcurrentTimeUnit;LJavaUtilConcurrentThreadFactory;", "release", "LIoReactivexInternalSchedulersIoScheduler_ThreadWorker;", "Ljava/util/concurrent/ConcurrentLinkedQueue<Lio/reactivex/internal/schedulers/IoScheduler$ThreadWorker;>;", "Ljava/util/concurrent/Future<*>;", "LIoReactivexInternalSchedulersIoScheduler;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool = { "CachedWorkerPool", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x18, 7, 6, 5, -1, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool;
}

@end

void IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_initWithLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentThreadFactory_(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *self, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentThreadFactory> threadFactory) {
  NSObject_init(self);
  self->keepAliveTime_ = unit != nil ? [unit toNanosWithLong:keepAliveTime] : 0LL;
  JreStrongAssignAndConsume(&self->expiringWorkerQueue_, new_JavaUtilConcurrentConcurrentLinkedQueue_init());
  JreStrongAssignAndConsume(&self->allWorkers_, new_IoReactivexDisposablesCompositeDisposable_init());
  JreStrongAssign(&self->threadFactory_, threadFactory);
  id<JavaUtilConcurrentScheduledExecutorService> evictor = nil;
  id<JavaUtilConcurrentFuture> task = nil;
  if (unit != nil) {
    evictor = JavaUtilConcurrentExecutors_newScheduledThreadPoolWithInt_withJavaUtilConcurrentThreadFactory_(1, JreLoadStatic(IoReactivexInternalSchedulersIoScheduler, EVICTOR_THREAD_FACTORY));
    task = [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(evictor)) scheduleWithFixedDelayWithJavaLangRunnable:self withLong:self->keepAliveTime_ withLong:self->keepAliveTime_ withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, NANOSECONDS)];
  }
  JreStrongAssign(&self->evictorService_, evictor);
  JreStrongAssign(&self->evictorTask_, task);
}

IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *new_IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_initWithLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentThreadFactory_(jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool, initWithLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentThreadFactory_, keepAliveTime, unit, threadFactory)
}

IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *create_IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_initWithLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentThreadFactory_(jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool, initWithLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentThreadFactory_, keepAliveTime, unit, threadFactory)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool)

@implementation IoReactivexInternalSchedulersIoScheduler_EventLoopWorker

- (instancetype)initWithIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool:(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *)pool {
  IoReactivexInternalSchedulersIoScheduler_EventLoopWorker_initWithIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_(self, pool);
  return self;
}

- (void)dispose {
  if ([((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(once_)) compareAndSetWithBoolean:false withBoolean:true]) {
    [((IoReactivexDisposablesCompositeDisposable *) nil_chk(tasks_)) dispose];
    [((IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *) nil_chk(pool_)) release__WithIoReactivexInternalSchedulersIoScheduler_ThreadWorker:threadWorker_];
  }
}

- (jboolean)isDisposed {
  return [((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(once_)) get];
}

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)action
                                                                      withLong:(jlong)delayTime
                                                withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit {
  if ([((IoReactivexDisposablesCompositeDisposable *) nil_chk(tasks_)) isDisposed]) {
    return JreLoadEnum(IoReactivexInternalDisposablesEmptyDisposable, INSTANCE);
  }
  return [((IoReactivexInternalSchedulersIoScheduler_ThreadWorker *) nil_chk(threadWorker_)) scheduleActualWithJavaLangRunnable:action withLong:delayTime withJavaUtilConcurrentTimeUnit:unit withIoReactivexInternalDisposablesDisposableContainer:tasks_];
}

- (void)dealloc {
  RELEASE_(tasks_);
  RELEASE_(pool_);
  RELEASE_(threadWorker_);
  RELEASE_(once_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool:);
  methods[1].selector = @selector(dispose);
  methods[2].selector = @selector(isDisposed);
  methods[3].selector = @selector(scheduleWithJavaLangRunnable:withLong:withJavaUtilConcurrentTimeUnit:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "tasks_", "LIoReactivexDisposablesCompositeDisposable;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "pool_", "LIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "threadWorker_", "LIoReactivexInternalSchedulersIoScheduler_ThreadWorker;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "once_", "LJavaUtilConcurrentAtomicAtomicBoolean;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool;", "schedule", "LJavaLangRunnable;JLJavaUtilConcurrentTimeUnit;", "LIoReactivexInternalSchedulersIoScheduler;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersIoScheduler_EventLoopWorker = { "EventLoopWorker", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x18, 4, 4, 3, -1, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersIoScheduler_EventLoopWorker;
}

@end

void IoReactivexInternalSchedulersIoScheduler_EventLoopWorker_initWithIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_(IoReactivexInternalSchedulersIoScheduler_EventLoopWorker *self, IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *pool) {
  IoReactivexScheduler_Worker_init(self);
  JreStrongAssignAndConsume(&self->once_, new_JavaUtilConcurrentAtomicAtomicBoolean_init());
  JreStrongAssign(&self->pool_, pool);
  JreStrongAssignAndConsume(&self->tasks_, new_IoReactivexDisposablesCompositeDisposable_init());
  JreStrongAssign(&self->threadWorker_, [((IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *) nil_chk(pool)) get]);
}

IoReactivexInternalSchedulersIoScheduler_EventLoopWorker *new_IoReactivexInternalSchedulersIoScheduler_EventLoopWorker_initWithIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *pool) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersIoScheduler_EventLoopWorker, initWithIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_, pool)
}

IoReactivexInternalSchedulersIoScheduler_EventLoopWorker *create_IoReactivexInternalSchedulersIoScheduler_EventLoopWorker_initWithIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *pool) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersIoScheduler_EventLoopWorker, initWithIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_, pool)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersIoScheduler_EventLoopWorker)

@implementation IoReactivexInternalSchedulersIoScheduler_ThreadWorker

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory {
  IoReactivexInternalSchedulersIoScheduler_ThreadWorker_initWithJavaUtilConcurrentThreadFactory_(self, threadFactory);
  return self;
}

- (jlong)getExpirationTime {
  return expirationTime_;
}

- (void)setExpirationTimeWithLong:(jlong)expirationTime {
  self->expirationTime_ = expirationTime;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaUtilConcurrentThreadFactory:);
  methods[1].selector = @selector(getExpirationTime);
  methods[2].selector = @selector(setExpirationTimeWithLong:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "expirationTime_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilConcurrentThreadFactory;", "setExpirationTime", "J", "LIoReactivexInternalSchedulersIoScheduler;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersIoScheduler_ThreadWorker = { "ThreadWorker", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x18, 3, 1, 3, -1, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersIoScheduler_ThreadWorker;
}

@end

void IoReactivexInternalSchedulersIoScheduler_ThreadWorker_initWithJavaUtilConcurrentThreadFactory_(IoReactivexInternalSchedulersIoScheduler_ThreadWorker *self, id<JavaUtilConcurrentThreadFactory> threadFactory) {
  IoReactivexInternalSchedulersNewThreadWorker_initWithJavaUtilConcurrentThreadFactory_(self, threadFactory);
  self->expirationTime_ = 0LL;
}

IoReactivexInternalSchedulersIoScheduler_ThreadWorker *new_IoReactivexInternalSchedulersIoScheduler_ThreadWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersIoScheduler_ThreadWorker, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

IoReactivexInternalSchedulersIoScheduler_ThreadWorker *create_IoReactivexInternalSchedulersIoScheduler_ThreadWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersIoScheduler_ThreadWorker, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersIoScheduler_ThreadWorker)
