//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "IoReactivexInternalFunctionsFunctions.h"
#include "IoReactivexInternalSchedulersAbstractDirectTask.h"
#include "J2ObjC_source.h"
#include "java/lang/Runnable.h"
#include "java/lang/Thread.h"
#include "java/util/concurrent/Future.h"
#include "java/util/concurrent/FutureTask.h"
#include "java/util/concurrent/atomic/AtomicReference.h"

#pragma clang diagnostic ignored "-Wincomplete-implementation"

inline jlong IoReactivexInternalSchedulersAbstractDirectTask_get_serialVersionUID();
#define IoReactivexInternalSchedulersAbstractDirectTask_serialVersionUID 1811839108042568751LL
J2OBJC_STATIC_FIELD_CONSTANT(IoReactivexInternalSchedulersAbstractDirectTask, serialVersionUID, jlong)

J2OBJC_INITIALIZED_DEFN(IoReactivexInternalSchedulersAbstractDirectTask)

JavaUtilConcurrentFutureTask *IoReactivexInternalSchedulersAbstractDirectTask_FINISHED;
JavaUtilConcurrentFutureTask *IoReactivexInternalSchedulersAbstractDirectTask_DISPOSED;

@implementation IoReactivexInternalSchedulersAbstractDirectTask

+ (JavaUtilConcurrentFutureTask *)FINISHED {
  return IoReactivexInternalSchedulersAbstractDirectTask_FINISHED;
}

+ (JavaUtilConcurrentFutureTask *)DISPOSED {
  return IoReactivexInternalSchedulersAbstractDirectTask_DISPOSED;
}

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)runnable {
  IoReactivexInternalSchedulersAbstractDirectTask_initWithJavaLangRunnable_(self, runnable);
  return self;
}

- (void)dispose {
  id<JavaUtilConcurrentFuture> f = [self get];
  if (f != IoReactivexInternalSchedulersAbstractDirectTask_FINISHED && f != IoReactivexInternalSchedulersAbstractDirectTask_DISPOSED) {
    if ([self compareAndSetWithId:f withId:IoReactivexInternalSchedulersAbstractDirectTask_DISPOSED]) {
      if (f != nil) {
        [f cancelWithBoolean:runner_ != JavaLangThread_currentThread()];
      }
    }
  }
}

- (jboolean)isDisposed {
  id<JavaUtilConcurrentFuture> f = [self get];
  return f == IoReactivexInternalSchedulersAbstractDirectTask_FINISHED || f == IoReactivexInternalSchedulersAbstractDirectTask_DISPOSED;
}

- (void)setFutureWithJavaUtilConcurrentFuture:(id<JavaUtilConcurrentFuture>)future {
  for (; ; ) {
    id<JavaUtilConcurrentFuture> f = [self get];
    if (f == IoReactivexInternalSchedulersAbstractDirectTask_FINISHED) {
      break;
    }
    if (f == IoReactivexInternalSchedulersAbstractDirectTask_DISPOSED) {
      [((id<JavaUtilConcurrentFuture>) nil_chk(future)) cancelWithBoolean:runner_ != JavaLangThread_currentThread()];
      break;
    }
    if ([self compareAndSetWithId:f withId:future]) {
      break;
    }
  }
}

- (void)dealloc {
  RELEASE_(runnable_);
  RELEASE_(runner_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x11, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x11, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x11, 1, 2, -1, 3, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaLangRunnable:);
  methods[1].selector = @selector(dispose);
  methods[2].selector = @selector(isDisposed);
  methods[3].selector = @selector(setFutureWithJavaUtilConcurrentFuture:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID", "J", .constantValue.asLong = IoReactivexInternalSchedulersAbstractDirectTask_serialVersionUID, 0x1a, -1, -1, -1, -1 },
    { "runnable_", "LJavaLangRunnable;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "runner_", "LJavaLangThread;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "FINISHED", "LJavaUtilConcurrentFutureTask;", .constantValue.asLong = 0, 0x1c, -1, 4, 5, -1 },
    { "DISPOSED", "LJavaUtilConcurrentFutureTask;", .constantValue.asLong = 0, 0x1c, -1, 6, 5, -1 },
  };
  static const void *ptrTable[] = { "LJavaLangRunnable;", "setFuture", "LJavaUtilConcurrentFuture;", "(Ljava/util/concurrent/Future<*>;)V", &IoReactivexInternalSchedulersAbstractDirectTask_FINISHED, "Ljava/util/concurrent/FutureTask<Ljava/lang/Void;>;", &IoReactivexInternalSchedulersAbstractDirectTask_DISPOSED, "Ljava/util/concurrent/atomic/AtomicReference<Ljava/util/concurrent/Future<*>;>;Lio/reactivex/disposables/Disposable;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersAbstractDirectTask = { "AbstractDirectTask", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x400, 4, 5, -1, -1, -1, 7, -1 };
  return &_IoReactivexInternalSchedulersAbstractDirectTask;
}

+ (void)initialize {
  if (self == [IoReactivexInternalSchedulersAbstractDirectTask class]) {
    JreStrongAssignAndConsume(&IoReactivexInternalSchedulersAbstractDirectTask_FINISHED, new_JavaUtilConcurrentFutureTask_initWithJavaLangRunnable_withId_(JreLoadStatic(IoReactivexInternalFunctionsFunctions, EMPTY_RUNNABLE), nil));
    JreStrongAssignAndConsume(&IoReactivexInternalSchedulersAbstractDirectTask_DISPOSED, new_JavaUtilConcurrentFutureTask_initWithJavaLangRunnable_withId_(JreLoadStatic(IoReactivexInternalFunctionsFunctions, EMPTY_RUNNABLE), nil));
    J2OBJC_SET_INITIALIZED(IoReactivexInternalSchedulersAbstractDirectTask)
  }
}

@end

void IoReactivexInternalSchedulersAbstractDirectTask_initWithJavaLangRunnable_(IoReactivexInternalSchedulersAbstractDirectTask *self, id<JavaLangRunnable> runnable) {
  JavaUtilConcurrentAtomicAtomicReference_init(self);
  JreStrongAssign(&self->runnable_, runnable);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersAbstractDirectTask)
