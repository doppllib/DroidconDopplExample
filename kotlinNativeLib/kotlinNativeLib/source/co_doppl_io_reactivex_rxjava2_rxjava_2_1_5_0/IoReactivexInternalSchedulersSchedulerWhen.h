//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen")
#ifdef RESTRICT_IoReactivexInternalSchedulersSchedulerWhen
#define INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen 0
#else
#define INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen 1
#endif
#undef RESTRICT_IoReactivexInternalSchedulersSchedulerWhen
#ifdef INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction
#define INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction 1
#endif
#ifdef INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction
#define INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction 1
#endif

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (IoReactivexInternalSchedulersSchedulerWhen_) && (INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen || defined(INCLUDE_IoReactivexInternalSchedulersSchedulerWhen))
#define IoReactivexInternalSchedulersSchedulerWhen_

#define RESTRICT_IoReactivexScheduler 1
#define INCLUDE_IoReactivexScheduler 1
#include "IoReactivexScheduler.h"

#define RESTRICT_IoReactivexDisposablesDisposable 1
#define INCLUDE_IoReactivexDisposablesDisposable 1
#include "IoReactivexDisposablesDisposable.h"

@class IoReactivexScheduler_Worker;
@protocol IoReactivexFunctionsFunction;

@interface IoReactivexInternalSchedulersSchedulerWhen : IoReactivexScheduler < IoReactivexDisposablesDisposable >

+ (id<IoReactivexDisposablesDisposable>)SUBSCRIBED;

+ (id<IoReactivexDisposablesDisposable>)DISPOSED;

#pragma mark Public

- (instancetype)initWithIoReactivexFunctionsFunction:(id<IoReactivexFunctionsFunction>)combine
                            withIoReactivexScheduler:(IoReactivexScheduler *)actualScheduler;

- (IoReactivexScheduler_Worker * __nonnull)createWorker;

- (void)dispose;

- (jboolean)isDisposed;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen)

inline id<IoReactivexDisposablesDisposable> IoReactivexInternalSchedulersSchedulerWhen_get_SUBSCRIBED();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id<IoReactivexDisposablesDisposable> IoReactivexInternalSchedulersSchedulerWhen_SUBSCRIBED;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersSchedulerWhen, SUBSCRIBED, id<IoReactivexDisposablesDisposable>)

inline id<IoReactivexDisposablesDisposable> IoReactivexInternalSchedulersSchedulerWhen_get_DISPOSED();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id<IoReactivexDisposablesDisposable> IoReactivexInternalSchedulersSchedulerWhen_DISPOSED;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersSchedulerWhen, DISPOSED, id<IoReactivexDisposablesDisposable>)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersSchedulerWhen_initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_(IoReactivexInternalSchedulersSchedulerWhen *self, id<IoReactivexFunctionsFunction> combine, IoReactivexScheduler *actualScheduler);

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen *new_IoReactivexInternalSchedulersSchedulerWhen_initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_(id<IoReactivexFunctionsFunction> combine, IoReactivexScheduler *actualScheduler) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen *create_IoReactivexInternalSchedulersSchedulerWhen_initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_(id<IoReactivexFunctionsFunction> combine, IoReactivexScheduler *actualScheduler);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersSchedulerWhen)

#endif

#if !defined (IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_) && (INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen || defined(INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction))
#define IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_

#define RESTRICT_JavaUtilConcurrentAtomicAtomicReference 1
#define INCLUDE_JavaUtilConcurrentAtomicAtomicReference 1
#include "java/util/concurrent/atomic/AtomicReference.h"

#define RESTRICT_IoReactivexDisposablesDisposable 1
#define INCLUDE_IoReactivexDisposablesDisposable 1
#include "IoReactivexDisposablesDisposable.h"

@class IoReactivexScheduler_Worker;
@protocol IoReactivexCompletableObserver;
@protocol JavaUtilFunctionBinaryOperator;
@protocol JavaUtilFunctionUnaryOperator;

@interface IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction : JavaUtilConcurrentAtomicAtomicReference < IoReactivexDisposablesDisposable >

#pragma mark Public

- (id<IoReactivexDisposablesDisposable>)accumulateAndGetWithId:(id<IoReactivexDisposablesDisposable>)arg0
                            withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)arg1;

- (void)dispose;

- (id<IoReactivexDisposablesDisposable>)get;

- (id<IoReactivexDisposablesDisposable>)getAndAccumulateWithId:(id<IoReactivexDisposablesDisposable>)arg0
                            withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)arg1;

- (id<IoReactivexDisposablesDisposable>)getAndSetWithId:(id<IoReactivexDisposablesDisposable>)arg0;

- (id<IoReactivexDisposablesDisposable>)getAndUpdateWithJavaUtilFunctionUnaryOperator:(id<JavaUtilFunctionUnaryOperator>)arg0;

- (jboolean)isDisposed;

- (id<IoReactivexDisposablesDisposable>)updateAndGetWithJavaUtilFunctionUnaryOperator:(id<JavaUtilFunctionUnaryOperator>)arg0;

#pragma mark Protected

- (id<IoReactivexDisposablesDisposable>)callActualWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
                                               withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable;

#pragma mark Package-Private

- (instancetype)init;

- (void)callWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
         withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_init(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *self);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction)

#endif

#if !defined (IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_) && (INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen || defined(INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction))
#define IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_

@class IoReactivexScheduler_Worker;
@protocol IoReactivexCompletableObserver;
@protocol IoReactivexDisposablesDisposable;
@protocol JavaLangRunnable;
@protocol JavaUtilFunctionBinaryOperator;
@protocol JavaUtilFunctionUnaryOperator;

@interface IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction : IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction

#pragma mark Public

- (id<IoReactivexDisposablesDisposable>)accumulateAndGetWithId:(id<IoReactivexDisposablesDisposable>)arg0
                            withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)arg1;

- (id<IoReactivexDisposablesDisposable>)get;

- (id<IoReactivexDisposablesDisposable>)getAndAccumulateWithId:(id<IoReactivexDisposablesDisposable>)arg0
                            withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)arg1;

- (id<IoReactivexDisposablesDisposable>)getAndSetWithId:(id<IoReactivexDisposablesDisposable>)arg0;

- (id<IoReactivexDisposablesDisposable>)getAndUpdateWithJavaUtilFunctionUnaryOperator:(id<JavaUtilFunctionUnaryOperator>)arg0;

- (id<IoReactivexDisposablesDisposable>)updateAndGetWithJavaUtilFunctionUnaryOperator:(id<JavaUtilFunctionUnaryOperator>)arg0;

#pragma mark Protected

- (id<IoReactivexDisposablesDisposable>)callActualWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
                                               withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable;

#pragma mark Package-Private

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)action;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction *self, id<JavaLangRunnable> action);

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction *new_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(id<JavaLangRunnable> action) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction *create_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(id<JavaLangRunnable> action);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction)

#endif

#if !defined (IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_) && (INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen || defined(INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction))
#define IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_

@class IoReactivexScheduler_Worker;
@class JavaUtilConcurrentTimeUnit;
@protocol IoReactivexCompletableObserver;
@protocol IoReactivexDisposablesDisposable;
@protocol JavaLangRunnable;
@protocol JavaUtilFunctionBinaryOperator;
@protocol JavaUtilFunctionUnaryOperator;

@interface IoReactivexInternalSchedulersSchedulerWhen_DelayedAction : IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction

#pragma mark Public

- (id<IoReactivexDisposablesDisposable>)accumulateAndGetWithId:(id<IoReactivexDisposablesDisposable>)arg0
                            withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)arg1;

- (id<IoReactivexDisposablesDisposable>)get;

- (id<IoReactivexDisposablesDisposable>)getAndAccumulateWithId:(id<IoReactivexDisposablesDisposable>)arg0
                            withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)arg1;

- (id<IoReactivexDisposablesDisposable>)getAndSetWithId:(id<IoReactivexDisposablesDisposable>)arg0;

- (id<IoReactivexDisposablesDisposable>)getAndUpdateWithJavaUtilFunctionUnaryOperator:(id<JavaUtilFunctionUnaryOperator>)arg0;

- (id<IoReactivexDisposablesDisposable>)updateAndGetWithJavaUtilFunctionUnaryOperator:(id<JavaUtilFunctionUnaryOperator>)arg0;

#pragma mark Protected

- (id<IoReactivexDisposablesDisposable>)callActualWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
                                               withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable;

#pragma mark Package-Private

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)action
                                withLong:(jlong)delayTime
          withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction *self, id<JavaLangRunnable> action, jlong delayTime, JavaUtilConcurrentTimeUnit *unit);

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_DelayedAction *new_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(id<JavaLangRunnable> action, jlong delayTime, JavaUtilConcurrentTimeUnit *unit) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_DelayedAction *create_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(id<JavaLangRunnable> action, jlong delayTime, JavaUtilConcurrentTimeUnit *unit);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction)

#endif

#if !defined (IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_) && (INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen || defined(INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction))
#define IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_

#define RESTRICT_JavaLangRunnable 1
#define INCLUDE_JavaLangRunnable 1
#include "java/lang/Runnable.h"

@protocol IoReactivexCompletableObserver;

@interface IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction : NSObject < JavaLangRunnable > {
 @public
  id<IoReactivexCompletableObserver> actionCompletable_;
  id<JavaLangRunnable> action_;
}

#pragma mark Public

- (void)run;

#pragma mark Package-Private

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)action
      withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction)

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction, actionCompletable_, id<IoReactivexCompletableObserver>)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction, action_, id<JavaLangRunnable>)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction *self, id<JavaLangRunnable> action, id<IoReactivexCompletableObserver> actionCompletable);

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction *new_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(id<JavaLangRunnable> action, id<IoReactivexCompletableObserver> actionCompletable) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction *create_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(id<JavaLangRunnable> action, id<IoReactivexCompletableObserver> actionCompletable);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction)

#endif

#if !defined (IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_) && (INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen || defined(INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction))
#define IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_

#define RESTRICT_IoReactivexFunctionsFunction 1
#define INCLUDE_IoReactivexFunctionsFunction 1
#include "IoReactivexFunctionsFunction.h"

@class IoReactivexCompletable;
@class IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction;
@class IoReactivexScheduler_Worker;

@interface IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction : NSObject < IoReactivexFunctionsFunction > {
 @public
  IoReactivexScheduler_Worker *actualWorker_;
}

#pragma mark Public

- (IoReactivexCompletable *)applyWithId:(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *)action;

#pragma mark Package-Private

- (instancetype)initWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction)

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction, actualWorker_, IoReactivexScheduler_Worker *)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_initWithIoReactivexScheduler_Worker_(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction *self, IoReactivexScheduler_Worker *actualWorker);

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction *new_IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_initWithIoReactivexScheduler_Worker_(IoReactivexScheduler_Worker *actualWorker) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction *create_IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_initWithIoReactivexScheduler_Worker_(IoReactivexScheduler_Worker *actualWorker);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction)

#endif

#if !defined (IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable_) && (INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen || defined(INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable))
#define IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable_

#define RESTRICT_IoReactivexCompletable 1
#define INCLUDE_IoReactivexCompletable 1
#include "IoReactivexCompletable.h"

@class IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction;
@class IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction;
@protocol IoReactivexCompletableObserver;

@interface IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable : IoReactivexCompletable {
 @public
  IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *action_;
}

#pragma mark Protected

- (void)subscribeActualWithIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable;

#pragma mark Package-Private

- (instancetype)initWithIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction:(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction *)outer$
                         withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction:(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *)action;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable)

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable, action_, IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable_initWithIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable *self, IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction *outer$, IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *action);

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable *new_IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable_initWithIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction *outer$, IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *action) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable *create_IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable_initWithIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction *outer$, IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *action);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable)

#endif

#if !defined (IoReactivexInternalSchedulersSchedulerWhen_QueueWorker_) && (INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen || defined(INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_QueueWorker))
#define IoReactivexInternalSchedulersSchedulerWhen_QueueWorker_

#define RESTRICT_IoReactivexScheduler 1
#define INCLUDE_IoReactivexScheduler_Worker 1
#include "IoReactivexScheduler.h"

@class IoReactivexProcessorsFlowableProcessor;
@class JavaUtilConcurrentTimeUnit;
@protocol IoReactivexDisposablesDisposable;
@protocol JavaLangRunnable;

@interface IoReactivexInternalSchedulersSchedulerWhen_QueueWorker : IoReactivexScheduler_Worker

#pragma mark Public

- (void)dispose;

- (jboolean)isDisposed;

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)action;

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)action
                                                                      withLong:(jlong)delayTime
                                                withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

#pragma mark Package-Private

- (instancetype)initWithIoReactivexProcessorsFlowableProcessor:(IoReactivexProcessorsFlowableProcessor *)actionProcessor
                               withIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_QueueWorker)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersSchedulerWhen_QueueWorker_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(IoReactivexInternalSchedulersSchedulerWhen_QueueWorker *self, IoReactivexProcessorsFlowableProcessor *actionProcessor, IoReactivexScheduler_Worker *actualWorker);

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_QueueWorker *new_IoReactivexInternalSchedulersSchedulerWhen_QueueWorker_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(IoReactivexProcessorsFlowableProcessor *actionProcessor, IoReactivexScheduler_Worker *actualWorker) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_QueueWorker *create_IoReactivexInternalSchedulersSchedulerWhen_QueueWorker_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(IoReactivexProcessorsFlowableProcessor *actionProcessor, IoReactivexScheduler_Worker *actualWorker);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersSchedulerWhen_QueueWorker)

#endif

#if !defined (IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable_) && (INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen || defined(INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable))
#define IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable_

#define RESTRICT_IoReactivexDisposablesDisposable 1
#define INCLUDE_IoReactivexDisposablesDisposable 1
#include "IoReactivexDisposablesDisposable.h"

@interface IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable : NSObject < IoReactivexDisposablesDisposable >

#pragma mark Public

- (void)dispose;

- (jboolean)isDisposed;

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable_init(IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable *self);

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable *new_IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable *create_IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable_init();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen")
