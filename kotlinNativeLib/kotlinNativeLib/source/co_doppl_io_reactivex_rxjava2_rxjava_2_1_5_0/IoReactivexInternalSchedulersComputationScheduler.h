//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_IoReactivexInternalSchedulersComputationScheduler")
#ifdef RESTRICT_IoReactivexInternalSchedulersComputationScheduler
#define INCLUDE_ALL_IoReactivexInternalSchedulersComputationScheduler 0
#else
#define INCLUDE_ALL_IoReactivexInternalSchedulersComputationScheduler 1
#endif
#undef RESTRICT_IoReactivexInternalSchedulersComputationScheduler

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (IoReactivexInternalSchedulersComputationScheduler_) && (INCLUDE_ALL_IoReactivexInternalSchedulersComputationScheduler || defined(INCLUDE_IoReactivexInternalSchedulersComputationScheduler))
#define IoReactivexInternalSchedulersComputationScheduler_

#define RESTRICT_IoReactivexScheduler 1
#define INCLUDE_IoReactivexScheduler 1
#include "IoReactivexScheduler.h"

@class IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool;
@class IoReactivexInternalSchedulersComputationScheduler_PoolWorker;
@class IoReactivexInternalSchedulersRxThreadFactory;
@class IoReactivexScheduler_Worker;
@class JavaUtilConcurrentAtomicAtomicReference;
@class JavaUtilConcurrentTimeUnit;
@protocol IoReactivexDisposablesDisposable;
@protocol JavaLangRunnable;
@protocol JavaUtilConcurrentThreadFactory;

@interface IoReactivexInternalSchedulersComputationScheduler : IoReactivexScheduler {
 @public
  id<JavaUtilConcurrentThreadFactory> threadFactory_;
  JavaUtilConcurrentAtomicAtomicReference *pool_;
}

+ (IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool *)NONE;

+ (IoReactivexInternalSchedulersRxThreadFactory *)THREAD_FACTORY;

+ (NSString *)KEY_MAX_THREADS;

+ (jint)MAX_THREADS;

+ (IoReactivexInternalSchedulersComputationScheduler_PoolWorker *)SHUTDOWN_WORKER;

#pragma mark Public

- (instancetype)init;

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory;

- (IoReactivexScheduler_Worker * __nonnull)createWorker;

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleDirectWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)run
                                                                            withLong:(jlong)delay
                                                      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

- (id<IoReactivexDisposablesDisposable> __nonnull)schedulePeriodicallyDirectWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)run
                                                                                        withLong:(jlong)initialDelay
                                                                                        withLong:(jlong)period
                                                                  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

- (void)shutdown;

- (void)start;

#pragma mark Package-Private

+ (jint)capWithInt:(jint)cpuCount
           withInt:(jint)paramThreads;

@end

J2OBJC_STATIC_INIT(IoReactivexInternalSchedulersComputationScheduler)

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersComputationScheduler, threadFactory_, id<JavaUtilConcurrentThreadFactory>)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersComputationScheduler, pool_, JavaUtilConcurrentAtomicAtomicReference *)

inline IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool *IoReactivexInternalSchedulersComputationScheduler_get_NONE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool *IoReactivexInternalSchedulersComputationScheduler_NONE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersComputationScheduler, NONE, IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool *)

inline IoReactivexInternalSchedulersRxThreadFactory *IoReactivexInternalSchedulersComputationScheduler_get_THREAD_FACTORY();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexInternalSchedulersRxThreadFactory *IoReactivexInternalSchedulersComputationScheduler_THREAD_FACTORY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersComputationScheduler, THREAD_FACTORY, IoReactivexInternalSchedulersRxThreadFactory *)

inline NSString *IoReactivexInternalSchedulersComputationScheduler_get_KEY_MAX_THREADS();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *IoReactivexInternalSchedulersComputationScheduler_KEY_MAX_THREADS;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersComputationScheduler, KEY_MAX_THREADS, NSString *)

inline jint IoReactivexInternalSchedulersComputationScheduler_get_MAX_THREADS();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jint IoReactivexInternalSchedulersComputationScheduler_MAX_THREADS;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(IoReactivexInternalSchedulersComputationScheduler, MAX_THREADS, jint)

inline IoReactivexInternalSchedulersComputationScheduler_PoolWorker *IoReactivexInternalSchedulersComputationScheduler_get_SHUTDOWN_WORKER();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexInternalSchedulersComputationScheduler_PoolWorker *IoReactivexInternalSchedulersComputationScheduler_SHUTDOWN_WORKER;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersComputationScheduler, SHUTDOWN_WORKER, IoReactivexInternalSchedulersComputationScheduler_PoolWorker *)

FOUNDATION_EXPORT jint IoReactivexInternalSchedulersComputationScheduler_capWithInt_withInt_(jint cpuCount, jint paramThreads);

FOUNDATION_EXPORT void IoReactivexInternalSchedulersComputationScheduler_init(IoReactivexInternalSchedulersComputationScheduler *self);

FOUNDATION_EXPORT IoReactivexInternalSchedulersComputationScheduler *new_IoReactivexInternalSchedulersComputationScheduler_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersComputationScheduler *create_IoReactivexInternalSchedulersComputationScheduler_init();

FOUNDATION_EXPORT void IoReactivexInternalSchedulersComputationScheduler_initWithJavaUtilConcurrentThreadFactory_(IoReactivexInternalSchedulersComputationScheduler *self, id<JavaUtilConcurrentThreadFactory> threadFactory);

FOUNDATION_EXPORT IoReactivexInternalSchedulersComputationScheduler *new_IoReactivexInternalSchedulersComputationScheduler_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersComputationScheduler *create_IoReactivexInternalSchedulersComputationScheduler_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersComputationScheduler)

#endif

#if !defined (IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool_) && (INCLUDE_ALL_IoReactivexInternalSchedulersComputationScheduler || defined(INCLUDE_IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool))
#define IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool_

@class IOSObjectArray;
@class IoReactivexInternalSchedulersComputationScheduler_PoolWorker;
@protocol JavaUtilConcurrentThreadFactory;

@interface IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool : NSObject {
 @public
  jint cores_;
  IOSObjectArray *eventLoops_;
  jlong n_;
}

#pragma mark Public

- (IoReactivexInternalSchedulersComputationScheduler_PoolWorker *)getEventLoop;

- (void)shutdown;

#pragma mark Package-Private

- (instancetype)initWithInt:(jint)maxThreads
withJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool)

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool, eventLoops_, IOSObjectArray *)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool_initWithInt_withJavaUtilConcurrentThreadFactory_(IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool *self, jint maxThreads, id<JavaUtilConcurrentThreadFactory> threadFactory);

FOUNDATION_EXPORT IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool *new_IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool_initWithInt_withJavaUtilConcurrentThreadFactory_(jint maxThreads, id<JavaUtilConcurrentThreadFactory> threadFactory) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool *create_IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool_initWithInt_withJavaUtilConcurrentThreadFactory_(jint maxThreads, id<JavaUtilConcurrentThreadFactory> threadFactory);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersComputationScheduler_FixedSchedulerPool)

#endif

#if !defined (IoReactivexInternalSchedulersComputationScheduler_EventLoopWorker_) && (INCLUDE_ALL_IoReactivexInternalSchedulersComputationScheduler || defined(INCLUDE_IoReactivexInternalSchedulersComputationScheduler_EventLoopWorker))
#define IoReactivexInternalSchedulersComputationScheduler_EventLoopWorker_

#define RESTRICT_IoReactivexScheduler 1
#define INCLUDE_IoReactivexScheduler_Worker 1
#include "IoReactivexScheduler.h"

@class IoReactivexInternalSchedulersComputationScheduler_PoolWorker;
@class JavaUtilConcurrentTimeUnit;
@protocol IoReactivexDisposablesDisposable;
@protocol JavaLangRunnable;

@interface IoReactivexInternalSchedulersComputationScheduler_EventLoopWorker : IoReactivexScheduler_Worker {
 @public
  volatile_jboolean disposed_;
}

#pragma mark Public

- (void)dispose;

- (jboolean)isDisposed;

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)action;

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)action
                                                                      withLong:(jlong)delayTime
                                                withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

#pragma mark Package-Private

- (instancetype)initWithIoReactivexInternalSchedulersComputationScheduler_PoolWorker:(IoReactivexInternalSchedulersComputationScheduler_PoolWorker *)poolWorker;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersComputationScheduler_EventLoopWorker)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersComputationScheduler_EventLoopWorker_initWithIoReactivexInternalSchedulersComputationScheduler_PoolWorker_(IoReactivexInternalSchedulersComputationScheduler_EventLoopWorker *self, IoReactivexInternalSchedulersComputationScheduler_PoolWorker *poolWorker);

FOUNDATION_EXPORT IoReactivexInternalSchedulersComputationScheduler_EventLoopWorker *new_IoReactivexInternalSchedulersComputationScheduler_EventLoopWorker_initWithIoReactivexInternalSchedulersComputationScheduler_PoolWorker_(IoReactivexInternalSchedulersComputationScheduler_PoolWorker *poolWorker) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersComputationScheduler_EventLoopWorker *create_IoReactivexInternalSchedulersComputationScheduler_EventLoopWorker_initWithIoReactivexInternalSchedulersComputationScheduler_PoolWorker_(IoReactivexInternalSchedulersComputationScheduler_PoolWorker *poolWorker);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersComputationScheduler_EventLoopWorker)

#endif

#if !defined (IoReactivexInternalSchedulersComputationScheduler_PoolWorker_) && (INCLUDE_ALL_IoReactivexInternalSchedulersComputationScheduler || defined(INCLUDE_IoReactivexInternalSchedulersComputationScheduler_PoolWorker))
#define IoReactivexInternalSchedulersComputationScheduler_PoolWorker_

#define RESTRICT_IoReactivexInternalSchedulersNewThreadWorker 1
#define INCLUDE_IoReactivexInternalSchedulersNewThreadWorker 1
#include "IoReactivexInternalSchedulersNewThreadWorker.h"

@protocol JavaUtilConcurrentThreadFactory;

@interface IoReactivexInternalSchedulersComputationScheduler_PoolWorker : IoReactivexInternalSchedulersNewThreadWorker

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersComputationScheduler_PoolWorker)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersComputationScheduler_PoolWorker_initWithJavaUtilConcurrentThreadFactory_(IoReactivexInternalSchedulersComputationScheduler_PoolWorker *self, id<JavaUtilConcurrentThreadFactory> threadFactory);

FOUNDATION_EXPORT IoReactivexInternalSchedulersComputationScheduler_PoolWorker *new_IoReactivexInternalSchedulersComputationScheduler_PoolWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersComputationScheduler_PoolWorker *create_IoReactivexInternalSchedulersComputationScheduler_PoolWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersComputationScheduler_PoolWorker)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_IoReactivexInternalSchedulersComputationScheduler")
