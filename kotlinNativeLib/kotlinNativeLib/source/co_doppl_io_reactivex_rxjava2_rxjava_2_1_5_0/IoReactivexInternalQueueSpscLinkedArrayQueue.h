//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_IoReactivexInternalQueueSpscLinkedArrayQueue")
#ifdef RESTRICT_IoReactivexInternalQueueSpscLinkedArrayQueue
#define INCLUDE_ALL_IoReactivexInternalQueueSpscLinkedArrayQueue 0
#else
#define INCLUDE_ALL_IoReactivexInternalQueueSpscLinkedArrayQueue 1
#endif
#undef RESTRICT_IoReactivexInternalQueueSpscLinkedArrayQueue

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (IoReactivexInternalQueueSpscLinkedArrayQueue_) && (INCLUDE_ALL_IoReactivexInternalQueueSpscLinkedArrayQueue || defined(INCLUDE_IoReactivexInternalQueueSpscLinkedArrayQueue))
#define IoReactivexInternalQueueSpscLinkedArrayQueue_

#define RESTRICT_IoReactivexInternalFuseableSimplePlainQueue 1
#define INCLUDE_IoReactivexInternalFuseableSimplePlainQueue 1
#include "IoReactivexInternalFuseableSimplePlainQueue.h"

@class JavaUtilConcurrentAtomicAtomicLong;
@class JavaUtilConcurrentAtomicAtomicReferenceArray;

@interface IoReactivexInternalQueueSpscLinkedArrayQueue : NSObject < IoReactivexInternalFuseableSimplePlainQueue > {
 @public
  JavaUtilConcurrentAtomicAtomicLong *producerIndex_;
  jint producerLookAheadStep_;
  jlong producerLookAhead_;
  jint producerMask_;
  JavaUtilConcurrentAtomicAtomicReferenceArray *producerBuffer_;
  jint consumerMask_;
  JavaUtilConcurrentAtomicAtomicReferenceArray *consumerBuffer_;
  JavaUtilConcurrentAtomicAtomicLong *consumerIndex_;
}

+ (jint)MAX_LOOK_AHEAD_STEP;

#pragma mark Public

- (instancetype)initWithInt:(jint)bufferSize;

- (void)clear;

- (jboolean)isEmpty;

- (jboolean)offerWithId:(id)e;

- (jboolean)offerWithId:(id)first
                 withId:(id)second;

- (id)peek;

- (id __nullable)poll;

- (jint)size;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(IoReactivexInternalQueueSpscLinkedArrayQueue)

J2OBJC_FIELD_SETTER(IoReactivexInternalQueueSpscLinkedArrayQueue, producerIndex_, JavaUtilConcurrentAtomicAtomicLong *)
J2OBJC_FIELD_SETTER(IoReactivexInternalQueueSpscLinkedArrayQueue, producerBuffer_, JavaUtilConcurrentAtomicAtomicReferenceArray *)
J2OBJC_FIELD_SETTER(IoReactivexInternalQueueSpscLinkedArrayQueue, consumerBuffer_, JavaUtilConcurrentAtomicAtomicReferenceArray *)
J2OBJC_FIELD_SETTER(IoReactivexInternalQueueSpscLinkedArrayQueue, consumerIndex_, JavaUtilConcurrentAtomicAtomicLong *)

inline jint IoReactivexInternalQueueSpscLinkedArrayQueue_get_MAX_LOOK_AHEAD_STEP();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jint IoReactivexInternalQueueSpscLinkedArrayQueue_MAX_LOOK_AHEAD_STEP;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(IoReactivexInternalQueueSpscLinkedArrayQueue, MAX_LOOK_AHEAD_STEP, jint)

FOUNDATION_EXPORT void IoReactivexInternalQueueSpscLinkedArrayQueue_initWithInt_(IoReactivexInternalQueueSpscLinkedArrayQueue *self, jint bufferSize);

FOUNDATION_EXPORT IoReactivexInternalQueueSpscLinkedArrayQueue *new_IoReactivexInternalQueueSpscLinkedArrayQueue_initWithInt_(jint bufferSize) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalQueueSpscLinkedArrayQueue *create_IoReactivexInternalQueueSpscLinkedArrayQueue_initWithInt_(jint bufferSize);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalQueueSpscLinkedArrayQueue)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_IoReactivexInternalQueueSpscLinkedArrayQueue")
