//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "IoReactivexBackpressureStrategy.h"
#include "IoReactivexDisposablesDisposable.h"
#include "IoReactivexExceptionsExceptions.h"
#include "IoReactivexExceptionsMissingBackpressureException.h"
#include "IoReactivexFlowable.h"
#include "IoReactivexFlowableEmitter.h"
#include "IoReactivexFlowableOnSubscribe.h"
#include "IoReactivexFunctionsCancellable.h"
#include "IoReactivexInternalDisposablesCancellableDisposable.h"
#include "IoReactivexInternalDisposablesSequentialDisposable.h"
#include "IoReactivexInternalFuseableSimplePlainQueue.h"
#include "IoReactivexInternalOperatorsFlowableFlowableCreate.h"
#include "IoReactivexInternalQueueSpscLinkedArrayQueue.h"
#include "IoReactivexInternalSubscriptionsSubscriptionHelper.h"
#include "IoReactivexInternalUtilAtomicThrowable.h"
#include "IoReactivexInternalUtilBackpressureHelper.h"
#include "IoReactivexPluginsRxJavaPlugins.h"
#include "J2ObjC_source.h"
#include "OrgReactivestreamsSubscriber.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/Throwable.h"
#include "java/util/concurrent/atomic/AtomicInteger.h"
#include "java/util/concurrent/atomic/AtomicLong.h"
#include "java/util/concurrent/atomic/AtomicReference.h"

#pragma clang diagnostic ignored "-Wprotocol"

inline jlong IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter_get_serialVersionUID();
#define IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter_serialVersionUID 4883307006032401862LL
J2OBJC_STATIC_FIELD_CONSTANT(IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter, serialVersionUID, jlong)

inline jlong IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_get_serialVersionUID();
#define IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_serialVersionUID 7326289992464377023LL
J2OBJC_STATIC_FIELD_CONSTANT(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter, serialVersionUID, jlong)

__attribute__((unused)) static void IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_onErrorWithJavaLangThrowable_(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *self, JavaLangThrowable *e);

__attribute__((unused)) static jboolean IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *self);

__attribute__((unused)) static void IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_setDisposableWithIoReactivexDisposablesDisposable_(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *self, id<IoReactivexDisposablesDisposable> s);

__attribute__((unused)) static void IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_setCancellableWithIoReactivexFunctionsCancellable_(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *self, id<IoReactivexFunctionsCancellable> c);

__attribute__((unused)) static jlong IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_requested(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *self);

inline jlong IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter_get_serialVersionUID();
#define IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter_serialVersionUID 3776720187248809713LL
J2OBJC_STATIC_FIELD_CONSTANT(IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter, serialVersionUID, jlong)

inline jlong IoReactivexInternalOperatorsFlowableFlowableCreate_NoOverflowBaseAsyncEmitter_get_serialVersionUID();
#define IoReactivexInternalOperatorsFlowableFlowableCreate_NoOverflowBaseAsyncEmitter_serialVersionUID 4127754106204442833LL
J2OBJC_STATIC_FIELD_CONSTANT(IoReactivexInternalOperatorsFlowableFlowableCreate_NoOverflowBaseAsyncEmitter, serialVersionUID, jlong)

inline jlong IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter_get_serialVersionUID();
#define IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter_serialVersionUID 8360058422307496563LL
J2OBJC_STATIC_FIELD_CONSTANT(IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter, serialVersionUID, jlong)

inline jlong IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter_get_serialVersionUID();
#define IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter_serialVersionUID 338953216916120960LL
J2OBJC_STATIC_FIELD_CONSTANT(IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter, serialVersionUID, jlong)

inline jlong IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter_get_serialVersionUID();
#define IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter_serialVersionUID 2427151001689639875LL
J2OBJC_STATIC_FIELD_CONSTANT(IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter, serialVersionUID, jlong)

inline jlong IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter_get_serialVersionUID();
#define IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter_serialVersionUID 4023437720691792495LL
J2OBJC_STATIC_FIELD_CONSTANT(IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter, serialVersionUID, jlong)

@implementation IoReactivexInternalOperatorsFlowableFlowableCreate

- (instancetype)initWithIoReactivexFlowableOnSubscribe:(id<IoReactivexFlowableOnSubscribe>)source
                   withIoReactivexBackpressureStrategy:(IoReactivexBackpressureStrategy *)backpressure {
  IoReactivexInternalOperatorsFlowableFlowableCreate_initWithIoReactivexFlowableOnSubscribe_withIoReactivexBackpressureStrategy_(self, source, backpressure);
  return self;
}

- (void)subscribeActualWithOrgReactivestreamsSubscriber:(id<OrgReactivestreamsSubscriber>)t {
  IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *emitter;
  switch ([backpressure_ ordinal]) {
    case IoReactivexBackpressureStrategy_Enum_MISSING:
    {
      emitter = create_IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter_initWithOrgReactivestreamsSubscriber_(t);
      break;
    }
    case IoReactivexBackpressureStrategy_Enum_ERROR:
    {
      emitter = create_IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter_initWithOrgReactivestreamsSubscriber_(t);
      break;
    }
    case IoReactivexBackpressureStrategy_Enum_DROP:
    {
      emitter = create_IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter_initWithOrgReactivestreamsSubscriber_(t);
      break;
    }
    case IoReactivexBackpressureStrategy_Enum_LATEST:
    {
      emitter = create_IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter_initWithOrgReactivestreamsSubscriber_(t);
      break;
    }
    default:
    {
      emitter = create_IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter_initWithOrgReactivestreamsSubscriber_withInt_(t, IoReactivexFlowable_bufferSize());
      break;
    }
  }
  [((id<OrgReactivestreamsSubscriber>) nil_chk(t)) onSubscribeWithOrgReactivestreamsSubscription:emitter];
  @try {
    [((id<IoReactivexFlowableOnSubscribe>) nil_chk(source_)) subscribeWithIoReactivexFlowableEmitter:emitter];
  }
  @catch (JavaLangThrowable *ex) {
    IoReactivexExceptionsExceptions_throwIfFatalWithJavaLangThrowable_(ex);
    IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_onErrorWithJavaLangThrowable_(nil_chk(emitter), ex);
  }
}

- (void)dealloc {
  RELEASE_(source_);
  RELEASE_(backpressure_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, 1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, 4, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithIoReactivexFlowableOnSubscribe:withIoReactivexBackpressureStrategy:);
  methods[1].selector = @selector(subscribeActualWithOrgReactivestreamsSubscriber:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "source_", "LIoReactivexFlowableOnSubscribe;", .constantValue.asLong = 0, 0x10, -1, -1, 5, -1 },
    { "backpressure_", "LIoReactivexBackpressureStrategy;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LIoReactivexFlowableOnSubscribe;LIoReactivexBackpressureStrategy;", "(Lio/reactivex/FlowableOnSubscribe<TT;>;Lio/reactivex/BackpressureStrategy;)V", "subscribeActual", "LOrgReactivestreamsSubscriber;", "(Lorg/reactivestreams/Subscriber<-TT;>;)V", "Lio/reactivex/FlowableOnSubscribe<TT;>;", "LIoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter;LIoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter;LIoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter;LIoReactivexInternalOperatorsFlowableFlowableCreate_NoOverflowBaseAsyncEmitter;LIoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter;LIoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter;LIoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter;LIoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter;", "<T:Ljava/lang/Object;>Lio/reactivex/Flowable<TT;>;" };
  static const J2ObjcClassInfo _IoReactivexInternalOperatorsFlowableFlowableCreate = { "FlowableCreate", "io.reactivex.internal.operators.flowable", ptrTable, methods, fields, 7, 0x11, 2, 2, -1, 6, -1, 7, -1 };
  return &_IoReactivexInternalOperatorsFlowableFlowableCreate;
}

@end

void IoReactivexInternalOperatorsFlowableFlowableCreate_initWithIoReactivexFlowableOnSubscribe_withIoReactivexBackpressureStrategy_(IoReactivexInternalOperatorsFlowableFlowableCreate *self, id<IoReactivexFlowableOnSubscribe> source, IoReactivexBackpressureStrategy *backpressure) {
  IoReactivexFlowable_init(self);
  JreStrongAssign(&self->source_, source);
  JreStrongAssign(&self->backpressure_, backpressure);
}

IoReactivexInternalOperatorsFlowableFlowableCreate *new_IoReactivexInternalOperatorsFlowableFlowableCreate_initWithIoReactivexFlowableOnSubscribe_withIoReactivexBackpressureStrategy_(id<IoReactivexFlowableOnSubscribe> source, IoReactivexBackpressureStrategy *backpressure) {
  J2OBJC_NEW_IMPL(IoReactivexInternalOperatorsFlowableFlowableCreate, initWithIoReactivexFlowableOnSubscribe_withIoReactivexBackpressureStrategy_, source, backpressure)
}

IoReactivexInternalOperatorsFlowableFlowableCreate *create_IoReactivexInternalOperatorsFlowableFlowableCreate_initWithIoReactivexFlowableOnSubscribe_withIoReactivexBackpressureStrategy_(id<IoReactivexFlowableOnSubscribe> source, IoReactivexBackpressureStrategy *backpressure) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalOperatorsFlowableFlowableCreate, initWithIoReactivexFlowableOnSubscribe_withIoReactivexBackpressureStrategy_, source, backpressure)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalOperatorsFlowableFlowableCreate)

@implementation IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter

- (instancetype)initWithIoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter:(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *)emitter {
  IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter_initWithIoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_(self, emitter);
  return self;
}

- (void)onNextWithId:(id)t {
  if (IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(nil_chk(emitter_)) || JreLoadVolatileBoolean(&done_)) {
    return;
  }
  if (t == nil) {
    [self onErrorWithJavaLangThrowable:create_JavaLangNullPointerException_initWithNSString_(@"onNext called with null. Null values are generally not allowed in 2.x operators and sources.")];
    return;
  }
  if ([self get] == 0 && [self compareAndSetWithInt:0 withInt:1]) {
    [emitter_ onNextWithId:t];
    if ([self decrementAndGet] == 0) {
      return;
    }
  }
  else {
    id<IoReactivexInternalFuseableSimplePlainQueue> q = queue_;
    @synchronized(q) {
      [((id<IoReactivexInternalFuseableSimplePlainQueue>) nil_chk(q)) offerWithId:t];
    }
    if ([self getAndIncrement] != 0) {
      return;
    }
  }
  [self drainLoop];
}

- (void)onErrorWithJavaLangThrowable:(JavaLangThrowable *)t {
  if (![self tryOnErrorWithJavaLangThrowable:t]) {
    IoReactivexPluginsRxJavaPlugins_onErrorWithJavaLangThrowable_(t);
  }
}

- (jboolean)tryOnErrorWithJavaLangThrowable:(JavaLangThrowable *)t {
  if (IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(nil_chk(emitter_)) || JreLoadVolatileBoolean(&done_)) {
    return false;
  }
  if (t == nil) {
    t = create_JavaLangNullPointerException_initWithNSString_(@"onError called with null. Null values are generally not allowed in 2.x operators and sources.");
  }
  if ([((IoReactivexInternalUtilAtomicThrowable *) nil_chk(error_)) addThrowableWithJavaLangThrowable:t]) {
    JreAssignVolatileBoolean(&done_, true);
    [self drain];
    return true;
  }
  return false;
}

- (void)onComplete {
  if (IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(nil_chk(emitter_)) || JreLoadVolatileBoolean(&done_)) {
    return;
  }
  JreAssignVolatileBoolean(&done_, true);
  [self drain];
}

- (void)drain {
  if ([self getAndIncrement] == 0) {
    [self drainLoop];
  }
}

- (void)drainLoop {
  IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *e = emitter_;
  id<IoReactivexInternalFuseableSimplePlainQueue> q = queue_;
  IoReactivexInternalUtilAtomicThrowable *error = self->error_;
  jint missed = 1;
  for (; ; ) {
    for (; ; ) {
      if (IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(nil_chk(e))) {
        [((id<IoReactivexInternalFuseableSimplePlainQueue>) nil_chk(q)) clear];
        return;
      }
      if ([((IoReactivexInternalUtilAtomicThrowable *) nil_chk(error)) get] != nil) {
        [((id<IoReactivexInternalFuseableSimplePlainQueue>) nil_chk(q)) clear];
        IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_onErrorWithJavaLangThrowable_(e, [error terminate]);
        return;
      }
      jboolean d = JreLoadVolatileBoolean(&done_);
      id v = [((id<IoReactivexInternalFuseableSimplePlainQueue>) nil_chk(q)) poll];
      jboolean empty = v == nil;
      if (d && empty) {
        [e onComplete];
        return;
      }
      if (empty) {
        break;
      }
      [e onNextWithId:v];
    }
    missed = [self addAndGetWithInt:-missed];
    if (missed == 0) {
      break;
    }
  }
}

- (void)setDisposableWithIoReactivexDisposablesDisposable:(id<IoReactivexDisposablesDisposable>)s {
  IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_setDisposableWithIoReactivexDisposablesDisposable_(nil_chk(emitter_), s);
}

- (void)setCancellableWithIoReactivexFunctionsCancellable:(id<IoReactivexFunctionsCancellable>)c {
  IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_setCancellableWithIoReactivexFunctionsCancellable_(nil_chk(emitter_), c);
}

- (jlong)requested {
  return IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_requested(nil_chk(emitter_));
}

- (jboolean)isCancelled {
  return IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(nil_chk(emitter_));
}

- (id<IoReactivexFlowableEmitter>)serialize {
  return self;
}

- (jboolean)isEqual:(id)obj {
  return self == obj;
}

- (NSUInteger)hash {
  return (NSUInteger)self;
}

- (void)dealloc {
  RELEASE_(emitter_);
  RELEASE_(error_);
  RELEASE_(queue_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, 1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, 4, -1, -1 },
    { NULL, "V", 0x1, 5, 6, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 7, 6, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexFlowableEmitter;", 0x1, -1, -1, -1, 12, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithIoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter:);
  methods[1].selector = @selector(onNextWithId:);
  methods[2].selector = @selector(onErrorWithJavaLangThrowable:);
  methods[3].selector = @selector(tryOnErrorWithJavaLangThrowable:);
  methods[4].selector = @selector(onComplete);
  methods[5].selector = @selector(drain);
  methods[6].selector = @selector(drainLoop);
  methods[7].selector = @selector(setDisposableWithIoReactivexDisposablesDisposable:);
  methods[8].selector = @selector(setCancellableWithIoReactivexFunctionsCancellable:);
  methods[9].selector = @selector(requested);
  methods[10].selector = @selector(isCancelled);
  methods[11].selector = @selector(serialize);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID", "J", .constantValue.asLong = IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter_serialVersionUID, 0x1a, -1, -1, -1, -1 },
    { "emitter_", "LIoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter;", .constantValue.asLong = 0, 0x10, -1, -1, 13, -1 },
    { "error_", "LIoReactivexInternalUtilAtomicThrowable;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "queue_", "LIoReactivexInternalFuseableSimplePlainQueue;", .constantValue.asLong = 0, 0x10, -1, -1, 14, -1 },
    { "done_", "Z", .constantValue.asLong = 0, 0x40, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LIoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter;", "(Lio/reactivex/internal/operators/flowable/FlowableCreate$BaseEmitter<TT;>;)V", "onNext", "LNSObject;", "(TT;)V", "onError", "LJavaLangThrowable;", "tryOnError", "setDisposable", "LIoReactivexDisposablesDisposable;", "setCancellable", "LIoReactivexFunctionsCancellable;", "()Lio/reactivex/FlowableEmitter<TT;>;", "Lio/reactivex/internal/operators/flowable/FlowableCreate$BaseEmitter<TT;>;", "Lio/reactivex/internal/fuseable/SimplePlainQueue<TT;>;", "LIoReactivexInternalOperatorsFlowableFlowableCreate;", "<T:Ljava/lang/Object;>Ljava/util/concurrent/atomic/AtomicInteger;Lio/reactivex/FlowableEmitter<TT;>;" };
  static const J2ObjcClassInfo _IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter = { "SerializedEmitter", "io.reactivex.internal.operators.flowable", ptrTable, methods, fields, 7, 0x18, 12, 5, 15, -1, -1, 16, -1 };
  return &_IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter;
}

@end

void IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter_initWithIoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_(IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter *self, IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *emitter) {
  JavaUtilConcurrentAtomicAtomicInteger_init(self);
  JreStrongAssign(&self->emitter_, emitter);
  JreStrongAssignAndConsume(&self->error_, new_IoReactivexInternalUtilAtomicThrowable_init());
  JreStrongAssignAndConsume(&self->queue_, new_IoReactivexInternalQueueSpscLinkedArrayQueue_initWithInt_(16));
}

IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter *new_IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter_initWithIoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *emitter) {
  J2OBJC_NEW_IMPL(IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter, initWithIoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_, emitter)
}

IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter *create_IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter_initWithIoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *emitter) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter, initWithIoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_, emitter)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter)

@implementation IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter

- (instancetype)initWithOrgReactivestreamsSubscriber:(id<OrgReactivestreamsSubscriber>)actual {
  IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_initWithOrgReactivestreamsSubscriber_(self, actual);
  return self;
}

- (void)onComplete {
  [self complete];
}

- (void)complete {
  if (IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(self)) {
    return;
  }
  @try {
    [((id<OrgReactivestreamsSubscriber>) nil_chk(actual_)) onComplete];
  }
  @finally {
    [((IoReactivexInternalDisposablesSequentialDisposable *) nil_chk(serial_)) dispose];
  }
}

- (void)onErrorWithJavaLangThrowable:(JavaLangThrowable *)e {
  IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_onErrorWithJavaLangThrowable_(self, e);
}

- (jboolean)tryOnErrorWithJavaLangThrowable:(JavaLangThrowable *)e {
  return [self errorWithJavaLangThrowable:e];
}

- (jboolean)errorWithJavaLangThrowable:(JavaLangThrowable *)e {
  if (e == nil) {
    e = create_JavaLangNullPointerException_initWithNSString_(@"onError called with null. Null values are generally not allowed in 2.x operators and sources.");
  }
  if (IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(self)) {
    return false;
  }
  @try {
    [((id<OrgReactivestreamsSubscriber>) nil_chk(actual_)) onErrorWithJavaLangThrowable:e];
  }
  @finally {
    [((IoReactivexInternalDisposablesSequentialDisposable *) nil_chk(serial_)) dispose];
  }
  return true;
}

- (void)cancel {
  [((IoReactivexInternalDisposablesSequentialDisposable *) nil_chk(serial_)) dispose];
  [self onUnsubscribed];
}

- (void)onUnsubscribed {
}

- (jboolean)isCancelled {
  return IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(self);
}

- (void)requestWithLong:(jlong)n {
  if (IoReactivexInternalSubscriptionsSubscriptionHelper_validateWithLong_(n)) {
    IoReactivexInternalUtilBackpressureHelper_addWithJavaUtilConcurrentAtomicAtomicLong_withLong_(self, n);
    [self onRequested];
  }
}

- (void)onRequested {
}

- (void)setDisposableWithIoReactivexDisposablesDisposable:(id<IoReactivexDisposablesDisposable>)s {
  IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_setDisposableWithIoReactivexDisposablesDisposable_(self, s);
}

- (void)setCancellableWithIoReactivexFunctionsCancellable:(id<IoReactivexFunctionsCancellable>)c {
  IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_setCancellableWithIoReactivexFunctionsCancellable_(self, c);
}

- (jlong)requested {
  return IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_requested(self);
}

- (id<IoReactivexFlowableEmitter>)serialize {
  return create_IoReactivexInternalOperatorsFlowableFlowableCreate_SerializedEmitter_initWithIoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_(self);
}

- (jboolean)isEqual:(id)obj {
  return self == obj;
}

- (NSUInteger)hash {
  return (NSUInteger)self;
}

- (void)dealloc {
  RELEASE_(actual_);
  RELEASE_(serial_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, 1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x11, 2, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 4, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x4, 5, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x11, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x11, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x11, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x11, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x11, 10, 11, -1, -1, -1, -1 },
    { NULL, "J", 0x11, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexFlowableEmitter;", 0x11, -1, -1, -1, 12, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOrgReactivestreamsSubscriber:);
  methods[1].selector = @selector(onComplete);
  methods[2].selector = @selector(complete);
  methods[3].selector = @selector(onErrorWithJavaLangThrowable:);
  methods[4].selector = @selector(tryOnErrorWithJavaLangThrowable:);
  methods[5].selector = @selector(errorWithJavaLangThrowable:);
  methods[6].selector = @selector(cancel);
  methods[7].selector = @selector(onUnsubscribed);
  methods[8].selector = @selector(isCancelled);
  methods[9].selector = @selector(requestWithLong:);
  methods[10].selector = @selector(onRequested);
  methods[11].selector = @selector(setDisposableWithIoReactivexDisposablesDisposable:);
  methods[12].selector = @selector(setCancellableWithIoReactivexFunctionsCancellable:);
  methods[13].selector = @selector(requested);
  methods[14].selector = @selector(serialize);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID", "J", .constantValue.asLong = IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_serialVersionUID, 0x1a, -1, -1, -1, -1 },
    { "actual_", "LOrgReactivestreamsSubscriber;", .constantValue.asLong = 0, 0x10, -1, -1, 13, -1 },
    { "serial_", "LIoReactivexInternalDisposablesSequentialDisposable;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOrgReactivestreamsSubscriber;", "(Lorg/reactivestreams/Subscriber<-TT;>;)V", "onError", "LJavaLangThrowable;", "tryOnError", "error", "request", "J", "setDisposable", "LIoReactivexDisposablesDisposable;", "setCancellable", "LIoReactivexFunctionsCancellable;", "()Lio/reactivex/FlowableEmitter<TT;>;", "Lorg/reactivestreams/Subscriber<-TT;>;", "LIoReactivexInternalOperatorsFlowableFlowableCreate;", "<T:Ljava/lang/Object;>Ljava/util/concurrent/atomic/AtomicLong;Lio/reactivex/FlowableEmitter<TT;>;Lorg/reactivestreams/Subscription;" };
  static const J2ObjcClassInfo _IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter = { "BaseEmitter", "io.reactivex.internal.operators.flowable", ptrTable, methods, fields, 7, 0x408, 15, 3, 14, -1, -1, 15, -1 };
  return &_IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter;
}

@end

void IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_initWithOrgReactivestreamsSubscriber_(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *self, id<OrgReactivestreamsSubscriber> actual) {
  JavaUtilConcurrentAtomicAtomicLong_init(self);
  JreStrongAssign(&self->actual_, actual);
  JreStrongAssignAndConsume(&self->serial_, new_IoReactivexInternalDisposablesSequentialDisposable_init());
}

void IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_onErrorWithJavaLangThrowable_(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *self, JavaLangThrowable *e) {
  if (![self tryOnErrorWithJavaLangThrowable:e]) {
    IoReactivexPluginsRxJavaPlugins_onErrorWithJavaLangThrowable_(e);
  }
}

jboolean IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *self) {
  return [((IoReactivexInternalDisposablesSequentialDisposable *) nil_chk(self->serial_)) isDisposed];
}

void IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_setDisposableWithIoReactivexDisposablesDisposable_(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *self, id<IoReactivexDisposablesDisposable> s) {
  [((IoReactivexInternalDisposablesSequentialDisposable *) nil_chk(self->serial_)) updateWithIoReactivexDisposablesDisposable:s];
}

void IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_setCancellableWithIoReactivexFunctionsCancellable_(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *self, id<IoReactivexFunctionsCancellable> c) {
  IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_setDisposableWithIoReactivexDisposablesDisposable_(self, create_IoReactivexInternalDisposablesCancellableDisposable_initWithIoReactivexFunctionsCancellable_(c));
}

jlong IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_requested(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter *self) {
  return [self get];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter)

@implementation IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter

- (instancetype)initWithOrgReactivestreamsSubscriber:(id<OrgReactivestreamsSubscriber>)actual {
  IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter_initWithOrgReactivestreamsSubscriber_(self, actual);
  return self;
}

- (void)onNextWithId:(id)t {
  if (IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(self)) {
    return;
  }
  if (t != nil) {
    [((id<OrgReactivestreamsSubscriber>) nil_chk(actual_)) onNextWithId:t];
  }
  else {
    IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_onErrorWithJavaLangThrowable_(self, create_JavaLangNullPointerException_initWithNSString_(@"onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
    return;
  }
  for (; ; ) {
    jlong r = [self get];
    if (r == 0LL || [self compareAndSetWithLong:r withLong:r - 1]) {
      return;
    }
  }
}

- (jboolean)isEqual:(id)obj {
  return self == obj;
}

- (NSUInteger)hash {
  return (NSUInteger)self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, 1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, 4, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOrgReactivestreamsSubscriber:);
  methods[1].selector = @selector(onNextWithId:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID", "J", .constantValue.asLong = IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter_serialVersionUID, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOrgReactivestreamsSubscriber;", "(Lorg/reactivestreams/Subscriber<-TT;>;)V", "onNext", "LNSObject;", "(TT;)V", "LIoReactivexInternalOperatorsFlowableFlowableCreate;", "<T:Ljava/lang/Object;>Lio/reactivex/internal/operators/flowable/FlowableCreate$BaseEmitter<TT;>;" };
  static const J2ObjcClassInfo _IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter = { "MissingEmitter", "io.reactivex.internal.operators.flowable", ptrTable, methods, fields, 7, 0x18, 2, 1, 5, -1, -1, 6, -1 };
  return &_IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter;
}

@end

void IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter_initWithOrgReactivestreamsSubscriber_(IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter *self, id<OrgReactivestreamsSubscriber> actual) {
  IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_initWithOrgReactivestreamsSubscriber_(self, actual);
}

IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter *new_IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter_initWithOrgReactivestreamsSubscriber_(id<OrgReactivestreamsSubscriber> actual) {
  J2OBJC_NEW_IMPL(IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter, initWithOrgReactivestreamsSubscriber_, actual)
}

IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter *create_IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter_initWithOrgReactivestreamsSubscriber_(id<OrgReactivestreamsSubscriber> actual) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter, initWithOrgReactivestreamsSubscriber_, actual)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalOperatorsFlowableFlowableCreate_MissingEmitter)

@implementation IoReactivexInternalOperatorsFlowableFlowableCreate_NoOverflowBaseAsyncEmitter

- (instancetype)initWithOrgReactivestreamsSubscriber:(id<OrgReactivestreamsSubscriber>)actual {
  IoReactivexInternalOperatorsFlowableFlowableCreate_NoOverflowBaseAsyncEmitter_initWithOrgReactivestreamsSubscriber_(self, actual);
  return self;
}

- (void)onNextWithId:(id)t {
  if (IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(self)) {
    return;
  }
  if (t == nil) {
    IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_onErrorWithJavaLangThrowable_(self, create_JavaLangNullPointerException_initWithNSString_(@"onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
    return;
  }
  if ([self get] != 0) {
    [((id<OrgReactivestreamsSubscriber>) nil_chk(actual_)) onNextWithId:t];
    IoReactivexInternalUtilBackpressureHelper_producedWithJavaUtilConcurrentAtomicAtomicLong_withLong_(self, 1);
  }
  else {
    [self onOverflow];
  }
}

- (void)onOverflow {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (jboolean)isEqual:(id)obj {
  return self == obj;
}

- (NSUInteger)hash {
  return (NSUInteger)self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, 1, -1, -1 },
    { NULL, "V", 0x11, 2, 3, -1, 4, -1, -1 },
    { NULL, "V", 0x400, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOrgReactivestreamsSubscriber:);
  methods[1].selector = @selector(onNextWithId:);
  methods[2].selector = @selector(onOverflow);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID", "J", .constantValue.asLong = IoReactivexInternalOperatorsFlowableFlowableCreate_NoOverflowBaseAsyncEmitter_serialVersionUID, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOrgReactivestreamsSubscriber;", "(Lorg/reactivestreams/Subscriber<-TT;>;)V", "onNext", "LNSObject;", "(TT;)V", "LIoReactivexInternalOperatorsFlowableFlowableCreate;", "<T:Ljava/lang/Object;>Lio/reactivex/internal/operators/flowable/FlowableCreate$BaseEmitter<TT;>;" };
  static const J2ObjcClassInfo _IoReactivexInternalOperatorsFlowableFlowableCreate_NoOverflowBaseAsyncEmitter = { "NoOverflowBaseAsyncEmitter", "io.reactivex.internal.operators.flowable", ptrTable, methods, fields, 7, 0x408, 3, 1, 5, -1, -1, 6, -1 };
  return &_IoReactivexInternalOperatorsFlowableFlowableCreate_NoOverflowBaseAsyncEmitter;
}

@end

void IoReactivexInternalOperatorsFlowableFlowableCreate_NoOverflowBaseAsyncEmitter_initWithOrgReactivestreamsSubscriber_(IoReactivexInternalOperatorsFlowableFlowableCreate_NoOverflowBaseAsyncEmitter *self, id<OrgReactivestreamsSubscriber> actual) {
  IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_initWithOrgReactivestreamsSubscriber_(self, actual);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalOperatorsFlowableFlowableCreate_NoOverflowBaseAsyncEmitter)

@implementation IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter

- (instancetype)initWithOrgReactivestreamsSubscriber:(id<OrgReactivestreamsSubscriber>)actual {
  IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter_initWithOrgReactivestreamsSubscriber_(self, actual);
  return self;
}

- (void)onOverflow {
}

- (jboolean)isEqual:(id)obj {
  return self == obj;
}

- (NSUInteger)hash {
  return (NSUInteger)self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, 1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOrgReactivestreamsSubscriber:);
  methods[1].selector = @selector(onOverflow);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID", "J", .constantValue.asLong = IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter_serialVersionUID, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOrgReactivestreamsSubscriber;", "(Lorg/reactivestreams/Subscriber<-TT;>;)V", "LIoReactivexInternalOperatorsFlowableFlowableCreate;", "<T:Ljava/lang/Object;>Lio/reactivex/internal/operators/flowable/FlowableCreate$NoOverflowBaseAsyncEmitter<TT;>;" };
  static const J2ObjcClassInfo _IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter = { "DropAsyncEmitter", "io.reactivex.internal.operators.flowable", ptrTable, methods, fields, 7, 0x18, 2, 1, 2, -1, -1, 3, -1 };
  return &_IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter;
}

@end

void IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter_initWithOrgReactivestreamsSubscriber_(IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter *self, id<OrgReactivestreamsSubscriber> actual) {
  IoReactivexInternalOperatorsFlowableFlowableCreate_NoOverflowBaseAsyncEmitter_initWithOrgReactivestreamsSubscriber_(self, actual);
}

IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter *new_IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter_initWithOrgReactivestreamsSubscriber_(id<OrgReactivestreamsSubscriber> actual) {
  J2OBJC_NEW_IMPL(IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter, initWithOrgReactivestreamsSubscriber_, actual)
}

IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter *create_IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter_initWithOrgReactivestreamsSubscriber_(id<OrgReactivestreamsSubscriber> actual) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter, initWithOrgReactivestreamsSubscriber_, actual)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalOperatorsFlowableFlowableCreate_DropAsyncEmitter)

@implementation IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter

- (instancetype)initWithOrgReactivestreamsSubscriber:(id<OrgReactivestreamsSubscriber>)actual {
  IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter_initWithOrgReactivestreamsSubscriber_(self, actual);
  return self;
}

- (void)onOverflow {
  IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_onErrorWithJavaLangThrowable_(self, create_IoReactivexExceptionsMissingBackpressureException_initWithNSString_(@"create: could not emit value due to lack of requests"));
}

- (jboolean)isEqual:(id)obj {
  return self == obj;
}

- (NSUInteger)hash {
  return (NSUInteger)self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, 1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOrgReactivestreamsSubscriber:);
  methods[1].selector = @selector(onOverflow);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID", "J", .constantValue.asLong = IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter_serialVersionUID, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOrgReactivestreamsSubscriber;", "(Lorg/reactivestreams/Subscriber<-TT;>;)V", "LIoReactivexInternalOperatorsFlowableFlowableCreate;", "<T:Ljava/lang/Object;>Lio/reactivex/internal/operators/flowable/FlowableCreate$NoOverflowBaseAsyncEmitter<TT;>;" };
  static const J2ObjcClassInfo _IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter = { "ErrorAsyncEmitter", "io.reactivex.internal.operators.flowable", ptrTable, methods, fields, 7, 0x18, 2, 1, 2, -1, -1, 3, -1 };
  return &_IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter;
}

@end

void IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter_initWithOrgReactivestreamsSubscriber_(IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter *self, id<OrgReactivestreamsSubscriber> actual) {
  IoReactivexInternalOperatorsFlowableFlowableCreate_NoOverflowBaseAsyncEmitter_initWithOrgReactivestreamsSubscriber_(self, actual);
}

IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter *new_IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter_initWithOrgReactivestreamsSubscriber_(id<OrgReactivestreamsSubscriber> actual) {
  J2OBJC_NEW_IMPL(IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter, initWithOrgReactivestreamsSubscriber_, actual)
}

IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter *create_IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter_initWithOrgReactivestreamsSubscriber_(id<OrgReactivestreamsSubscriber> actual) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter, initWithOrgReactivestreamsSubscriber_, actual)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalOperatorsFlowableFlowableCreate_ErrorAsyncEmitter)

@implementation IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter

- (instancetype)initWithOrgReactivestreamsSubscriber:(id<OrgReactivestreamsSubscriber>)actual
                                             withInt:(jint)capacityHint {
  IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter_initWithOrgReactivestreamsSubscriber_withInt_(self, actual, capacityHint);
  return self;
}

- (void)onNextWithId:(id)t {
  if (JreLoadVolatileBoolean(&done_) || IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(self)) {
    return;
  }
  if (t == nil) {
    IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_onErrorWithJavaLangThrowable_(self, create_JavaLangNullPointerException_initWithNSString_(@"onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
    return;
  }
  [((IoReactivexInternalQueueSpscLinkedArrayQueue *) nil_chk(queue_)) offerWithId:t];
  [self drain];
}

- (jboolean)tryOnErrorWithJavaLangThrowable:(JavaLangThrowable *)e {
  if (JreLoadVolatileBoolean(&done_) || IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(self)) {
    return false;
  }
  if (e == nil) {
    e = create_JavaLangNullPointerException_initWithNSString_(@"onError called with null. Null values are generally not allowed in 2.x operators and sources.");
  }
  JreStrongAssign(&error_, e);
  JreAssignVolatileBoolean(&done_, true);
  [self drain];
  return true;
}

- (void)onComplete {
  JreAssignVolatileBoolean(&done_, true);
  [self drain];
}

- (void)onRequested {
  [self drain];
}

- (void)onUnsubscribed {
  if ([((JavaUtilConcurrentAtomicAtomicInteger *) nil_chk(wip_)) getAndIncrement] == 0) {
    [((IoReactivexInternalQueueSpscLinkedArrayQueue *) nil_chk(queue_)) clear];
  }
}

- (void)drain {
  if ([((JavaUtilConcurrentAtomicAtomicInteger *) nil_chk(wip_)) getAndIncrement] != 0) {
    return;
  }
  jint missed = 1;
  id<OrgReactivestreamsSubscriber> a = actual_;
  IoReactivexInternalQueueSpscLinkedArrayQueue *q = queue_;
  for (; ; ) {
    jlong r = [self get];
    jlong e = 0LL;
    while (e != r) {
      if (IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(self)) {
        [((IoReactivexInternalQueueSpscLinkedArrayQueue *) nil_chk(q)) clear];
        return;
      }
      jboolean d = JreLoadVolatileBoolean(&done_);
      id o = [((IoReactivexInternalQueueSpscLinkedArrayQueue *) nil_chk(q)) poll];
      jboolean empty = o == nil;
      if (d && empty) {
        JavaLangThrowable *ex = error_;
        if (ex != nil) {
          [self errorWithJavaLangThrowable:ex];
        }
        else {
          [self complete];
        }
        return;
      }
      if (empty) {
        break;
      }
      [((id<OrgReactivestreamsSubscriber>) nil_chk(a)) onNextWithId:o];
      e++;
    }
    if (e == r) {
      if (IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(self)) {
        [((IoReactivexInternalQueueSpscLinkedArrayQueue *) nil_chk(q)) clear];
        return;
      }
      jboolean d = JreLoadVolatileBoolean(&done_);
      jboolean empty = [((IoReactivexInternalQueueSpscLinkedArrayQueue *) nil_chk(q)) isEmpty];
      if (d && empty) {
        JavaLangThrowable *ex = error_;
        if (ex != nil) {
          [self errorWithJavaLangThrowable:ex];
        }
        else {
          [self complete];
        }
        return;
      }
    }
    if (e != 0) {
      IoReactivexInternalUtilBackpressureHelper_producedWithJavaUtilConcurrentAtomicAtomicLong_withLong_(self, e);
    }
    missed = [wip_ addAndGetWithInt:-missed];
    if (missed == 0) {
      break;
    }
  }
}

- (jboolean)isEqual:(id)obj {
  return self == obj;
}

- (NSUInteger)hash {
  return (NSUInteger)self;
}

- (void)dealloc {
  RELEASE_(queue_);
  RELEASE_(error_);
  RELEASE_(wip_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, 1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, 4, -1, -1 },
    { NULL, "Z", 0x1, 5, 6, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOrgReactivestreamsSubscriber:withInt:);
  methods[1].selector = @selector(onNextWithId:);
  methods[2].selector = @selector(tryOnErrorWithJavaLangThrowable:);
  methods[3].selector = @selector(onComplete);
  methods[4].selector = @selector(onRequested);
  methods[5].selector = @selector(onUnsubscribed);
  methods[6].selector = @selector(drain);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID", "J", .constantValue.asLong = IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter_serialVersionUID, 0x1a, -1, -1, -1, -1 },
    { "queue_", "LIoReactivexInternalQueueSpscLinkedArrayQueue;", .constantValue.asLong = 0, 0x10, -1, -1, 7, -1 },
    { "error_", "LJavaLangThrowable;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "done_", "Z", .constantValue.asLong = 0, 0x40, -1, -1, -1, -1 },
    { "wip_", "LJavaUtilConcurrentAtomicAtomicInteger;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOrgReactivestreamsSubscriber;I", "(Lorg/reactivestreams/Subscriber<-TT;>;I)V", "onNext", "LNSObject;", "(TT;)V", "tryOnError", "LJavaLangThrowable;", "Lio/reactivex/internal/queue/SpscLinkedArrayQueue<TT;>;", "LIoReactivexInternalOperatorsFlowableFlowableCreate;", "<T:Ljava/lang/Object;>Lio/reactivex/internal/operators/flowable/FlowableCreate$BaseEmitter<TT;>;" };
  static const J2ObjcClassInfo _IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter = { "BufferAsyncEmitter", "io.reactivex.internal.operators.flowable", ptrTable, methods, fields, 7, 0x18, 7, 5, 8, -1, -1, 9, -1 };
  return &_IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter;
}

@end

void IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter_initWithOrgReactivestreamsSubscriber_withInt_(IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter *self, id<OrgReactivestreamsSubscriber> actual, jint capacityHint) {
  IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_initWithOrgReactivestreamsSubscriber_(self, actual);
  JreStrongAssignAndConsume(&self->queue_, new_IoReactivexInternalQueueSpscLinkedArrayQueue_initWithInt_(capacityHint));
  JreStrongAssignAndConsume(&self->wip_, new_JavaUtilConcurrentAtomicAtomicInteger_init());
}

IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter *new_IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter_initWithOrgReactivestreamsSubscriber_withInt_(id<OrgReactivestreamsSubscriber> actual, jint capacityHint) {
  J2OBJC_NEW_IMPL(IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter, initWithOrgReactivestreamsSubscriber_withInt_, actual, capacityHint)
}

IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter *create_IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter_initWithOrgReactivestreamsSubscriber_withInt_(id<OrgReactivestreamsSubscriber> actual, jint capacityHint) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter, initWithOrgReactivestreamsSubscriber_withInt_, actual, capacityHint)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalOperatorsFlowableFlowableCreate_BufferAsyncEmitter)

@implementation IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter

- (instancetype)initWithOrgReactivestreamsSubscriber:(id<OrgReactivestreamsSubscriber>)actual {
  IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter_initWithOrgReactivestreamsSubscriber_(self, actual);
  return self;
}

- (void)onNextWithId:(id)t {
  if (JreLoadVolatileBoolean(&done_) || IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(self)) {
    return;
  }
  if (t == nil) {
    IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_onErrorWithJavaLangThrowable_(self, create_JavaLangNullPointerException_initWithNSString_(@"onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
    return;
  }
  [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(queue_)) setWithId:t];
  [self drain];
}

- (jboolean)tryOnErrorWithJavaLangThrowable:(JavaLangThrowable *)e {
  if (JreLoadVolatileBoolean(&done_) || IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(self)) {
    return false;
  }
  if (e == nil) {
    IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_onErrorWithJavaLangThrowable_(self, create_JavaLangNullPointerException_initWithNSString_(@"onError called with null. Null values are generally not allowed in 2.x operators and sources."));
  }
  JreStrongAssign(&error_, e);
  JreAssignVolatileBoolean(&done_, true);
  [self drain];
  return true;
}

- (void)onComplete {
  JreAssignVolatileBoolean(&done_, true);
  [self drain];
}

- (void)onRequested {
  [self drain];
}

- (void)onUnsubscribed {
  if ([((JavaUtilConcurrentAtomicAtomicInteger *) nil_chk(wip_)) getAndIncrement] == 0) {
    [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(queue_)) lazySetWithId:nil];
  }
}

- (void)drain {
  if ([((JavaUtilConcurrentAtomicAtomicInteger *) nil_chk(wip_)) getAndIncrement] != 0) {
    return;
  }
  jint missed = 1;
  id<OrgReactivestreamsSubscriber> a = actual_;
  JavaUtilConcurrentAtomicAtomicReference *q = queue_;
  for (; ; ) {
    jlong r = [self get];
    jlong e = 0LL;
    while (e != r) {
      if (IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(self)) {
        [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(q)) lazySetWithId:nil];
        return;
      }
      jboolean d = JreLoadVolatileBoolean(&done_);
      id o = [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(q)) getAndSetWithId:nil];
      jboolean empty = o == nil;
      if (d && empty) {
        JavaLangThrowable *ex = error_;
        if (ex != nil) {
          [self errorWithJavaLangThrowable:ex];
        }
        else {
          [self complete];
        }
        return;
      }
      if (empty) {
        break;
      }
      [((id<OrgReactivestreamsSubscriber>) nil_chk(a)) onNextWithId:o];
      e++;
    }
    if (e == r) {
      if (IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_isCancelled(self)) {
        [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(q)) lazySetWithId:nil];
        return;
      }
      jboolean d = JreLoadVolatileBoolean(&done_);
      jboolean empty = [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(q)) get] == nil;
      if (d && empty) {
        JavaLangThrowable *ex = error_;
        if (ex != nil) {
          [self errorWithJavaLangThrowable:ex];
        }
        else {
          [self complete];
        }
        return;
      }
    }
    if (e != 0) {
      IoReactivexInternalUtilBackpressureHelper_producedWithJavaUtilConcurrentAtomicAtomicLong_withLong_(self, e);
    }
    missed = [wip_ addAndGetWithInt:-missed];
    if (missed == 0) {
      break;
    }
  }
}

- (jboolean)isEqual:(id)obj {
  return self == obj;
}

- (NSUInteger)hash {
  return (NSUInteger)self;
}

- (void)dealloc {
  RELEASE_(queue_);
  RELEASE_(error_);
  RELEASE_(wip_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, 1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, 4, -1, -1 },
    { NULL, "Z", 0x1, 5, 6, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOrgReactivestreamsSubscriber:);
  methods[1].selector = @selector(onNextWithId:);
  methods[2].selector = @selector(tryOnErrorWithJavaLangThrowable:);
  methods[3].selector = @selector(onComplete);
  methods[4].selector = @selector(onRequested);
  methods[5].selector = @selector(onUnsubscribed);
  methods[6].selector = @selector(drain);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID", "J", .constantValue.asLong = IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter_serialVersionUID, 0x1a, -1, -1, -1, -1 },
    { "queue_", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x10, -1, -1, 7, -1 },
    { "error_", "LJavaLangThrowable;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "done_", "Z", .constantValue.asLong = 0, 0x40, -1, -1, -1, -1 },
    { "wip_", "LJavaUtilConcurrentAtomicAtomicInteger;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOrgReactivestreamsSubscriber;", "(Lorg/reactivestreams/Subscriber<-TT;>;)V", "onNext", "LNSObject;", "(TT;)V", "tryOnError", "LJavaLangThrowable;", "Ljava/util/concurrent/atomic/AtomicReference<TT;>;", "LIoReactivexInternalOperatorsFlowableFlowableCreate;", "<T:Ljava/lang/Object;>Lio/reactivex/internal/operators/flowable/FlowableCreate$BaseEmitter<TT;>;" };
  static const J2ObjcClassInfo _IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter = { "LatestAsyncEmitter", "io.reactivex.internal.operators.flowable", ptrTable, methods, fields, 7, 0x18, 7, 5, 8, -1, -1, 9, -1 };
  return &_IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter;
}

@end

void IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter_initWithOrgReactivestreamsSubscriber_(IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter *self, id<OrgReactivestreamsSubscriber> actual) {
  IoReactivexInternalOperatorsFlowableFlowableCreate_BaseEmitter_initWithOrgReactivestreamsSubscriber_(self, actual);
  JreStrongAssignAndConsume(&self->queue_, new_JavaUtilConcurrentAtomicAtomicReference_init());
  JreStrongAssignAndConsume(&self->wip_, new_JavaUtilConcurrentAtomicAtomicInteger_init());
}

IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter *new_IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter_initWithOrgReactivestreamsSubscriber_(id<OrgReactivestreamsSubscriber> actual) {
  J2OBJC_NEW_IMPL(IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter, initWithOrgReactivestreamsSubscriber_, actual)
}

IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter *create_IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter_initWithOrgReactivestreamsSubscriber_(id<OrgReactivestreamsSubscriber> actual) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter, initWithOrgReactivestreamsSubscriber_, actual)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalOperatorsFlowableFlowableCreate_LatestAsyncEmitter)
