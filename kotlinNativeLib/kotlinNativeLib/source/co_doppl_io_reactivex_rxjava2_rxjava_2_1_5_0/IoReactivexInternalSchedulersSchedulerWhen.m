//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "IoReactivexCompletable.h"
#include "IoReactivexCompletableObserver.h"
#include "IoReactivexDisposablesDisposable.h"
#include "IoReactivexDisposablesDisposables.h"
#include "IoReactivexExceptionsExceptions.h"
#include "IoReactivexFlowable.h"
#include "IoReactivexFunctionsFunction.h"
#include "IoReactivexInternalSchedulersSchedulerWhen.h"
#include "IoReactivexProcessorsFlowableProcessor.h"
#include "IoReactivexProcessorsUnicastProcessor.h"
#include "IoReactivexScheduler.h"
#include "J2ObjC_source.h"
#include "java/lang/Runnable.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/Throwable.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/util/concurrent/atomic/AtomicBoolean.h"
#include "java/util/concurrent/atomic/AtomicReference.h"

#pragma clang diagnostic ignored "-Wincomplete-implementation"

@interface IoReactivexInternalSchedulersSchedulerWhen () {
 @public
  IoReactivexScheduler *actualScheduler_;
  IoReactivexProcessorsFlowableProcessor *workerProcessor_;
  id<IoReactivexDisposablesDisposable> disposable_;
}

@end

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen, actualScheduler_, IoReactivexScheduler *)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen, workerProcessor_, IoReactivexProcessorsFlowableProcessor *)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen, disposable_, id<IoReactivexDisposablesDisposable>)

@interface IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction () {
 @public
  id<JavaLangRunnable> action_;
}

@end

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction, action_, id<JavaLangRunnable>)

@interface IoReactivexInternalSchedulersSchedulerWhen_DelayedAction () {
 @public
  id<JavaLangRunnable> action_;
  jlong delayTime_;
  JavaUtilConcurrentTimeUnit *unit_;
}

@end

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction, action_, id<JavaLangRunnable>)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction, unit_, JavaUtilConcurrentTimeUnit *)

@interface IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable () {
 @public
  IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction *this$0_;
}

@end

@interface IoReactivexInternalSchedulersSchedulerWhen_QueueWorker () {
 @public
  JavaUtilConcurrentAtomicAtomicBoolean *unsubscribed_;
  IoReactivexProcessorsFlowableProcessor *actionProcessor_;
  IoReactivexScheduler_Worker *actualWorker_;
}

@end

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_QueueWorker, unsubscribed_, JavaUtilConcurrentAtomicAtomicBoolean *)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_QueueWorker, actionProcessor_, IoReactivexProcessorsFlowableProcessor *)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_QueueWorker, actualWorker_, IoReactivexScheduler_Worker *)

J2OBJC_INITIALIZED_DEFN(IoReactivexInternalSchedulersSchedulerWhen)

id<IoReactivexDisposablesDisposable> IoReactivexInternalSchedulersSchedulerWhen_SUBSCRIBED;
id<IoReactivexDisposablesDisposable> IoReactivexInternalSchedulersSchedulerWhen_DISPOSED;

@implementation IoReactivexInternalSchedulersSchedulerWhen

+ (id<IoReactivexDisposablesDisposable>)SUBSCRIBED {
  return IoReactivexInternalSchedulersSchedulerWhen_SUBSCRIBED;
}

+ (id<IoReactivexDisposablesDisposable>)DISPOSED {
  return IoReactivexInternalSchedulersSchedulerWhen_DISPOSED;
}

- (instancetype)initWithIoReactivexFunctionsFunction:(id<IoReactivexFunctionsFunction>)combine
                            withIoReactivexScheduler:(IoReactivexScheduler *)actualScheduler {
  IoReactivexInternalSchedulersSchedulerWhen_initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_(self, combine, actualScheduler);
  return self;
}

- (void)dispose {
  [((id<IoReactivexDisposablesDisposable>) nil_chk(disposable_)) dispose];
}

- (jboolean)isDisposed {
  return [((id<IoReactivexDisposablesDisposable>) nil_chk(disposable_)) isDisposed];
}

- (IoReactivexScheduler_Worker * __nonnull)createWorker {
  IoReactivexScheduler_Worker *actualWorker = [((IoReactivexScheduler *) nil_chk(actualScheduler_)) createWorker];
  IoReactivexProcessorsFlowableProcessor *actionProcessor = [((IoReactivexProcessorsUnicastProcessor *) nil_chk(IoReactivexProcessorsUnicastProcessor_create())) toSerialized];
  IoReactivexFlowable *actions = [((IoReactivexProcessorsFlowableProcessor *) nil_chk(actionProcessor)) mapWithIoReactivexFunctionsFunction:create_IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_initWithIoReactivexScheduler_Worker_(actualWorker)];
  IoReactivexScheduler_Worker *worker = create_IoReactivexInternalSchedulersSchedulerWhen_QueueWorker_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(actionProcessor, actualWorker);
  [((IoReactivexProcessorsFlowableProcessor *) nil_chk(workerProcessor_)) onNextWithId:actions];
  return worker;
}

- (void)dealloc {
  RELEASE_(actualScheduler_);
  RELEASE_(workerProcessor_);
  RELEASE_(disposable_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, 1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler_Worker;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithIoReactivexFunctionsFunction:withIoReactivexScheduler:);
  methods[1].selector = @selector(dispose);
  methods[2].selector = @selector(isDisposed);
  methods[3].selector = @selector(createWorker);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "actualScheduler_", "LIoReactivexScheduler;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "workerProcessor_", "LIoReactivexProcessorsFlowableProcessor;", .constantValue.asLong = 0, 0x12, -1, -1, 2, -1 },
    { "disposable_", "LIoReactivexDisposablesDisposable;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "SUBSCRIBED", "LIoReactivexDisposablesDisposable;", .constantValue.asLong = 0, 0x18, -1, 3, -1, -1 },
    { "DISPOSED", "LIoReactivexDisposablesDisposable;", .constantValue.asLong = 0, 0x18, -1, 4, -1, -1 },
  };
  static const void *ptrTable[] = { "LIoReactivexFunctionsFunction;LIoReactivexScheduler;", "(Lio/reactivex/functions/Function<Lio/reactivex/Flowable<Lio/reactivex/Flowable<Lio/reactivex/Completable;>;>;Lio/reactivex/Completable;>;Lio/reactivex/Scheduler;)V", "Lio/reactivex/processors/FlowableProcessor<Lio/reactivex/Flowable<Lio/reactivex/Completable;>;>;", &IoReactivexInternalSchedulersSchedulerWhen_SUBSCRIBED, &IoReactivexInternalSchedulersSchedulerWhen_DISPOSED, "LIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction;LIoReactivexInternalSchedulersSchedulerWhen_ImmediateAction;LIoReactivexInternalSchedulersSchedulerWhen_DelayedAction;LIoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction;LIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction;LIoReactivexInternalSchedulersSchedulerWhen_QueueWorker;LIoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen = { "SchedulerWhen", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x1, 4, 5, -1, 5, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen;
}

+ (void)initialize {
  if (self == [IoReactivexInternalSchedulersSchedulerWhen class]) {
    JreStrongAssignAndConsume(&IoReactivexInternalSchedulersSchedulerWhen_SUBSCRIBED, new_IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable_init());
    JreStrongAssign(&IoReactivexInternalSchedulersSchedulerWhen_DISPOSED, IoReactivexDisposablesDisposables_disposed());
    J2OBJC_SET_INITIALIZED(IoReactivexInternalSchedulersSchedulerWhen)
  }
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_(IoReactivexInternalSchedulersSchedulerWhen *self, id<IoReactivexFunctionsFunction> combine, IoReactivexScheduler *actualScheduler) {
  IoReactivexScheduler_init(self);
  JreStrongAssign(&self->actualScheduler_, actualScheduler);
  JreStrongAssign(&self->workerProcessor_, [((IoReactivexProcessorsUnicastProcessor *) nil_chk(IoReactivexProcessorsUnicastProcessor_create())) toSerialized]);
  @try {
    JreStrongAssign(&self->disposable_, [((IoReactivexCompletable *) nil_chk([((id<IoReactivexFunctionsFunction>) nil_chk(combine)) applyWithId:self->workerProcessor_])) subscribe]);
  }
  @catch (JavaLangThrowable *e) {
    IoReactivexExceptionsExceptions_propagateWithJavaLangThrowable_(e);
  }
}

IoReactivexInternalSchedulersSchedulerWhen *new_IoReactivexInternalSchedulersSchedulerWhen_initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_(id<IoReactivexFunctionsFunction> combine, IoReactivexScheduler *actualScheduler) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen, initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_, combine, actualScheduler)
}

IoReactivexInternalSchedulersSchedulerWhen *create_IoReactivexInternalSchedulersSchedulerWhen_initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_(id<IoReactivexFunctionsFunction> combine, IoReactivexScheduler *actualScheduler) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen, initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_, combine, actualScheduler)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersSchedulerWhen)

@implementation IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)callWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
         withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable {
  id<IoReactivexDisposablesDisposable> oldState = [self get];
  if (oldState == JreLoadStatic(IoReactivexInternalSchedulersSchedulerWhen, DISPOSED)) {
    return;
  }
  if (oldState != JreLoadStatic(IoReactivexInternalSchedulersSchedulerWhen, SUBSCRIBED)) {
    return;
  }
  id<IoReactivexDisposablesDisposable> newState = [self callActualWithIoReactivexScheduler_Worker:actualWorker withIoReactivexCompletableObserver:actionCompletable];
  if (![self compareAndSetWithId:JreLoadStatic(IoReactivexInternalSchedulersSchedulerWhen, SUBSCRIBED) withId:newState]) {
    [((id<IoReactivexDisposablesDisposable>) nil_chk(newState)) dispose];
  }
}

- (id<IoReactivexDisposablesDisposable>)callActualWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
                                               withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (jboolean)isDisposed {
  return [((id<IoReactivexDisposablesDisposable>) nil_chk([self get])) isDisposed];
}

- (void)dispose {
  id<IoReactivexDisposablesDisposable> oldState;
  id<IoReactivexDisposablesDisposable> newState = JreLoadStatic(IoReactivexInternalSchedulersSchedulerWhen, DISPOSED);
  do {
    oldState = [self get];
    if (oldState == JreLoadStatic(IoReactivexInternalSchedulersSchedulerWhen, DISPOSED)) {
      return;
    }
  }
  while (![self compareAndSetWithId:oldState withId:newState]);
  if (oldState != JreLoadStatic(IoReactivexInternalSchedulersSchedulerWhen, SUBSCRIBED)) {
    [((id<IoReactivexDisposablesDisposable>) nil_chk(oldState)) dispose];
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 0, 1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x404, 2, 1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(callWithIoReactivexScheduler_Worker:withIoReactivexCompletableObserver:);
  methods[2].selector = @selector(callActualWithIoReactivexScheduler_Worker:withIoReactivexCompletableObserver:);
  methods[3].selector = @selector(isDisposed);
  methods[4].selector = @selector(dispose);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "call", "LIoReactivexScheduler_Worker;LIoReactivexCompletableObserver;", "callActual", "LIoReactivexInternalSchedulersSchedulerWhen;", "Ljava/util/concurrent/atomic/AtomicReference<Lio/reactivex/disposables/Disposable;>;Lio/reactivex/disposables/Disposable;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction = { "ScheduledAction", "io.reactivex.internal.schedulers", ptrTable, methods, NULL, 7, 0x408, 5, 0, 3, -1, -1, 4, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_init(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *self) {
  JavaUtilConcurrentAtomicAtomicReference_initWithId_(self, JreLoadStatic(IoReactivexInternalSchedulersSchedulerWhen, SUBSCRIBED));
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction)

@implementation IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)action {
  IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(self, action);
  return self;
}

- (id<IoReactivexDisposablesDisposable>)callActualWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
                                               withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable {
  return [((IoReactivexScheduler_Worker *) nil_chk(actualWorker)) scheduleWithJavaLangRunnable:create_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(action_, actionCompletable)];
}

- (void)dealloc {
  RELEASE_(action_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x4, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaLangRunnable:);
  methods[1].selector = @selector(callActualWithIoReactivexScheduler_Worker:withIoReactivexCompletableObserver:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "action_", "LJavaLangRunnable;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaLangRunnable;", "callActual", "LIoReactivexScheduler_Worker;LIoReactivexCompletableObserver;", "LIoReactivexInternalSchedulersSchedulerWhen;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction = { "ImmediateAction", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x8, 2, 1, 3, -1, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction *self, id<JavaLangRunnable> action) {
  IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_init(self);
  JreStrongAssign(&self->action_, action);
}

IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction *new_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(id<JavaLangRunnable> action) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction, initWithJavaLangRunnable_, action)
}

IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction *create_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(id<JavaLangRunnable> action) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction, initWithJavaLangRunnable_, action)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction)

@implementation IoReactivexInternalSchedulersSchedulerWhen_DelayedAction

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)action
                                withLong:(jlong)delayTime
          withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(self, action, delayTime, unit);
  return self;
}

- (id<IoReactivexDisposablesDisposable>)callActualWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
                                               withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable {
  return [((IoReactivexScheduler_Worker *) nil_chk(actualWorker)) scheduleWithJavaLangRunnable:create_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(action_, actionCompletable) withLong:delayTime_ withJavaUtilConcurrentTimeUnit:unit_];
}

- (void)dealloc {
  RELEASE_(action_);
  RELEASE_(unit_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x4, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaLangRunnable:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[1].selector = @selector(callActualWithIoReactivexScheduler_Worker:withIoReactivexCompletableObserver:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "action_", "LJavaLangRunnable;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "delayTime_", "J", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "unit_", "LJavaUtilConcurrentTimeUnit;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaLangRunnable;JLJavaUtilConcurrentTimeUnit;", "callActual", "LIoReactivexScheduler_Worker;LIoReactivexCompletableObserver;", "LIoReactivexInternalSchedulersSchedulerWhen;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_DelayedAction = { "DelayedAction", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x8, 2, 3, 3, -1, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction *self, id<JavaLangRunnable> action, jlong delayTime, JavaUtilConcurrentTimeUnit *unit) {
  IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_init(self);
  JreStrongAssign(&self->action_, action);
  self->delayTime_ = delayTime;
  JreStrongAssign(&self->unit_, unit);
}

IoReactivexInternalSchedulersSchedulerWhen_DelayedAction *new_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(id<JavaLangRunnable> action, jlong delayTime, JavaUtilConcurrentTimeUnit *unit) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction, initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_, action, delayTime, unit)
}

IoReactivexInternalSchedulersSchedulerWhen_DelayedAction *create_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(id<JavaLangRunnable> action, jlong delayTime, JavaUtilConcurrentTimeUnit *unit) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction, initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_, action, delayTime, unit)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction)

@implementation IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)action
      withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable {
  IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(self, action, actionCompletable);
  return self;
}

- (void)run {
  @try {
    [((id<JavaLangRunnable>) nil_chk(action_)) run];
  }
  @finally {
    [((id<IoReactivexCompletableObserver>) nil_chk(actionCompletable_)) onComplete];
  }
}

- (void)dealloc {
  RELEASE_(actionCompletable_);
  RELEASE_(action_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaLangRunnable:withIoReactivexCompletableObserver:);
  methods[1].selector = @selector(run);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "actionCompletable_", "LIoReactivexCompletableObserver;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "action_", "LJavaLangRunnable;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaLangRunnable;LIoReactivexCompletableObserver;", "LIoReactivexInternalSchedulersSchedulerWhen;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction = { "OnCompletedAction", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x8, 2, 2, 1, -1, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction *self, id<JavaLangRunnable> action, id<IoReactivexCompletableObserver> actionCompletable) {
  NSObject_init(self);
  JreStrongAssign(&self->action_, action);
  JreStrongAssign(&self->actionCompletable_, actionCompletable);
}

IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction *new_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(id<JavaLangRunnable> action, id<IoReactivexCompletableObserver> actionCompletable) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction, initWithJavaLangRunnable_withIoReactivexCompletableObserver_, action, actionCompletable)
}

IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction *create_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(id<JavaLangRunnable> action, id<IoReactivexCompletableObserver> actionCompletable) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction, initWithJavaLangRunnable_withIoReactivexCompletableObserver_, action, actionCompletable)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction)

@implementation IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction

- (instancetype)initWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker {
  IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_initWithIoReactivexScheduler_Worker_(self, actualWorker);
  return self;
}

- (IoReactivexCompletable *)applyWithId:(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *)action {
  return create_IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable_initWithIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(self, action);
}

- (void)dealloc {
  RELEASE_(actualWorker_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "LIoReactivexCompletable;", 0x1, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithIoReactivexScheduler_Worker:);
  methods[1].selector = @selector(applyWithId:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "actualWorker_", "LIoReactivexScheduler_Worker;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LIoReactivexScheduler_Worker;", "apply", "LIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction;", "LIoReactivexInternalSchedulersSchedulerWhen;", "LIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable;", "Ljava/lang/Object;Lio/reactivex/functions/Function<Lio/reactivex/internal/schedulers/SchedulerWhen$ScheduledAction;Lio/reactivex/Completable;>;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction = { "CreateWorkerFunction", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x18, 2, 1, 3, 4, -1, 5, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_initWithIoReactivexScheduler_Worker_(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction *self, IoReactivexScheduler_Worker *actualWorker) {
  NSObject_init(self);
  JreStrongAssign(&self->actualWorker_, actualWorker);
}

IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction *new_IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_initWithIoReactivexScheduler_Worker_(IoReactivexScheduler_Worker *actualWorker) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction, initWithIoReactivexScheduler_Worker_, actualWorker)
}

IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction *create_IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_initWithIoReactivexScheduler_Worker_(IoReactivexScheduler_Worker *actualWorker) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction, initWithIoReactivexScheduler_Worker_, actualWorker)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction)

@implementation IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable

- (instancetype)initWithIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction:(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction *)outer$
                         withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction:(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *)action {
  IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable_initWithIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(self, outer$, action);
  return self;
}

- (void)subscribeActualWithIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable {
  [((id<IoReactivexCompletableObserver>) nil_chk(actionCompletable)) onSubscribeWithIoReactivexDisposablesDisposable:action_];
  [((IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *) nil_chk(action_)) callWithIoReactivexScheduler_Worker:this$0_->actualWorker_ withIoReactivexCompletableObserver:actionCompletable];
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(action_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction:withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction:);
  methods[1].selector = @selector(subscribeActualWithIoReactivexCompletableObserver:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "action_", "LIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction;", "subscribeActual", "LIoReactivexCompletableObserver;", "LIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable = { "WorkerCompletable", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x10, 2, 2, 3, -1, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable_initWithIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable *self, IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction *outer$, IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *action) {
  JreStrongAssign(&self->this$0_, outer$);
  IoReactivexCompletable_init(self);
  JreStrongAssign(&self->action_, action);
}

IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable *new_IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable_initWithIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction *outer$, IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *action) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable, initWithIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_, outer$, action)
}

IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable *create_IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable_initWithIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction *outer$, IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *action) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable, initWithIoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_, outer$, action)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersSchedulerWhen_CreateWorkerFunction_WorkerCompletable)

@implementation IoReactivexInternalSchedulersSchedulerWhen_QueueWorker

- (instancetype)initWithIoReactivexProcessorsFlowableProcessor:(IoReactivexProcessorsFlowableProcessor *)actionProcessor
                               withIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker {
  IoReactivexInternalSchedulersSchedulerWhen_QueueWorker_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(self, actionProcessor, actualWorker);
  return self;
}

- (void)dispose {
  if ([((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(unsubscribed_)) compareAndSetWithBoolean:false withBoolean:true]) {
    [((IoReactivexProcessorsFlowableProcessor *) nil_chk(actionProcessor_)) onComplete];
    [((IoReactivexScheduler_Worker *) nil_chk(actualWorker_)) dispose];
  }
}

- (jboolean)isDisposed {
  return [((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(unsubscribed_)) get];
}

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)action
                                                                      withLong:(jlong)delayTime
                                                withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit {
  IoReactivexInternalSchedulersSchedulerWhen_DelayedAction *delayedAction = create_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(action, delayTime, unit);
  [((IoReactivexProcessorsFlowableProcessor *) nil_chk(actionProcessor_)) onNextWithId:delayedAction];
  return delayedAction;
}

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)action {
  IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction *immediateAction = create_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(action);
  [((IoReactivexProcessorsFlowableProcessor *) nil_chk(actionProcessor_)) onNextWithId:immediateAction];
  return immediateAction;
}

- (void)dealloc {
  RELEASE_(unsubscribed_);
  RELEASE_(actionProcessor_);
  RELEASE_(actualWorker_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, 1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 2, 4, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithIoReactivexProcessorsFlowableProcessor:withIoReactivexScheduler_Worker:);
  methods[1].selector = @selector(dispose);
  methods[2].selector = @selector(isDisposed);
  methods[3].selector = @selector(scheduleWithJavaLangRunnable:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[4].selector = @selector(scheduleWithJavaLangRunnable:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "unsubscribed_", "LJavaUtilConcurrentAtomicAtomicBoolean;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "actionProcessor_", "LIoReactivexProcessorsFlowableProcessor;", .constantValue.asLong = 0, 0x12, -1, -1, 5, -1 },
    { "actualWorker_", "LIoReactivexScheduler_Worker;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LIoReactivexProcessorsFlowableProcessor;LIoReactivexScheduler_Worker;", "(Lio/reactivex/processors/FlowableProcessor<Lio/reactivex/internal/schedulers/SchedulerWhen$ScheduledAction;>;Lio/reactivex/Scheduler$Worker;)V", "schedule", "LJavaLangRunnable;JLJavaUtilConcurrentTimeUnit;", "LJavaLangRunnable;", "Lio/reactivex/processors/FlowableProcessor<Lio/reactivex/internal/schedulers/SchedulerWhen$ScheduledAction;>;", "LIoReactivexInternalSchedulersSchedulerWhen;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_QueueWorker = { "QueueWorker", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x18, 5, 3, 6, -1, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_QueueWorker;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_QueueWorker_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(IoReactivexInternalSchedulersSchedulerWhen_QueueWorker *self, IoReactivexProcessorsFlowableProcessor *actionProcessor, IoReactivexScheduler_Worker *actualWorker) {
  IoReactivexScheduler_Worker_init(self);
  JreStrongAssign(&self->actionProcessor_, actionProcessor);
  JreStrongAssign(&self->actualWorker_, actualWorker);
  JreStrongAssignAndConsume(&self->unsubscribed_, new_JavaUtilConcurrentAtomicAtomicBoolean_init());
}

IoReactivexInternalSchedulersSchedulerWhen_QueueWorker *new_IoReactivexInternalSchedulersSchedulerWhen_QueueWorker_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(IoReactivexProcessorsFlowableProcessor *actionProcessor, IoReactivexScheduler_Worker *actualWorker) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen_QueueWorker, initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_, actionProcessor, actualWorker)
}

IoReactivexInternalSchedulersSchedulerWhen_QueueWorker *create_IoReactivexInternalSchedulersSchedulerWhen_QueueWorker_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(IoReactivexProcessorsFlowableProcessor *actionProcessor, IoReactivexScheduler_Worker *actualWorker) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen_QueueWorker, initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_, actionProcessor, actualWorker)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersSchedulerWhen_QueueWorker)

@implementation IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)dispose {
}

- (jboolean)isDisposed {
  return false;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(dispose);
  methods[2].selector = @selector(isDisposed);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LIoReactivexInternalSchedulersSchedulerWhen;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable = { "SubscribedDisposable", "io.reactivex.internal.schedulers", ptrTable, methods, NULL, 7, 0x18, 3, 0, 0, -1, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable_init(IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable *self) {
  NSObject_init(self);
}

IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable *new_IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable_init() {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable, init)
}

IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable *create_IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable_init() {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersSchedulerWhen_SubscribedDisposable)
