//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "IoReactivexDisposablesDisposable.h"
#include "IoReactivexDisposablesDisposables.h"
#include "IoReactivexInternalDisposablesEmptyDisposable.h"
#include "IoReactivexInternalFunctionsObjectHelper.h"
#include "IoReactivexInternalSchedulersTrampolineScheduler.h"
#include "IoReactivexPluginsRxJavaPlugins.h"
#include "IoReactivexScheduler.h"
#include "J2ObjC_source.h"
#include "java/lang/InterruptedException.h"
#include "java/lang/Long.h"
#include "java/lang/Runnable.h"
#include "java/lang/Thread.h"
#include "java/util/concurrent/PriorityBlockingQueue.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/util/concurrent/atomic/AtomicInteger.h"

inline IoReactivexInternalSchedulersTrampolineScheduler *IoReactivexInternalSchedulersTrampolineScheduler_get_INSTANCE();
static IoReactivexInternalSchedulersTrampolineScheduler *IoReactivexInternalSchedulersTrampolineScheduler_INSTANCE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersTrampolineScheduler, INSTANCE, IoReactivexInternalSchedulersTrampolineScheduler *)

@interface IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker () {
 @public
  JavaUtilConcurrentAtomicAtomicInteger *wip_;
}

@end

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker, wip_, JavaUtilConcurrentAtomicAtomicInteger *)

@interface IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask () {
 @public
  IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker *this$0_;
}

@end

@interface IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable () {
 @public
  id<JavaLangRunnable> run_;
  IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker *worker_;
  jlong execTime_;
}

@end

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable, run_, id<JavaLangRunnable>)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable, worker_, IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker *)

J2OBJC_INITIALIZED_DEFN(IoReactivexInternalSchedulersTrampolineScheduler)

@implementation IoReactivexInternalSchedulersTrampolineScheduler

+ (IoReactivexInternalSchedulersTrampolineScheduler *)instance {
  return IoReactivexInternalSchedulersTrampolineScheduler_instance();
}

- (IoReactivexScheduler_Worker * __nonnull)createWorker {
  return create_IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_init();
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexInternalSchedulersTrampolineScheduler_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleDirectWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)run {
  [((id<JavaLangRunnable>) nil_chk(run)) run];
  return JreLoadEnum(IoReactivexInternalDisposablesEmptyDisposable, INSTANCE);
}

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleDirectWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)run
                                                                            withLong:(jlong)delay
                                                      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  @try {
    [((JavaUtilConcurrentTimeUnit *) nil_chk(unit)) sleepWithLong:delay];
    [((id<JavaLangRunnable>) nil_chk(run)) run];
  }
  @catch (JavaLangInterruptedException *ex) {
    [((JavaLangThread *) nil_chk(JavaLangThread_currentThread())) interrupt];
    IoReactivexPluginsRxJavaPlugins_onErrorWithJavaLangThrowable_(ex);
  }
  return JreLoadEnum(IoReactivexInternalDisposablesEmptyDisposable, INSTANCE);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LIoReactivexInternalSchedulersTrampolineScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler_Worker;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 0, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(instance);
  methods[1].selector = @selector(createWorker);
  methods[2].selector = @selector(init);
  methods[3].selector = @selector(scheduleDirectWithJavaLangRunnable:);
  methods[4].selector = @selector(scheduleDirectWithJavaLangRunnable:withLong:withJavaUtilConcurrentTimeUnit:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "INSTANCE", "LIoReactivexInternalSchedulersTrampolineScheduler;", .constantValue.asLong = 0, 0x1a, -1, 3, -1, -1 },
  };
  static const void *ptrTable[] = { "scheduleDirect", "LJavaLangRunnable;", "LJavaLangRunnable;JLJavaUtilConcurrentTimeUnit;", &IoReactivexInternalSchedulersTrampolineScheduler_INSTANCE, "LIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker;LIoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable;LIoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersTrampolineScheduler = { "TrampolineScheduler", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x11, 5, 1, -1, 4, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersTrampolineScheduler;
}

+ (void)initialize {
  if (self == [IoReactivexInternalSchedulersTrampolineScheduler class]) {
    JreStrongAssignAndConsume(&IoReactivexInternalSchedulersTrampolineScheduler_INSTANCE, new_IoReactivexInternalSchedulersTrampolineScheduler_init());
    J2OBJC_SET_INITIALIZED(IoReactivexInternalSchedulersTrampolineScheduler)
  }
}

@end

IoReactivexInternalSchedulersTrampolineScheduler *IoReactivexInternalSchedulersTrampolineScheduler_instance() {
  IoReactivexInternalSchedulersTrampolineScheduler_initialize();
  return IoReactivexInternalSchedulersTrampolineScheduler_INSTANCE;
}

void IoReactivexInternalSchedulersTrampolineScheduler_init(IoReactivexInternalSchedulersTrampolineScheduler *self) {
  IoReactivexScheduler_init(self);
}

IoReactivexInternalSchedulersTrampolineScheduler *new_IoReactivexInternalSchedulersTrampolineScheduler_init() {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersTrampolineScheduler, init)
}

IoReactivexInternalSchedulersTrampolineScheduler *create_IoReactivexInternalSchedulersTrampolineScheduler_init() {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersTrampolineScheduler, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersTrampolineScheduler)

@implementation IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)action {
  return [self enqueueWithJavaLangRunnable:action withLong:[self nowWithJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, MILLISECONDS)]];
}

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)action
                                                                      withLong:(jlong)delayTime
                                                withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit {
  jlong execTime = [self nowWithJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, MILLISECONDS)] + [((JavaUtilConcurrentTimeUnit *) nil_chk(unit)) toMillisWithLong:delayTime];
  return [self enqueueWithJavaLangRunnable:create_IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable_initWithJavaLangRunnable_withIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_withLong_(action, self, execTime) withLong:execTime];
}

- (id<IoReactivexDisposablesDisposable>)enqueueWithJavaLangRunnable:(id<JavaLangRunnable>)action
                                                           withLong:(jlong)execTime {
  if (JreLoadVolatileBoolean(&disposed_)) {
    return JreLoadEnum(IoReactivexInternalDisposablesEmptyDisposable, INSTANCE);
  }
  IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable *timedRunnable = create_IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable_initWithJavaLangRunnable_withJavaLangLong_withInt_(action, JavaLangLong_valueOfWithLong_(execTime), [((JavaUtilConcurrentAtomicAtomicInteger *) nil_chk(counter_)) incrementAndGet]);
  [((JavaUtilConcurrentPriorityBlockingQueue *) nil_chk(queue_)) addWithId:timedRunnable];
  if ([((JavaUtilConcurrentAtomicAtomicInteger *) nil_chk(wip_)) getAndIncrement] == 0) {
    jint missed = 1;
    for (; ; ) {
      for (; ; ) {
        if (JreLoadVolatileBoolean(&disposed_)) {
          [queue_ clear];
          return JreLoadEnum(IoReactivexInternalDisposablesEmptyDisposable, INSTANCE);
        }
        IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable *polled = [queue_ poll];
        if (polled == nil) {
          break;
        }
        if (!JreLoadVolatileBoolean(&polled->disposed_)) {
          [((id<JavaLangRunnable>) nil_chk(polled->run_)) run];
        }
      }
      missed = [wip_ addAndGetWithInt:-missed];
      if (missed == 0) {
        break;
      }
    }
    return JreLoadEnum(IoReactivexInternalDisposablesEmptyDisposable, INSTANCE);
  }
  else {
    return IoReactivexDisposablesDisposables_fromRunnableWithJavaLangRunnable_(create_IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask_initWithIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_withIoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable_(self, timedRunnable));
  }
}

- (void)dispose {
  JreAssignVolatileBoolean(&disposed_, true);
}

- (jboolean)isDisposed {
  return JreLoadVolatileBoolean(&disposed_);
}

- (void)dealloc {
  RELEASE_(queue_);
  RELEASE_(wip_);
  RELEASE_(counter_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 0, 2, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x0, 3, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(scheduleWithJavaLangRunnable:);
  methods[2].selector = @selector(scheduleWithJavaLangRunnable:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[3].selector = @selector(enqueueWithJavaLangRunnable:withLong:);
  methods[4].selector = @selector(dispose);
  methods[5].selector = @selector(isDisposed);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "queue_", "LJavaUtilConcurrentPriorityBlockingQueue;", .constantValue.asLong = 0, 0x10, -1, -1, 5, -1 },
    { "wip_", "LJavaUtilConcurrentAtomicAtomicInteger;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "counter_", "LJavaUtilConcurrentAtomicAtomicInteger;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "disposed_", "Z", .constantValue.asLong = 0, 0x40, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "schedule", "LJavaLangRunnable;", "LJavaLangRunnable;JLJavaUtilConcurrentTimeUnit;", "enqueue", "LJavaLangRunnable;J", "Ljava/util/concurrent/PriorityBlockingQueue<Lio/reactivex/internal/schedulers/TrampolineScheduler$TimedRunnable;>;", "LIoReactivexInternalSchedulersTrampolineScheduler;", "LIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker = { "TrampolineWorker", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x18, 6, 4, 6, 7, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker;
}

@end

void IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_init(IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker *self) {
  IoReactivexScheduler_Worker_init(self);
  JreStrongAssignAndConsume(&self->queue_, new_JavaUtilConcurrentPriorityBlockingQueue_init());
  JreStrongAssignAndConsume(&self->wip_, new_JavaUtilConcurrentAtomicAtomicInteger_init());
  JreStrongAssignAndConsume(&self->counter_, new_JavaUtilConcurrentAtomicAtomicInteger_init());
}

IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker *new_IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_init() {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker, init)
}

IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker *create_IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_init() {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker)

@implementation IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask

- (instancetype)initWithIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker:(IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker *)outer$
                       withIoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable:(IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable *)timedRunnable {
  IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask_initWithIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_withIoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable_(self, outer$, timedRunnable);
  return self;
}

- (void)run {
  JreAssignVolatileBoolean(&((IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable *) nil_chk(timedRunnable_))->disposed_, true);
  [((JavaUtilConcurrentPriorityBlockingQueue *) nil_chk(this$0_->queue_)) removeWithId:timedRunnable_];
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(timedRunnable_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker:withIoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable:);
  methods[1].selector = @selector(run);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "timedRunnable_", "LIoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LIoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable;", "LIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask = { "AppendToQueueTask", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x10, 2, 2, 1, -1, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask;
}

@end

void IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask_initWithIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_withIoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable_(IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask *self, IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker *outer$, IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable *timedRunnable) {
  JreStrongAssign(&self->this$0_, outer$);
  NSObject_init(self);
  JreStrongAssign(&self->timedRunnable_, timedRunnable);
}

IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask *new_IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask_initWithIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_withIoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable_(IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker *outer$, IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable *timedRunnable) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask, initWithIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_withIoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable_, outer$, timedRunnable)
}

IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask *create_IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask_initWithIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_withIoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable_(IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker *outer$, IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable *timedRunnable) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask, initWithIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_withIoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable_, outer$, timedRunnable)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_AppendToQueueTask)

@implementation IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)run
                        withJavaLangLong:(JavaLangLong *)execTime
                                 withInt:(jint)count {
  IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable_initWithJavaLangRunnable_withJavaLangLong_withInt_(self, run, execTime, count);
  return self;
}

- (jint)compareToWithId:(IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable *)that {
  cast_chk(that, [IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable class]);
  jint result = IoReactivexInternalFunctionsObjectHelper_compareWithLong_withLong_(execTime_, ((IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable *) nil_chk(that))->execTime_);
  if (result == 0) {
    return IoReactivexInternalFunctionsObjectHelper_compareWithInt_withInt_(count_, that->count_);
  }
  return result;
}

- (void)dealloc {
  RELEASE_(run_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaLangRunnable:withJavaLangLong:withInt:);
  methods[1].selector = @selector(compareToWithId:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "run_", "LJavaLangRunnable;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "execTime_", "J", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "count_", "I", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "disposed_", "Z", .constantValue.asLong = 0, 0x40, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaLangRunnable;LJavaLangLong;I", "compareTo", "LIoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable;", "LIoReactivexInternalSchedulersTrampolineScheduler;", "Ljava/lang/Object;Ljava/lang/Comparable<Lio/reactivex/internal/schedulers/TrampolineScheduler$TimedRunnable;>;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable = { "TimedRunnable", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x18, 2, 4, 3, -1, -1, 4, -1 };
  return &_IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable;
}

@end

void IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable_initWithJavaLangRunnable_withJavaLangLong_withInt_(IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable *self, id<JavaLangRunnable> run, JavaLangLong *execTime, jint count) {
  NSObject_init(self);
  JreStrongAssign(&self->run_, run);
  self->execTime_ = [((JavaLangLong *) nil_chk(execTime)) longLongValue];
  self->count_ = count;
}

IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable *new_IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable_initWithJavaLangRunnable_withJavaLangLong_withInt_(id<JavaLangRunnable> run, JavaLangLong *execTime, jint count) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable, initWithJavaLangRunnable_withJavaLangLong_withInt_, run, execTime, count)
}

IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable *create_IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable_initWithJavaLangRunnable_withJavaLangLong_withInt_(id<JavaLangRunnable> run, JavaLangLong *execTime, jint count) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable, initWithJavaLangRunnable_withJavaLangLong_withInt_, run, execTime, count)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersTrampolineScheduler_TimedRunnable)

@implementation IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)run
withIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker:(IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker *)worker
                                withLong:(jlong)execTime {
  IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable_initWithJavaLangRunnable_withIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_withLong_(self, run, worker, execTime);
  return self;
}

- (void)run {
  if (!JreLoadVolatileBoolean(&((IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker *) nil_chk(worker_))->disposed_)) {
    jlong t = [worker_ nowWithJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, MILLISECONDS)];
    if (execTime_ > t) {
      jlong delay = execTime_ - t;
      if (delay > 0) {
        @try {
          JavaLangThread_sleepWithLong_(delay);
        }
        @catch (JavaLangInterruptedException *e) {
          [((JavaLangThread *) nil_chk(JavaLangThread_currentThread())) interrupt];
          IoReactivexPluginsRxJavaPlugins_onErrorWithJavaLangThrowable_(e);
          return;
        }
      }
    }
    if (!JreLoadVolatileBoolean(&worker_->disposed_)) {
      [((id<JavaLangRunnable>) nil_chk(run_)) run];
    }
  }
}

- (void)dealloc {
  RELEASE_(run_);
  RELEASE_(worker_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaLangRunnable:withIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker:withLong:);
  methods[1].selector = @selector(run);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "run_", "LJavaLangRunnable;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "worker_", "LIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "execTime_", "J", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaLangRunnable;LIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker;J", "LIoReactivexInternalSchedulersTrampolineScheduler;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable = { "SleepingRunnable", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x18, 2, 3, 1, -1, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable;
}

@end

void IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable_initWithJavaLangRunnable_withIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_withLong_(IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable *self, id<JavaLangRunnable> run, IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker *worker, jlong execTime) {
  NSObject_init(self);
  JreStrongAssign(&self->run_, run);
  JreStrongAssign(&self->worker_, worker);
  self->execTime_ = execTime;
}

IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable *new_IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable_initWithJavaLangRunnable_withIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_withLong_(id<JavaLangRunnable> run, IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker *worker, jlong execTime) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable, initWithJavaLangRunnable_withIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_withLong_, run, worker, execTime)
}

IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable *create_IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable_initWithJavaLangRunnable_withIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_withLong_(id<JavaLangRunnable> run, IoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker *worker, jlong execTime) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable, initWithJavaLangRunnable_withIoReactivexInternalSchedulersTrampolineScheduler_TrampolineWorker_withLong_, run, worker, execTime)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersTrampolineScheduler_SleepingRunnable)
