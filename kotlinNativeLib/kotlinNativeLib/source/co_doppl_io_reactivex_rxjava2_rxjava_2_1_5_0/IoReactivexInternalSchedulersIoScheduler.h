//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_IoReactivexInternalSchedulersIoScheduler")
#ifdef RESTRICT_IoReactivexInternalSchedulersIoScheduler
#define INCLUDE_ALL_IoReactivexInternalSchedulersIoScheduler 0
#else
#define INCLUDE_ALL_IoReactivexInternalSchedulersIoScheduler 1
#endif
#undef RESTRICT_IoReactivexInternalSchedulersIoScheduler

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (IoReactivexInternalSchedulersIoScheduler_) && (INCLUDE_ALL_IoReactivexInternalSchedulersIoScheduler || defined(INCLUDE_IoReactivexInternalSchedulersIoScheduler))
#define IoReactivexInternalSchedulersIoScheduler_

#define RESTRICT_IoReactivexScheduler 1
#define INCLUDE_IoReactivexScheduler 1
#include "IoReactivexScheduler.h"

@class IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool;
@class IoReactivexInternalSchedulersIoScheduler_ThreadWorker;
@class IoReactivexInternalSchedulersRxThreadFactory;
@class IoReactivexScheduler_Worker;
@class JavaUtilConcurrentAtomicAtomicReference;
@protocol JavaUtilConcurrentThreadFactory;

@interface IoReactivexInternalSchedulersIoScheduler : IoReactivexScheduler {
 @public
  id<JavaUtilConcurrentThreadFactory> threadFactory_;
  JavaUtilConcurrentAtomicAtomicReference *pool_;
}

+ (IoReactivexInternalSchedulersRxThreadFactory *)WORKER_THREAD_FACTORY;

+ (IoReactivexInternalSchedulersRxThreadFactory *)EVICTOR_THREAD_FACTORY;

+ (IoReactivexInternalSchedulersIoScheduler_ThreadWorker *)SHUTDOWN_THREAD_WORKER;

+ (IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *)NONE;

#pragma mark Public

- (instancetype)init;

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory;

- (IoReactivexScheduler_Worker * __nonnull)createWorker;

- (void)shutdown;

- (jint)size;

- (void)start;

@end

J2OBJC_STATIC_INIT(IoReactivexInternalSchedulersIoScheduler)

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersIoScheduler, threadFactory_, id<JavaUtilConcurrentThreadFactory>)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersIoScheduler, pool_, JavaUtilConcurrentAtomicAtomicReference *)

inline IoReactivexInternalSchedulersRxThreadFactory *IoReactivexInternalSchedulersIoScheduler_get_WORKER_THREAD_FACTORY();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexInternalSchedulersRxThreadFactory *IoReactivexInternalSchedulersIoScheduler_WORKER_THREAD_FACTORY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersIoScheduler, WORKER_THREAD_FACTORY, IoReactivexInternalSchedulersRxThreadFactory *)

inline IoReactivexInternalSchedulersRxThreadFactory *IoReactivexInternalSchedulersIoScheduler_get_EVICTOR_THREAD_FACTORY();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexInternalSchedulersRxThreadFactory *IoReactivexInternalSchedulersIoScheduler_EVICTOR_THREAD_FACTORY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersIoScheduler, EVICTOR_THREAD_FACTORY, IoReactivexInternalSchedulersRxThreadFactory *)

inline IoReactivexInternalSchedulersIoScheduler_ThreadWorker *IoReactivexInternalSchedulersIoScheduler_get_SHUTDOWN_THREAD_WORKER();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexInternalSchedulersIoScheduler_ThreadWorker *IoReactivexInternalSchedulersIoScheduler_SHUTDOWN_THREAD_WORKER;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersIoScheduler, SHUTDOWN_THREAD_WORKER, IoReactivexInternalSchedulersIoScheduler_ThreadWorker *)

inline IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *IoReactivexInternalSchedulersIoScheduler_get_NONE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *IoReactivexInternalSchedulersIoScheduler_NONE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersIoScheduler, NONE, IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersIoScheduler_init(IoReactivexInternalSchedulersIoScheduler *self);

FOUNDATION_EXPORT IoReactivexInternalSchedulersIoScheduler *new_IoReactivexInternalSchedulersIoScheduler_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersIoScheduler *create_IoReactivexInternalSchedulersIoScheduler_init();

FOUNDATION_EXPORT void IoReactivexInternalSchedulersIoScheduler_initWithJavaUtilConcurrentThreadFactory_(IoReactivexInternalSchedulersIoScheduler *self, id<JavaUtilConcurrentThreadFactory> threadFactory);

FOUNDATION_EXPORT IoReactivexInternalSchedulersIoScheduler *new_IoReactivexInternalSchedulersIoScheduler_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersIoScheduler *create_IoReactivexInternalSchedulersIoScheduler_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersIoScheduler)

#endif

#if !defined (IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_) && (INCLUDE_ALL_IoReactivexInternalSchedulersIoScheduler || defined(INCLUDE_IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool))
#define IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_

#define RESTRICT_JavaLangRunnable 1
#define INCLUDE_JavaLangRunnable 1
#include "java/lang/Runnable.h"

@class IoReactivexDisposablesCompositeDisposable;
@class IoReactivexInternalSchedulersIoScheduler_ThreadWorker;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentThreadFactory;

@interface IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool : NSObject < JavaLangRunnable > {
 @public
  IoReactivexDisposablesCompositeDisposable *allWorkers_;
}

#pragma mark Public

- (void)run;

#pragma mark Package-Private

- (instancetype)initWithLong:(jlong)keepAliveTime
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
withJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory;

- (void)evictExpiredWorkers;

- (IoReactivexInternalSchedulersIoScheduler_ThreadWorker *)get;

- (jlong)now;

- (void)release__WithIoReactivexInternalSchedulersIoScheduler_ThreadWorker:(IoReactivexInternalSchedulersIoScheduler_ThreadWorker *)threadWorker;

- (void)shutdown;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool)

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool, allWorkers_, IoReactivexDisposablesCompositeDisposable *)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_initWithLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentThreadFactory_(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *self, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentThreadFactory> threadFactory);

FOUNDATION_EXPORT IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *new_IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_initWithLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentThreadFactory_(jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentThreadFactory> threadFactory) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *create_IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_initWithLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentThreadFactory_(jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentThreadFactory> threadFactory);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool)

#endif

#if !defined (IoReactivexInternalSchedulersIoScheduler_EventLoopWorker_) && (INCLUDE_ALL_IoReactivexInternalSchedulersIoScheduler || defined(INCLUDE_IoReactivexInternalSchedulersIoScheduler_EventLoopWorker))
#define IoReactivexInternalSchedulersIoScheduler_EventLoopWorker_

#define RESTRICT_IoReactivexScheduler 1
#define INCLUDE_IoReactivexScheduler_Worker 1
#include "IoReactivexScheduler.h"

@class IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool;
@class JavaUtilConcurrentAtomicAtomicBoolean;
@class JavaUtilConcurrentTimeUnit;
@protocol IoReactivexDisposablesDisposable;
@protocol JavaLangRunnable;

@interface IoReactivexInternalSchedulersIoScheduler_EventLoopWorker : IoReactivexScheduler_Worker {
 @public
  JavaUtilConcurrentAtomicAtomicBoolean *once_;
}

#pragma mark Public

- (void)dispose;

- (jboolean)isDisposed;

- (id<IoReactivexDisposablesDisposable> __nonnull)scheduleWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)action
                                                                      withLong:(jlong)delayTime
                                                withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

#pragma mark Package-Private

- (instancetype)initWithIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool:(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *)pool;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersIoScheduler_EventLoopWorker)

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersIoScheduler_EventLoopWorker, once_, JavaUtilConcurrentAtomicAtomicBoolean *)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersIoScheduler_EventLoopWorker_initWithIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_(IoReactivexInternalSchedulersIoScheduler_EventLoopWorker *self, IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *pool);

FOUNDATION_EXPORT IoReactivexInternalSchedulersIoScheduler_EventLoopWorker *new_IoReactivexInternalSchedulersIoScheduler_EventLoopWorker_initWithIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *pool) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersIoScheduler_EventLoopWorker *create_IoReactivexInternalSchedulersIoScheduler_EventLoopWorker_initWithIoReactivexInternalSchedulersIoScheduler_CachedWorkerPool_(IoReactivexInternalSchedulersIoScheduler_CachedWorkerPool *pool);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersIoScheduler_EventLoopWorker)

#endif

#if !defined (IoReactivexInternalSchedulersIoScheduler_ThreadWorker_) && (INCLUDE_ALL_IoReactivexInternalSchedulersIoScheduler || defined(INCLUDE_IoReactivexInternalSchedulersIoScheduler_ThreadWorker))
#define IoReactivexInternalSchedulersIoScheduler_ThreadWorker_

#define RESTRICT_IoReactivexInternalSchedulersNewThreadWorker 1
#define INCLUDE_IoReactivexInternalSchedulersNewThreadWorker 1
#include "IoReactivexInternalSchedulersNewThreadWorker.h"

@protocol JavaUtilConcurrentThreadFactory;

@interface IoReactivexInternalSchedulersIoScheduler_ThreadWorker : IoReactivexInternalSchedulersNewThreadWorker

#pragma mark Public

- (jlong)getExpirationTime;

- (void)setExpirationTimeWithLong:(jlong)expirationTime;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersIoScheduler_ThreadWorker)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersIoScheduler_ThreadWorker_initWithJavaUtilConcurrentThreadFactory_(IoReactivexInternalSchedulersIoScheduler_ThreadWorker *self, id<JavaUtilConcurrentThreadFactory> threadFactory);

FOUNDATION_EXPORT IoReactivexInternalSchedulersIoScheduler_ThreadWorker *new_IoReactivexInternalSchedulersIoScheduler_ThreadWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersIoScheduler_ThreadWorker *create_IoReactivexInternalSchedulersIoScheduler_ThreadWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersIoScheduler_ThreadWorker)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_IoReactivexInternalSchedulersIoScheduler")
