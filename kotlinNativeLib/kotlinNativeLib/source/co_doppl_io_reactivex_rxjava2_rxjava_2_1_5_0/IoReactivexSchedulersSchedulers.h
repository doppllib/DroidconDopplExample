//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_IoReactivexSchedulersSchedulers")
#ifdef RESTRICT_IoReactivexSchedulersSchedulers
#define INCLUDE_ALL_IoReactivexSchedulersSchedulers 0
#else
#define INCLUDE_ALL_IoReactivexSchedulersSchedulers 1
#endif
#undef RESTRICT_IoReactivexSchedulersSchedulers

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (IoReactivexSchedulersSchedulers_) && (INCLUDE_ALL_IoReactivexSchedulersSchedulers || defined(INCLUDE_IoReactivexSchedulersSchedulers))
#define IoReactivexSchedulersSchedulers_

@class IoReactivexScheduler;
@protocol JavaUtilConcurrentExecutor;

@interface IoReactivexSchedulersSchedulers : NSObject

+ (IoReactivexScheduler *)SINGLE;

+ (IoReactivexScheduler *)COMPUTATION;

+ (IoReactivexScheduler *)IO;

+ (IoReactivexScheduler *)TRAMPOLINE;

+ (IoReactivexScheduler *)NEW_THREAD;

#pragma mark Public

+ (IoReactivexScheduler * __nonnull)computation;

+ (IoReactivexScheduler * __nonnull)fromWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

+ (IoReactivexScheduler * __nonnull)io;

+ (IoReactivexScheduler * __nonnull)newThread OBJC_METHOD_FAMILY_NONE;

+ (void)shutdown;

+ (IoReactivexScheduler * __nonnull)single;

+ (void)start;

+ (IoReactivexScheduler * __nonnull)trampoline;

@end

J2OBJC_STATIC_INIT(IoReactivexSchedulersSchedulers)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_get_SINGLE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_SINGLE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers, SINGLE, IoReactivexScheduler *)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_get_COMPUTATION();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_COMPUTATION;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers, COMPUTATION, IoReactivexScheduler *)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_get_IO();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_IO;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers, IO, IoReactivexScheduler *)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_get_TRAMPOLINE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_TRAMPOLINE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers, TRAMPOLINE, IoReactivexScheduler *)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_get_NEW_THREAD();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_NEW_THREAD;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers, NEW_THREAD, IoReactivexScheduler *)

FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_computation();

FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_io();

FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_trampoline();

FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_newThread();

FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_single();

FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_fromWithJavaUtilConcurrentExecutor_(id<JavaUtilConcurrentExecutor> executor);

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_shutdown();

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_start();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexSchedulersSchedulers)

#endif

#if !defined (IoReactivexSchedulersSchedulers_SingleHolder_) && (INCLUDE_ALL_IoReactivexSchedulersSchedulers || defined(INCLUDE_IoReactivexSchedulersSchedulers_SingleHolder))
#define IoReactivexSchedulersSchedulers_SingleHolder_

@class IoReactivexScheduler;

@interface IoReactivexSchedulersSchedulers_SingleHolder : NSObject

+ (IoReactivexScheduler *)DEFAULT;

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_STATIC_INIT(IoReactivexSchedulersSchedulers_SingleHolder)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_SingleHolder_get_DEFAULT();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_SingleHolder_DEFAULT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers_SingleHolder, DEFAULT, IoReactivexScheduler *)

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_SingleHolder_init(IoReactivexSchedulersSchedulers_SingleHolder *self);

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_SingleHolder *new_IoReactivexSchedulersSchedulers_SingleHolder_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_SingleHolder *create_IoReactivexSchedulersSchedulers_SingleHolder_init();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexSchedulersSchedulers_SingleHolder)

#endif

#if !defined (IoReactivexSchedulersSchedulers_ComputationHolder_) && (INCLUDE_ALL_IoReactivexSchedulersSchedulers || defined(INCLUDE_IoReactivexSchedulersSchedulers_ComputationHolder))
#define IoReactivexSchedulersSchedulers_ComputationHolder_

@class IoReactivexScheduler;

@interface IoReactivexSchedulersSchedulers_ComputationHolder : NSObject

+ (IoReactivexScheduler *)DEFAULT;

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_STATIC_INIT(IoReactivexSchedulersSchedulers_ComputationHolder)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_ComputationHolder_get_DEFAULT();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_ComputationHolder_DEFAULT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers_ComputationHolder, DEFAULT, IoReactivexScheduler *)

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_ComputationHolder_init(IoReactivexSchedulersSchedulers_ComputationHolder *self);

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_ComputationHolder *new_IoReactivexSchedulersSchedulers_ComputationHolder_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_ComputationHolder *create_IoReactivexSchedulersSchedulers_ComputationHolder_init();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexSchedulersSchedulers_ComputationHolder)

#endif

#if !defined (IoReactivexSchedulersSchedulers_IoHolder_) && (INCLUDE_ALL_IoReactivexSchedulersSchedulers || defined(INCLUDE_IoReactivexSchedulersSchedulers_IoHolder))
#define IoReactivexSchedulersSchedulers_IoHolder_

@class IoReactivexScheduler;

@interface IoReactivexSchedulersSchedulers_IoHolder : NSObject

+ (IoReactivexScheduler *)DEFAULT;

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_STATIC_INIT(IoReactivexSchedulersSchedulers_IoHolder)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_IoHolder_get_DEFAULT();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_IoHolder_DEFAULT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers_IoHolder, DEFAULT, IoReactivexScheduler *)

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_IoHolder_init(IoReactivexSchedulersSchedulers_IoHolder *self);

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_IoHolder *new_IoReactivexSchedulersSchedulers_IoHolder_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_IoHolder *create_IoReactivexSchedulersSchedulers_IoHolder_init();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexSchedulersSchedulers_IoHolder)

#endif

#if !defined (IoReactivexSchedulersSchedulers_NewThreadHolder_) && (INCLUDE_ALL_IoReactivexSchedulersSchedulers || defined(INCLUDE_IoReactivexSchedulersSchedulers_NewThreadHolder))
#define IoReactivexSchedulersSchedulers_NewThreadHolder_

@class IoReactivexScheduler;

@interface IoReactivexSchedulersSchedulers_NewThreadHolder : NSObject

+ (IoReactivexScheduler *)DEFAULT;

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_STATIC_INIT(IoReactivexSchedulersSchedulers_NewThreadHolder)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_NewThreadHolder_get_DEFAULT();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_NewThreadHolder_DEFAULT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers_NewThreadHolder, DEFAULT, IoReactivexScheduler *)

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_NewThreadHolder_init(IoReactivexSchedulersSchedulers_NewThreadHolder *self);

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_NewThreadHolder *new_IoReactivexSchedulersSchedulers_NewThreadHolder_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_NewThreadHolder *create_IoReactivexSchedulersSchedulers_NewThreadHolder_init();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexSchedulersSchedulers_NewThreadHolder)

#endif

#if !defined (IoReactivexSchedulersSchedulers_IOTask_) && (INCLUDE_ALL_IoReactivexSchedulersSchedulers || defined(INCLUDE_IoReactivexSchedulersSchedulers_IOTask))
#define IoReactivexSchedulersSchedulers_IOTask_

#define RESTRICT_JavaUtilConcurrentCallable 1
#define INCLUDE_JavaUtilConcurrentCallable 1
#include "java/util/concurrent/Callable.h"

@class IoReactivexScheduler;

@interface IoReactivexSchedulersSchedulers_IOTask : NSObject < JavaUtilConcurrentCallable >

#pragma mark Public

- (IoReactivexScheduler *)call;

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexSchedulersSchedulers_IOTask)

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_IOTask_init(IoReactivexSchedulersSchedulers_IOTask *self);

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_IOTask *new_IoReactivexSchedulersSchedulers_IOTask_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_IOTask *create_IoReactivexSchedulersSchedulers_IOTask_init();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexSchedulersSchedulers_IOTask)

#endif

#if !defined (IoReactivexSchedulersSchedulers_NewThreadTask_) && (INCLUDE_ALL_IoReactivexSchedulersSchedulers || defined(INCLUDE_IoReactivexSchedulersSchedulers_NewThreadTask))
#define IoReactivexSchedulersSchedulers_NewThreadTask_

#define RESTRICT_JavaUtilConcurrentCallable 1
#define INCLUDE_JavaUtilConcurrentCallable 1
#include "java/util/concurrent/Callable.h"

@class IoReactivexScheduler;

@interface IoReactivexSchedulersSchedulers_NewThreadTask : NSObject < JavaUtilConcurrentCallable >

#pragma mark Public

- (IoReactivexScheduler *)call;

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexSchedulersSchedulers_NewThreadTask)

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_NewThreadTask_init(IoReactivexSchedulersSchedulers_NewThreadTask *self);

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_NewThreadTask *new_IoReactivexSchedulersSchedulers_NewThreadTask_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_NewThreadTask *create_IoReactivexSchedulersSchedulers_NewThreadTask_init();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexSchedulersSchedulers_NewThreadTask)

#endif

#if !defined (IoReactivexSchedulersSchedulers_SingleTask_) && (INCLUDE_ALL_IoReactivexSchedulersSchedulers || defined(INCLUDE_IoReactivexSchedulersSchedulers_SingleTask))
#define IoReactivexSchedulersSchedulers_SingleTask_

#define RESTRICT_JavaUtilConcurrentCallable 1
#define INCLUDE_JavaUtilConcurrentCallable 1
#include "java/util/concurrent/Callable.h"

@class IoReactivexScheduler;

@interface IoReactivexSchedulersSchedulers_SingleTask : NSObject < JavaUtilConcurrentCallable >

#pragma mark Public

- (IoReactivexScheduler *)call;

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexSchedulersSchedulers_SingleTask)

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_SingleTask_init(IoReactivexSchedulersSchedulers_SingleTask *self);

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_SingleTask *new_IoReactivexSchedulersSchedulers_SingleTask_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_SingleTask *create_IoReactivexSchedulersSchedulers_SingleTask_init();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexSchedulersSchedulers_SingleTask)

#endif

#if !defined (IoReactivexSchedulersSchedulers_ComputationTask_) && (INCLUDE_ALL_IoReactivexSchedulersSchedulers || defined(INCLUDE_IoReactivexSchedulersSchedulers_ComputationTask))
#define IoReactivexSchedulersSchedulers_ComputationTask_

#define RESTRICT_JavaUtilConcurrentCallable 1
#define INCLUDE_JavaUtilConcurrentCallable 1
#include "java/util/concurrent/Callable.h"

@class IoReactivexScheduler;

@interface IoReactivexSchedulersSchedulers_ComputationTask : NSObject < JavaUtilConcurrentCallable >

#pragma mark Public

- (IoReactivexScheduler *)call;

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexSchedulersSchedulers_ComputationTask)

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_ComputationTask_init(IoReactivexSchedulersSchedulers_ComputationTask *self);

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_ComputationTask *new_IoReactivexSchedulersSchedulers_ComputationTask_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_ComputationTask *create_IoReactivexSchedulersSchedulers_ComputationTask_init();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexSchedulersSchedulers_ComputationTask)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_IoReactivexSchedulersSchedulers")
