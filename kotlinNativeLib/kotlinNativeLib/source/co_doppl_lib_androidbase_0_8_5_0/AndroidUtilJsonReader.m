//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "AndroidUtilJsonReader.h"
#include "AndroidUtilJsonScope.h"
#include "AndroidUtilJsonToken.h"
#include "AndroidUtilMalformedJsonException.h"
#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/EOFException.h"
#include "java/io/IOException.h"
#include "java/io/Reader.h"
#include "java/lang/AssertionError.h"
#include "java/lang/CharSequence.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/Math.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/util/ArrayList.h"
#include "java/util/List.h"
#include "libcore/internal/StringPool.h"

@interface AndroidUtilJsonReader () {
 @public
  LibcoreInternalStringPool *stringPool_;
  JavaIoReader *in_;
  jboolean lenient_;
  IOSCharArray *buffer_;
  jint pos_;
  jint limit_;
  jint bufferStartLine_;
  jint bufferStartColumn_;
  id<JavaUtilList> stack_;
  AndroidUtilJsonToken *token_;
  NSString *name_;
  NSString *value_;
  jint valuePos_;
  jint valueLength_;
  jboolean skipping_;
}

- (void)expectWithAndroidUtilJsonToken:(AndroidUtilJsonToken *)expected;

- (AndroidUtilJsonToken *)advance;

- (AndroidUtilJsonScope *)peekStack;

- (AndroidUtilJsonScope *)pop;

- (void)pushWithAndroidUtilJsonScope:(AndroidUtilJsonScope *)newTop;

- (void)replaceTopWithAndroidUtilJsonScope:(AndroidUtilJsonScope *)newTop;

- (AndroidUtilJsonToken *)nextInArrayWithBoolean:(jboolean)firstElement;

- (AndroidUtilJsonToken *)nextInObjectWithBoolean:(jboolean)firstElement;

- (AndroidUtilJsonToken *)objectValue;

- (AndroidUtilJsonToken *)nextValue;

- (jboolean)fillBufferWithInt:(jint)minimum;

- (jint)getLineNumber;

- (jint)getColumnNumber;

- (jint)nextNonWhitespace;

- (void)checkLenient;

- (void)skipToEndOfLine;

- (jboolean)skipToWithNSString:(NSString *)toFind;

- (NSString *)nextStringWithChar:(jchar)quote;

- (NSString *)nextLiteralWithBoolean:(jboolean)assignOffsetsOnly;

- (jchar)readEscapeCharacter;

- (AndroidUtilJsonToken *)readLiteral;

- (AndroidUtilJsonToken *)decodeLiteral;

- (AndroidUtilJsonToken *)decodeNumberWithCharArray:(IOSCharArray *)chars
                                            withInt:(jint)offset
                                            withInt:(jint)length;

- (JavaIoIOException *)syntaxErrorWithNSString:(NSString *)message;

- (id<JavaLangCharSequence>)getSnippet;

@end

J2OBJC_FIELD_SETTER(AndroidUtilJsonReader, stringPool_, LibcoreInternalStringPool *)
J2OBJC_FIELD_SETTER(AndroidUtilJsonReader, in_, JavaIoReader *)
J2OBJC_FIELD_SETTER(AndroidUtilJsonReader, buffer_, IOSCharArray *)
J2OBJC_FIELD_SETTER(AndroidUtilJsonReader, stack_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(AndroidUtilJsonReader, token_, AndroidUtilJsonToken *)
J2OBJC_FIELD_SETTER(AndroidUtilJsonReader, name_, NSString *)
J2OBJC_FIELD_SETTER(AndroidUtilJsonReader, value_, NSString *)

inline NSString *AndroidUtilJsonReader_get_TRUE();
static NSString *AndroidUtilJsonReader_TRUE = @"true";
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidUtilJsonReader, TRUE, NSString *)

inline NSString *AndroidUtilJsonReader_get_FALSE();
static NSString *AndroidUtilJsonReader_FALSE = @"false";
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidUtilJsonReader, FALSE, NSString *)

__attribute__((unused)) static void AndroidUtilJsonReader_expectWithAndroidUtilJsonToken_(AndroidUtilJsonReader *self, AndroidUtilJsonToken *expected);

__attribute__((unused)) static AndroidUtilJsonToken *AndroidUtilJsonReader_advance(AndroidUtilJsonReader *self);

__attribute__((unused)) static AndroidUtilJsonScope *AndroidUtilJsonReader_peekStack(AndroidUtilJsonReader *self);

__attribute__((unused)) static AndroidUtilJsonScope *AndroidUtilJsonReader_pop(AndroidUtilJsonReader *self);

__attribute__((unused)) static void AndroidUtilJsonReader_pushWithAndroidUtilJsonScope_(AndroidUtilJsonReader *self, AndroidUtilJsonScope *newTop);

__attribute__((unused)) static void AndroidUtilJsonReader_replaceTopWithAndroidUtilJsonScope_(AndroidUtilJsonReader *self, AndroidUtilJsonScope *newTop);

__attribute__((unused)) static AndroidUtilJsonToken *AndroidUtilJsonReader_nextInArrayWithBoolean_(AndroidUtilJsonReader *self, jboolean firstElement);

__attribute__((unused)) static AndroidUtilJsonToken *AndroidUtilJsonReader_nextInObjectWithBoolean_(AndroidUtilJsonReader *self, jboolean firstElement);

__attribute__((unused)) static AndroidUtilJsonToken *AndroidUtilJsonReader_objectValue(AndroidUtilJsonReader *self);

__attribute__((unused)) static AndroidUtilJsonToken *AndroidUtilJsonReader_nextValue(AndroidUtilJsonReader *self);

__attribute__((unused)) static jboolean AndroidUtilJsonReader_fillBufferWithInt_(AndroidUtilJsonReader *self, jint minimum);

__attribute__((unused)) static jint AndroidUtilJsonReader_getLineNumber(AndroidUtilJsonReader *self);

__attribute__((unused)) static jint AndroidUtilJsonReader_getColumnNumber(AndroidUtilJsonReader *self);

__attribute__((unused)) static jint AndroidUtilJsonReader_nextNonWhitespace(AndroidUtilJsonReader *self);

__attribute__((unused)) static void AndroidUtilJsonReader_checkLenient(AndroidUtilJsonReader *self);

__attribute__((unused)) static void AndroidUtilJsonReader_skipToEndOfLine(AndroidUtilJsonReader *self);

__attribute__((unused)) static jboolean AndroidUtilJsonReader_skipToWithNSString_(AndroidUtilJsonReader *self, NSString *toFind);

__attribute__((unused)) static NSString *AndroidUtilJsonReader_nextStringWithChar_(AndroidUtilJsonReader *self, jchar quote);

__attribute__((unused)) static NSString *AndroidUtilJsonReader_nextLiteralWithBoolean_(AndroidUtilJsonReader *self, jboolean assignOffsetsOnly);

__attribute__((unused)) static jchar AndroidUtilJsonReader_readEscapeCharacter(AndroidUtilJsonReader *self);

__attribute__((unused)) static AndroidUtilJsonToken *AndroidUtilJsonReader_readLiteral(AndroidUtilJsonReader *self);

__attribute__((unused)) static AndroidUtilJsonToken *AndroidUtilJsonReader_decodeLiteral(AndroidUtilJsonReader *self);

__attribute__((unused)) static AndroidUtilJsonToken *AndroidUtilJsonReader_decodeNumberWithCharArray_withInt_withInt_(AndroidUtilJsonReader *self, IOSCharArray *chars, jint offset, jint length);

__attribute__((unused)) static JavaIoIOException *AndroidUtilJsonReader_syntaxErrorWithNSString_(AndroidUtilJsonReader *self, NSString *message);

__attribute__((unused)) static id<JavaLangCharSequence> AndroidUtilJsonReader_getSnippet(AndroidUtilJsonReader *self);

@implementation AndroidUtilJsonReader

- (instancetype)initWithJavaIoReader:(JavaIoReader *)inArg {
  AndroidUtilJsonReader_initWithJavaIoReader_(self, inArg);
  return self;
}

- (void)setLenientWithBoolean:(jboolean)lenient {
  self->lenient_ = lenient;
}

- (jboolean)isLenient {
  return lenient_;
}

- (void)beginArray {
  AndroidUtilJsonReader_expectWithAndroidUtilJsonToken_(self, JreLoadEnum(AndroidUtilJsonToken, BEGIN_ARRAY));
}

- (void)endArray {
  AndroidUtilJsonReader_expectWithAndroidUtilJsonToken_(self, JreLoadEnum(AndroidUtilJsonToken, END_ARRAY));
}

- (void)beginObject {
  AndroidUtilJsonReader_expectWithAndroidUtilJsonToken_(self, JreLoadEnum(AndroidUtilJsonToken, BEGIN_OBJECT));
}

- (void)endObject {
  AndroidUtilJsonReader_expectWithAndroidUtilJsonToken_(self, JreLoadEnum(AndroidUtilJsonToken, END_OBJECT));
}

- (void)expectWithAndroidUtilJsonToken:(AndroidUtilJsonToken *)expected {
  AndroidUtilJsonReader_expectWithAndroidUtilJsonToken_(self, expected);
}

- (jboolean)hasNext {
  [self peek];
  return token_ != JreLoadEnum(AndroidUtilJsonToken, END_OBJECT) && token_ != JreLoadEnum(AndroidUtilJsonToken, END_ARRAY);
}

- (AndroidUtilJsonToken *)peek {
  if (token_ != nil) {
    return token_;
  }
  {
    AndroidUtilJsonToken *firstToken;
    switch ([AndroidUtilJsonReader_peekStack(self) ordinal]) {
      case AndroidUtilJsonScope_Enum_EMPTY_DOCUMENT:
      AndroidUtilJsonReader_replaceTopWithAndroidUtilJsonScope_(self, JreLoadEnum(AndroidUtilJsonScope, NONEMPTY_DOCUMENT));
      firstToken = AndroidUtilJsonReader_nextValue(self);
      if (!lenient_ && token_ != JreLoadEnum(AndroidUtilJsonToken, BEGIN_ARRAY) && token_ != JreLoadEnum(AndroidUtilJsonToken, BEGIN_OBJECT)) {
        @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$@", @"Expected JSON document to start with '[' or '{' but was ", token_));
      }
      return firstToken;
      case AndroidUtilJsonScope_Enum_EMPTY_ARRAY:
      return AndroidUtilJsonReader_nextInArrayWithBoolean_(self, true);
      case AndroidUtilJsonScope_Enum_NONEMPTY_ARRAY:
      return AndroidUtilJsonReader_nextInArrayWithBoolean_(self, false);
      case AndroidUtilJsonScope_Enum_EMPTY_OBJECT:
      return AndroidUtilJsonReader_nextInObjectWithBoolean_(self, true);
      case AndroidUtilJsonScope_Enum_DANGLING_NAME:
      return AndroidUtilJsonReader_objectValue(self);
      case AndroidUtilJsonScope_Enum_NONEMPTY_OBJECT:
      return AndroidUtilJsonReader_nextInObjectWithBoolean_(self, false);
      case AndroidUtilJsonScope_Enum_NONEMPTY_DOCUMENT:
      @try {
        AndroidUtilJsonToken *token = AndroidUtilJsonReader_nextValue(self);
        if (lenient_) {
          return token;
        }
        @throw nil_chk(AndroidUtilJsonReader_syntaxErrorWithNSString_(self, @"Expected EOF"));
      }
      @catch (JavaIoEOFException *e) {
        return JreStrongAssign(&token_, JreLoadEnum(AndroidUtilJsonToken, END_DOCUMENT));
      }
      case AndroidUtilJsonScope_Enum_CLOSED:
      @throw create_JavaLangIllegalStateException_initWithNSString_(@"JsonReader is closed");
      default:
      @throw create_JavaLangAssertionError_init();
    }
  }
}

- (AndroidUtilJsonToken *)advance {
  return AndroidUtilJsonReader_advance(self);
}

- (NSString *)nextName {
  [self peek];
  if (token_ != JreLoadEnum(AndroidUtilJsonToken, NAME)) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@", @"Expected a name but was ", [self peek]));
  }
  NSString *result = name_;
  AndroidUtilJsonReader_advance(self);
  return result;
}

- (NSString *)nextString {
  [self peek];
  if (token_ != JreLoadEnum(AndroidUtilJsonToken, STRING) && token_ != JreLoadEnum(AndroidUtilJsonToken, NUMBER)) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@", @"Expected a string but was ", [self peek]));
  }
  NSString *result = value_;
  AndroidUtilJsonReader_advance(self);
  return result;
}

- (jboolean)nextBoolean {
  [self peek];
  if (token_ != JreLoadEnum(AndroidUtilJsonToken, BOOLEAN)) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@", @"Expected a boolean but was ", token_));
  }
  jboolean result = value_ == AndroidUtilJsonReader_TRUE;
  AndroidUtilJsonReader_advance(self);
  return result;
}

- (void)nextNull {
  [self peek];
  if (token_ != JreLoadEnum(AndroidUtilJsonToken, NULL)) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@", @"Expected null but was ", token_));
  }
  AndroidUtilJsonReader_advance(self);
}

- (jdouble)nextDouble {
  [self peek];
  if (token_ != JreLoadEnum(AndroidUtilJsonToken, STRING) && token_ != JreLoadEnum(AndroidUtilJsonToken, NUMBER)) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@", @"Expected a double but was ", token_));
  }
  jdouble result = JavaLangDouble_parseDoubleWithNSString_(value_);
  AndroidUtilJsonReader_advance(self);
  return result;
}

- (jlong)nextLong {
  [self peek];
  if (token_ != JreLoadEnum(AndroidUtilJsonToken, STRING) && token_ != JreLoadEnum(AndroidUtilJsonToken, NUMBER)) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@", @"Expected a long but was ", token_));
  }
  jlong result;
  @try {
    result = JavaLangLong_parseLongWithNSString_(value_);
  }
  @catch (JavaLangNumberFormatException *ignored) {
    jdouble asDouble = JavaLangDouble_parseDoubleWithNSString_(value_);
    result = JreFpToLong(asDouble);
    if ((jdouble) result != asDouble) {
      @throw create_JavaLangNumberFormatException_initWithNSString_(value_);
    }
  }
  AndroidUtilJsonReader_advance(self);
  return result;
}

- (jint)nextInt {
  [self peek];
  if (token_ != JreLoadEnum(AndroidUtilJsonToken, STRING) && token_ != JreLoadEnum(AndroidUtilJsonToken, NUMBER)) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@", @"Expected an int but was ", token_));
  }
  jint result;
  @try {
    result = JavaLangInteger_parseIntWithNSString_(value_);
  }
  @catch (JavaLangNumberFormatException *ignored) {
    jdouble asDouble = JavaLangDouble_parseDoubleWithNSString_(value_);
    result = JreFpToInt(asDouble);
    if ((jdouble) result != asDouble) {
      @throw create_JavaLangNumberFormatException_initWithNSString_(value_);
    }
  }
  AndroidUtilJsonReader_advance(self);
  return result;
}

- (void)close {
  JreStrongAssign(&value_, nil);
  JreStrongAssign(&token_, nil);
  [((id<JavaUtilList>) nil_chk(stack_)) clear];
  [stack_ addWithId:JreLoadEnum(AndroidUtilJsonScope, CLOSED)];
  [((JavaIoReader *) nil_chk(in_)) close];
}

- (void)skipValue {
  skipping_ = true;
  @try {
    jint count = 0;
    do {
      AndroidUtilJsonToken *token = AndroidUtilJsonReader_advance(self);
      if (token == JreLoadEnum(AndroidUtilJsonToken, BEGIN_ARRAY) || token == JreLoadEnum(AndroidUtilJsonToken, BEGIN_OBJECT)) {
        count++;
      }
      else if (token == JreLoadEnum(AndroidUtilJsonToken, END_ARRAY) || token == JreLoadEnum(AndroidUtilJsonToken, END_OBJECT)) {
        count--;
      }
    }
    while (count != 0);
  }
  @finally {
    skipping_ = false;
  }
}

- (AndroidUtilJsonScope *)peekStack {
  return AndroidUtilJsonReader_peekStack(self);
}

- (AndroidUtilJsonScope *)pop {
  return AndroidUtilJsonReader_pop(self);
}

- (void)pushWithAndroidUtilJsonScope:(AndroidUtilJsonScope *)newTop {
  AndroidUtilJsonReader_pushWithAndroidUtilJsonScope_(self, newTop);
}

- (void)replaceTopWithAndroidUtilJsonScope:(AndroidUtilJsonScope *)newTop {
  AndroidUtilJsonReader_replaceTopWithAndroidUtilJsonScope_(self, newTop);
}

- (AndroidUtilJsonToken *)nextInArrayWithBoolean:(jboolean)firstElement {
  return AndroidUtilJsonReader_nextInArrayWithBoolean_(self, firstElement);
}

- (AndroidUtilJsonToken *)nextInObjectWithBoolean:(jboolean)firstElement {
  return AndroidUtilJsonReader_nextInObjectWithBoolean_(self, firstElement);
}

- (AndroidUtilJsonToken *)objectValue {
  return AndroidUtilJsonReader_objectValue(self);
}

- (AndroidUtilJsonToken *)nextValue {
  return AndroidUtilJsonReader_nextValue(self);
}

- (jboolean)fillBufferWithInt:(jint)minimum {
  return AndroidUtilJsonReader_fillBufferWithInt_(self, minimum);
}

- (jint)getLineNumber {
  return AndroidUtilJsonReader_getLineNumber(self);
}

- (jint)getColumnNumber {
  return AndroidUtilJsonReader_getColumnNumber(self);
}

- (jint)nextNonWhitespace {
  return AndroidUtilJsonReader_nextNonWhitespace(self);
}

- (void)checkLenient {
  AndroidUtilJsonReader_checkLenient(self);
}

- (void)skipToEndOfLine {
  AndroidUtilJsonReader_skipToEndOfLine(self);
}

- (jboolean)skipToWithNSString:(NSString *)toFind {
  return AndroidUtilJsonReader_skipToWithNSString_(self, toFind);
}

- (NSString *)nextStringWithChar:(jchar)quote {
  return AndroidUtilJsonReader_nextStringWithChar_(self, quote);
}

- (NSString *)nextLiteralWithBoolean:(jboolean)assignOffsetsOnly {
  return AndroidUtilJsonReader_nextLiteralWithBoolean_(self, assignOffsetsOnly);
}

- (NSString *)description {
  return JreStrcat("$$@", [[self java_getClass] getSimpleName], @" near ", AndroidUtilJsonReader_getSnippet(self));
}

- (jchar)readEscapeCharacter {
  return AndroidUtilJsonReader_readEscapeCharacter(self);
}

- (AndroidUtilJsonToken *)readLiteral {
  return AndroidUtilJsonReader_readLiteral(self);
}

- (AndroidUtilJsonToken *)decodeLiteral {
  return AndroidUtilJsonReader_decodeLiteral(self);
}

- (AndroidUtilJsonToken *)decodeNumberWithCharArray:(IOSCharArray *)chars
                                            withInt:(jint)offset
                                            withInt:(jint)length {
  return AndroidUtilJsonReader_decodeNumberWithCharArray_withInt_withInt_(self, chars, offset, length);
}

- (JavaIoIOException *)syntaxErrorWithNSString:(NSString *)message {
  return AndroidUtilJsonReader_syntaxErrorWithNSString_(self, message);
}

- (id<JavaLangCharSequence>)getSnippet {
  return AndroidUtilJsonReader_getSnippet(self);
}

- (void)dealloc {
  RELEASE_(stringPool_);
  RELEASE_(in_);
  RELEASE_(buffer_);
  RELEASE_(stack_);
  RELEASE_(token_);
  RELEASE_(name_);
  RELEASE_(value_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x2, 4, 5, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "LAndroidUtilJsonToken;", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "LAndroidUtilJsonToken;", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "D", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "LAndroidUtilJsonScope;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LAndroidUtilJsonScope;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 8, 7, -1, -1, -1, -1 },
    { NULL, "LAndroidUtilJsonToken;", 0x2, 9, 2, 3, -1, -1, -1 },
    { NULL, "LAndroidUtilJsonToken;", 0x2, 10, 2, 3, -1, -1, -1 },
    { NULL, "LAndroidUtilJsonToken;", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "LAndroidUtilJsonToken;", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x2, 11, 12, 3, -1, -1, -1 },
    { NULL, "I", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x2, 13, 14, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x2, 15, 16, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x2, 17, 2, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 18, -1, -1, -1, -1, -1 },
    { NULL, "C", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "LAndroidUtilJsonToken;", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "LAndroidUtilJsonToken;", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "LAndroidUtilJsonToken;", 0x2, 19, 20, -1, -1, -1, -1 },
    { NULL, "LJavaIoIOException;", 0x2, 21, 14, 3, -1, -1, -1 },
    { NULL, "LJavaLangCharSequence;", 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaIoReader:);
  methods[1].selector = @selector(setLenientWithBoolean:);
  methods[2].selector = @selector(isLenient);
  methods[3].selector = @selector(beginArray);
  methods[4].selector = @selector(endArray);
  methods[5].selector = @selector(beginObject);
  methods[6].selector = @selector(endObject);
  methods[7].selector = @selector(expectWithAndroidUtilJsonToken:);
  methods[8].selector = @selector(hasNext);
  methods[9].selector = @selector(peek);
  methods[10].selector = @selector(advance);
  methods[11].selector = @selector(nextName);
  methods[12].selector = @selector(nextString);
  methods[13].selector = @selector(nextBoolean);
  methods[14].selector = @selector(nextNull);
  methods[15].selector = @selector(nextDouble);
  methods[16].selector = @selector(nextLong);
  methods[17].selector = @selector(nextInt);
  methods[18].selector = @selector(close);
  methods[19].selector = @selector(skipValue);
  methods[20].selector = @selector(peekStack);
  methods[21].selector = @selector(pop);
  methods[22].selector = @selector(pushWithAndroidUtilJsonScope:);
  methods[23].selector = @selector(replaceTopWithAndroidUtilJsonScope:);
  methods[24].selector = @selector(nextInArrayWithBoolean:);
  methods[25].selector = @selector(nextInObjectWithBoolean:);
  methods[26].selector = @selector(objectValue);
  methods[27].selector = @selector(nextValue);
  methods[28].selector = @selector(fillBufferWithInt:);
  methods[29].selector = @selector(getLineNumber);
  methods[30].selector = @selector(getColumnNumber);
  methods[31].selector = @selector(nextNonWhitespace);
  methods[32].selector = @selector(checkLenient);
  methods[33].selector = @selector(skipToEndOfLine);
  methods[34].selector = @selector(skipToWithNSString:);
  methods[35].selector = @selector(nextStringWithChar:);
  methods[36].selector = @selector(nextLiteralWithBoolean:);
  methods[37].selector = @selector(description);
  methods[38].selector = @selector(readEscapeCharacter);
  methods[39].selector = @selector(readLiteral);
  methods[40].selector = @selector(decodeLiteral);
  methods[41].selector = @selector(decodeNumberWithCharArray:withInt:withInt:);
  methods[42].selector = @selector(syntaxErrorWithNSString:);
  methods[43].selector = @selector(getSnippet);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TRUE", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 22, -1, -1 },
    { "FALSE", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 23, -1, -1 },
    { "stringPool_", "LLibcoreInternalStringPool;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "in_", "LJavaIoReader;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "lenient_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "buffer_", "[C", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "pos_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "limit_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "bufferStartLine_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "bufferStartColumn_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "stack_", "LJavaUtilList;", .constantValue.asLong = 0, 0x12, -1, -1, 24, -1 },
    { "token_", "LAndroidUtilJsonToken;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "name_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "value_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "valuePos_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "valueLength_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "skipping_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaIoReader;", "setLenient", "Z", "LJavaIoIOException;", "expect", "LAndroidUtilJsonToken;", "push", "LAndroidUtilJsonScope;", "replaceTop", "nextInArray", "nextInObject", "fillBuffer", "I", "skipTo", "LNSString;", "nextString", "C", "nextLiteral", "toString", "decodeNumber", "[CII", "syntaxError", &AndroidUtilJsonReader_TRUE, &AndroidUtilJsonReader_FALSE, "Ljava/util/List<Landroid/util/JsonScope;>;" };
  static const J2ObjcClassInfo _AndroidUtilJsonReader = { "JsonReader", "android.util", ptrTable, methods, fields, 7, 0x11, 44, 17, -1, -1, -1, -1, -1 };
  return &_AndroidUtilJsonReader;
}

@end

void AndroidUtilJsonReader_initWithJavaIoReader_(AndroidUtilJsonReader *self, JavaIoReader *inArg) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->stringPool_, new_LibcoreInternalStringPool_init());
  self->lenient_ = false;
  JreStrongAssignAndConsume(&self->buffer_, [IOSCharArray newArrayWithLength:1024]);
  self->pos_ = 0;
  self->limit_ = 0;
  self->bufferStartLine_ = 1;
  self->bufferStartColumn_ = 1;
  JreStrongAssignAndConsume(&self->stack_, new_JavaUtilArrayList_init());
  {
    AndroidUtilJsonReader_pushWithAndroidUtilJsonScope_(self, JreLoadEnum(AndroidUtilJsonScope, EMPTY_DOCUMENT));
  }
  self->skipping_ = false;
  if (inArg == nil) {
    @throw create_JavaLangNullPointerException_initWithNSString_(@"in == null");
  }
  JreStrongAssign(&self->in_, inArg);
}

AndroidUtilJsonReader *new_AndroidUtilJsonReader_initWithJavaIoReader_(JavaIoReader *inArg) {
  J2OBJC_NEW_IMPL(AndroidUtilJsonReader, initWithJavaIoReader_, inArg)
}

AndroidUtilJsonReader *create_AndroidUtilJsonReader_initWithJavaIoReader_(JavaIoReader *inArg) {
  J2OBJC_CREATE_IMPL(AndroidUtilJsonReader, initWithJavaIoReader_, inArg)
}

void AndroidUtilJsonReader_expectWithAndroidUtilJsonToken_(AndroidUtilJsonReader *self, AndroidUtilJsonToken *expected) {
  [self peek];
  if (self->token_ != expected) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$@", @"Expected ", expected, @" but was ", [self peek]));
  }
  AndroidUtilJsonReader_advance(self);
}

AndroidUtilJsonToken *AndroidUtilJsonReader_advance(AndroidUtilJsonReader *self) {
  [self peek];
  AndroidUtilJsonToken *result = self->token_;
  JreStrongAssign(&self->token_, nil);
  JreStrongAssign(&self->value_, nil);
  JreStrongAssign(&self->name_, nil);
  return result;
}

AndroidUtilJsonScope *AndroidUtilJsonReader_peekStack(AndroidUtilJsonReader *self) {
  return [((id<JavaUtilList>) nil_chk(self->stack_)) getWithInt:[self->stack_ size] - 1];
}

AndroidUtilJsonScope *AndroidUtilJsonReader_pop(AndroidUtilJsonReader *self) {
  return [((id<JavaUtilList>) nil_chk(self->stack_)) removeWithInt:[self->stack_ size] - 1];
}

void AndroidUtilJsonReader_pushWithAndroidUtilJsonScope_(AndroidUtilJsonReader *self, AndroidUtilJsonScope *newTop) {
  [((id<JavaUtilList>) nil_chk(self->stack_)) addWithId:newTop];
}

void AndroidUtilJsonReader_replaceTopWithAndroidUtilJsonScope_(AndroidUtilJsonReader *self, AndroidUtilJsonScope *newTop) {
  [((id<JavaUtilList>) nil_chk(self->stack_)) setWithInt:[self->stack_ size] - 1 withId:newTop];
}

AndroidUtilJsonToken *AndroidUtilJsonReader_nextInArrayWithBoolean_(AndroidUtilJsonReader *self, jboolean firstElement) {
  if (firstElement) {
    AndroidUtilJsonReader_replaceTopWithAndroidUtilJsonScope_(self, JreLoadEnum(AndroidUtilJsonScope, NONEMPTY_ARRAY));
  }
  else {
    switch (AndroidUtilJsonReader_nextNonWhitespace(self)) {
      case ']':
      AndroidUtilJsonReader_pop(self);
      return JreStrongAssign(&self->token_, JreLoadEnum(AndroidUtilJsonToken, END_ARRAY));
      case ';':
      AndroidUtilJsonReader_checkLenient(self);
      case ',':
      break;
      default:
      @throw nil_chk(AndroidUtilJsonReader_syntaxErrorWithNSString_(self, @"Unterminated array"));
    }
  }
  switch (AndroidUtilJsonReader_nextNonWhitespace(self)) {
    case ']':
    if (firstElement) {
      AndroidUtilJsonReader_pop(self);
      return JreStrongAssign(&self->token_, JreLoadEnum(AndroidUtilJsonToken, END_ARRAY));
    }
    case ';':
    case ',':
    AndroidUtilJsonReader_checkLenient(self);
    self->pos_--;
    JreStrongAssign(&self->value_, @"null");
    return JreStrongAssign(&self->token_, JreLoadEnum(AndroidUtilJsonToken, NULL));
    default:
    self->pos_--;
    return AndroidUtilJsonReader_nextValue(self);
  }
}

AndroidUtilJsonToken *AndroidUtilJsonReader_nextInObjectWithBoolean_(AndroidUtilJsonReader *self, jboolean firstElement) {
  if (firstElement) {
    switch (AndroidUtilJsonReader_nextNonWhitespace(self)) {
      case '}':
      AndroidUtilJsonReader_pop(self);
      return JreStrongAssign(&self->token_, JreLoadEnum(AndroidUtilJsonToken, END_OBJECT));
      default:
      self->pos_--;
    }
  }
  else {
    switch (AndroidUtilJsonReader_nextNonWhitespace(self)) {
      case '}':
      AndroidUtilJsonReader_pop(self);
      return JreStrongAssign(&self->token_, JreLoadEnum(AndroidUtilJsonToken, END_OBJECT));
      case ';':
      case ',':
      break;
      default:
      @throw nil_chk(AndroidUtilJsonReader_syntaxErrorWithNSString_(self, @"Unterminated object"));
    }
  }
  jint quote = AndroidUtilJsonReader_nextNonWhitespace(self);
  switch (quote) {
    case '\'':
    AndroidUtilJsonReader_checkLenient(self);
    case '"':
    JreStrongAssign(&self->name_, AndroidUtilJsonReader_nextStringWithChar_(self, (jchar) quote));
    break;
    default:
    AndroidUtilJsonReader_checkLenient(self);
    self->pos_--;
    JreStrongAssign(&self->name_, AndroidUtilJsonReader_nextLiteralWithBoolean_(self, false));
    if ([((NSString *) nil_chk(self->name_)) java_isEmpty]) {
      @throw nil_chk(AndroidUtilJsonReader_syntaxErrorWithNSString_(self, @"Expected name"));
    }
  }
  AndroidUtilJsonReader_replaceTopWithAndroidUtilJsonScope_(self, JreLoadEnum(AndroidUtilJsonScope, DANGLING_NAME));
  return JreStrongAssign(&self->token_, JreLoadEnum(AndroidUtilJsonToken, NAME));
}

AndroidUtilJsonToken *AndroidUtilJsonReader_objectValue(AndroidUtilJsonReader *self) {
  switch (AndroidUtilJsonReader_nextNonWhitespace(self)) {
    case ':':
    break;
    case '=':
    AndroidUtilJsonReader_checkLenient(self);
    if ((self->pos_ < self->limit_ || AndroidUtilJsonReader_fillBufferWithInt_(self, 1)) && IOSCharArray_Get(nil_chk(self->buffer_), self->pos_) == '>') {
      self->pos_++;
    }
    break;
    default:
    @throw nil_chk(AndroidUtilJsonReader_syntaxErrorWithNSString_(self, @"Expected ':'"));
  }
  AndroidUtilJsonReader_replaceTopWithAndroidUtilJsonScope_(self, JreLoadEnum(AndroidUtilJsonScope, NONEMPTY_OBJECT));
  return AndroidUtilJsonReader_nextValue(self);
}

AndroidUtilJsonToken *AndroidUtilJsonReader_nextValue(AndroidUtilJsonReader *self) {
  jint c = AndroidUtilJsonReader_nextNonWhitespace(self);
  switch (c) {
    case '{':
    AndroidUtilJsonReader_pushWithAndroidUtilJsonScope_(self, JreLoadEnum(AndroidUtilJsonScope, EMPTY_OBJECT));
    return JreStrongAssign(&self->token_, JreLoadEnum(AndroidUtilJsonToken, BEGIN_OBJECT));
    case '[':
    AndroidUtilJsonReader_pushWithAndroidUtilJsonScope_(self, JreLoadEnum(AndroidUtilJsonScope, EMPTY_ARRAY));
    return JreStrongAssign(&self->token_, JreLoadEnum(AndroidUtilJsonToken, BEGIN_ARRAY));
    case '\'':
    AndroidUtilJsonReader_checkLenient(self);
    case '"':
    JreStrongAssign(&self->value_, AndroidUtilJsonReader_nextStringWithChar_(self, (jchar) c));
    return JreStrongAssign(&self->token_, JreLoadEnum(AndroidUtilJsonToken, STRING));
    default:
    self->pos_--;
    return AndroidUtilJsonReader_readLiteral(self);
  }
}

jboolean AndroidUtilJsonReader_fillBufferWithInt_(AndroidUtilJsonReader *self, jint minimum) {
  for (jint i = 0; i < self->pos_; i++) {
    if (IOSCharArray_Get(nil_chk(self->buffer_), i) == 0x000a) {
      self->bufferStartLine_++;
      self->bufferStartColumn_ = 1;
    }
    else {
      self->bufferStartColumn_++;
    }
  }
  if (self->limit_ != self->pos_) {
    self->limit_ -= self->pos_;
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->buffer_, self->pos_, self->buffer_, 0, self->limit_);
  }
  else {
    self->limit_ = 0;
  }
  self->pos_ = 0;
  jint total;
  while ((total = [((JavaIoReader *) nil_chk(self->in_)) readWithCharArray:self->buffer_ withInt:self->limit_ withInt:((IOSCharArray *) nil_chk(self->buffer_))->size_ - self->limit_]) != -1) {
    self->limit_ += total;
    if (self->bufferStartLine_ == 1 && self->bufferStartColumn_ == 1 && self->limit_ > 0 && IOSCharArray_Get(self->buffer_, 0) == 0xfeff) {
      self->pos_++;
      self->bufferStartColumn_--;
    }
    if (self->limit_ >= minimum) {
      return true;
    }
  }
  return false;
}

jint AndroidUtilJsonReader_getLineNumber(AndroidUtilJsonReader *self) {
  jint result = self->bufferStartLine_;
  for (jint i = 0; i < self->pos_; i++) {
    if (IOSCharArray_Get(nil_chk(self->buffer_), i) == 0x000a) {
      result++;
    }
  }
  return result;
}

jint AndroidUtilJsonReader_getColumnNumber(AndroidUtilJsonReader *self) {
  jint result = self->bufferStartColumn_;
  for (jint i = 0; i < self->pos_; i++) {
    if (IOSCharArray_Get(nil_chk(self->buffer_), i) == 0x000a) {
      result = 1;
    }
    else {
      result++;
    }
  }
  return result;
}

jint AndroidUtilJsonReader_nextNonWhitespace(AndroidUtilJsonReader *self) {
  while (self->pos_ < self->limit_ || AndroidUtilJsonReader_fillBufferWithInt_(self, 1)) {
    jint c = IOSCharArray_Get(nil_chk(self->buffer_), self->pos_++);
    {
      jchar peek;
      switch (c) {
        case 0x0009:
        case ' ':
        case 0x000a:
        case 0x000d:
        continue;
        case '/':
        if (self->pos_ == self->limit_ && !AndroidUtilJsonReader_fillBufferWithInt_(self, 1)) {
          return c;
        }
        AndroidUtilJsonReader_checkLenient(self);
        peek = IOSCharArray_Get(self->buffer_, self->pos_);
        switch (peek) {
          case '*':
          self->pos_++;
          if (!AndroidUtilJsonReader_skipToWithNSString_(self, @"*/")) {
            @throw nil_chk(AndroidUtilJsonReader_syntaxErrorWithNSString_(self, @"Unterminated comment"));
          }
          self->pos_ += 2;
          continue;
          case '/':
          self->pos_++;
          AndroidUtilJsonReader_skipToEndOfLine(self);
          continue;
          default:
          return c;
        }
        case '#':
        AndroidUtilJsonReader_checkLenient(self);
        AndroidUtilJsonReader_skipToEndOfLine(self);
        continue;
        default:
        return c;
      }
    }
  }
  @throw create_JavaIoEOFException_initWithNSString_(@"End of input");
}

void AndroidUtilJsonReader_checkLenient(AndroidUtilJsonReader *self) {
  if (!self->lenient_) {
    @throw nil_chk(AndroidUtilJsonReader_syntaxErrorWithNSString_(self, @"Use JsonReader.setLenient(true) to accept malformed JSON"));
  }
}

void AndroidUtilJsonReader_skipToEndOfLine(AndroidUtilJsonReader *self) {
  while (self->pos_ < self->limit_ || AndroidUtilJsonReader_fillBufferWithInt_(self, 1)) {
    jchar c = IOSCharArray_Get(nil_chk(self->buffer_), self->pos_++);
    if (c == 0x000d || c == 0x000a) {
      break;
    }
  }
}

jboolean AndroidUtilJsonReader_skipToWithNSString_(AndroidUtilJsonReader *self, NSString *toFind) {
  for (; self->pos_ + [((NSString *) nil_chk(toFind)) java_length] <= self->limit_ || AndroidUtilJsonReader_fillBufferWithInt_(self, [toFind java_length]); self->pos_++) {
    {
      for (jint c = 0; c < [toFind java_length]; c++) {
        if (IOSCharArray_Get(nil_chk(self->buffer_), self->pos_ + c) != [toFind charAtWithInt:c]) {
          goto continue_outer;
        }
      }
      return true;
    }
    continue_outer: ;
  }
  return false;
}

NSString *AndroidUtilJsonReader_nextStringWithChar_(AndroidUtilJsonReader *self, jchar quote) {
  JavaLangStringBuilder *builder = nil;
  do {
    jint start = self->pos_;
    while (self->pos_ < self->limit_) {
      jint c = IOSCharArray_Get(nil_chk(self->buffer_), self->pos_++);
      if (c == quote) {
        if (self->skipping_) {
          return @"skipped!";
        }
        else if (builder == nil) {
          return [((LibcoreInternalStringPool *) nil_chk(self->stringPool_)) getWithCharArray:self->buffer_ withInt:start withInt:self->pos_ - start - 1];
        }
        else {
          [builder appendWithCharArray:self->buffer_ withInt:start withInt:self->pos_ - start - 1];
          return [builder description];
        }
      }
      else if (c == '\\') {
        if (builder == nil) {
          builder = create_JavaLangStringBuilder_init();
        }
        [builder appendWithCharArray:self->buffer_ withInt:start withInt:self->pos_ - start - 1];
        [builder appendWithChar:AndroidUtilJsonReader_readEscapeCharacter(self)];
        start = self->pos_;
      }
    }
    if (builder == nil) {
      builder = create_JavaLangStringBuilder_init();
    }
    [builder appendWithCharArray:self->buffer_ withInt:start withInt:self->pos_ - start];
  }
  while (AndroidUtilJsonReader_fillBufferWithInt_(self, 1));
  @throw nil_chk(AndroidUtilJsonReader_syntaxErrorWithNSString_(self, @"Unterminated string"));
}

NSString *AndroidUtilJsonReader_nextLiteralWithBoolean_(AndroidUtilJsonReader *self, jboolean assignOffsetsOnly) {
  JavaLangStringBuilder *builder = nil;
  self->valuePos_ = -1;
  self->valueLength_ = 0;
  jint i = 0;
  while (true) {
    for (; self->pos_ + i < self->limit_; i++) {
      switch (IOSCharArray_Get(nil_chk(self->buffer_), self->pos_ + i)) {
        case '/':
        case '\\':
        case ';':
        case '#':
        case '=':
        AndroidUtilJsonReader_checkLenient(self);
        case '{':
        case '}':
        case '[':
        case ']':
        case ':':
        case ',':
        case ' ':
        case 0x0009:
        case 0x000c:
        case 0x000d:
        case 0x000a:
        goto break_findNonLiteralCharacter;
      }
    }
    if (i < ((IOSCharArray *) nil_chk(self->buffer_))->size_) {
      if (AndroidUtilJsonReader_fillBufferWithInt_(self, i + 1)) {
        continue;
      }
      else {
        *IOSCharArray_GetRef(self->buffer_, self->limit_) = 0x0000;
        break;
      }
    }
    if (builder == nil) {
      builder = create_JavaLangStringBuilder_init();
    }
    [builder appendWithCharArray:self->buffer_ withInt:self->pos_ withInt:i];
    self->valueLength_ += i;
    self->pos_ += i;
    i = 0;
    if (!AndroidUtilJsonReader_fillBufferWithInt_(self, 1)) {
      break;
    }
  }
  break_findNonLiteralCharacter: ;
  NSString *result;
  if (assignOffsetsOnly && builder == nil) {
    self->valuePos_ = self->pos_;
    result = nil;
  }
  else if (self->skipping_) {
    result = @"skipped!";
  }
  else if (builder == nil) {
    result = [((LibcoreInternalStringPool *) nil_chk(self->stringPool_)) getWithCharArray:self->buffer_ withInt:self->pos_ withInt:i];
  }
  else {
    [builder appendWithCharArray:self->buffer_ withInt:self->pos_ withInt:i];
    result = [builder description];
  }
  self->valueLength_ += i;
  self->pos_ += i;
  return result;
}

jchar AndroidUtilJsonReader_readEscapeCharacter(AndroidUtilJsonReader *self) {
  if (self->pos_ == self->limit_ && !AndroidUtilJsonReader_fillBufferWithInt_(self, 1)) {
    @throw nil_chk(AndroidUtilJsonReader_syntaxErrorWithNSString_(self, @"Unterminated escape sequence"));
  }
  jchar escaped = IOSCharArray_Get(nil_chk(self->buffer_), self->pos_++);
  {
    NSString *hex;
    switch (escaped) {
      case 'u':
      if (self->pos_ + 4 > self->limit_ && !AndroidUtilJsonReader_fillBufferWithInt_(self, 4)) {
        @throw nil_chk(AndroidUtilJsonReader_syntaxErrorWithNSString_(self, @"Unterminated escape sequence"));
      }
      hex = [((LibcoreInternalStringPool *) nil_chk(self->stringPool_)) getWithCharArray:self->buffer_ withInt:self->pos_ withInt:4];
      self->pos_ += 4;
      return (jchar) JavaLangInteger_parseIntWithNSString_withInt_(hex, 16);
      case 't':
      return 0x0009;
      case 'b':
      return 0x0008;
      case 'n':
      return 0x000a;
      case 'r':
      return 0x000d;
      case 'f':
      return 0x000c;
      case '\'':
      case '"':
      case '\\':
      default:
      return escaped;
    }
  }
}

AndroidUtilJsonToken *AndroidUtilJsonReader_readLiteral(AndroidUtilJsonReader *self) {
  JreStrongAssign(&self->value_, AndroidUtilJsonReader_nextLiteralWithBoolean_(self, true));
  if (self->valueLength_ == 0) {
    @throw nil_chk(AndroidUtilJsonReader_syntaxErrorWithNSString_(self, @"Expected literal value"));
  }
  JreStrongAssign(&self->token_, AndroidUtilJsonReader_decodeLiteral(self));
  if (self->token_ == JreLoadEnum(AndroidUtilJsonToken, STRING)) {
    AndroidUtilJsonReader_checkLenient(self);
  }
  return self->token_;
}

AndroidUtilJsonToken *AndroidUtilJsonReader_decodeLiteral(AndroidUtilJsonReader *self) {
  if (self->valuePos_ == -1) {
    return JreLoadEnum(AndroidUtilJsonToken, STRING);
  }
  else if (self->valueLength_ == 4 && ('n' == IOSCharArray_Get(nil_chk(self->buffer_), self->valuePos_) || 'N' == IOSCharArray_Get(self->buffer_, self->valuePos_)) && ('u' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 1) || 'U' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 1)) && ('l' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 2) || 'L' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 2)) && ('l' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 3) || 'L' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 3))) {
    JreStrongAssign(&self->value_, @"null");
    return JreLoadEnum(AndroidUtilJsonToken, NULL);
  }
  else if (self->valueLength_ == 4 && ('t' == IOSCharArray_Get(nil_chk(self->buffer_), self->valuePos_) || 'T' == IOSCharArray_Get(self->buffer_, self->valuePos_)) && ('r' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 1) || 'R' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 1)) && ('u' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 2) || 'U' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 2)) && ('e' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 3) || 'E' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 3))) {
    JreStrongAssign(&self->value_, AndroidUtilJsonReader_TRUE);
    return JreLoadEnum(AndroidUtilJsonToken, BOOLEAN);
  }
  else if (self->valueLength_ == 5 && ('f' == IOSCharArray_Get(nil_chk(self->buffer_), self->valuePos_) || 'F' == IOSCharArray_Get(self->buffer_, self->valuePos_)) && ('a' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 1) || 'A' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 1)) && ('l' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 2) || 'L' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 2)) && ('s' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 3) || 'S' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 3)) && ('e' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 4) || 'E' == IOSCharArray_Get(self->buffer_, self->valuePos_ + 4))) {
    JreStrongAssign(&self->value_, AndroidUtilJsonReader_FALSE);
    return JreLoadEnum(AndroidUtilJsonToken, BOOLEAN);
  }
  else {
    JreStrongAssign(&self->value_, [((LibcoreInternalStringPool *) nil_chk(self->stringPool_)) getWithCharArray:self->buffer_ withInt:self->valuePos_ withInt:self->valueLength_]);
    return AndroidUtilJsonReader_decodeNumberWithCharArray_withInt_withInt_(self, self->buffer_, self->valuePos_, self->valueLength_);
  }
}

AndroidUtilJsonToken *AndroidUtilJsonReader_decodeNumberWithCharArray_withInt_withInt_(AndroidUtilJsonReader *self, IOSCharArray *chars, jint offset, jint length) {
  jint i = offset;
  jint c = IOSCharArray_Get(nil_chk(chars), i);
  if (c == '-') {
    c = IOSCharArray_Get(chars, ++i);
  }
  if (c == '0') {
    c = IOSCharArray_Get(chars, ++i);
  }
  else if (c >= '1' && c <= '9') {
    c = IOSCharArray_Get(chars, ++i);
    while (c >= '0' && c <= '9') {
      c = IOSCharArray_Get(chars, ++i);
    }
  }
  else {
    return JreLoadEnum(AndroidUtilJsonToken, STRING);
  }
  if (c == '.') {
    c = IOSCharArray_Get(chars, ++i);
    while (c >= '0' && c <= '9') {
      c = IOSCharArray_Get(chars, ++i);
    }
  }
  if (c == 'e' || c == 'E') {
    c = IOSCharArray_Get(chars, ++i);
    if (c == '+' || c == '-') {
      c = IOSCharArray_Get(chars, ++i);
    }
    if (c >= '0' && c <= '9') {
      c = IOSCharArray_Get(chars, ++i);
      while (c >= '0' && c <= '9') {
        c = IOSCharArray_Get(chars, ++i);
      }
    }
    else {
      return JreLoadEnum(AndroidUtilJsonToken, STRING);
    }
  }
  if (i == offset + length) {
    return JreLoadEnum(AndroidUtilJsonToken, NUMBER);
  }
  else {
    return JreLoadEnum(AndroidUtilJsonToken, STRING);
  }
}

JavaIoIOException *AndroidUtilJsonReader_syntaxErrorWithNSString_(AndroidUtilJsonReader *self, NSString *message) {
  @throw create_AndroidUtilMalformedJsonException_initWithNSString_(JreStrcat("$$I$I", message, @" at line ", AndroidUtilJsonReader_getLineNumber(self), @" column ", AndroidUtilJsonReader_getColumnNumber(self)));
}

id<JavaLangCharSequence> AndroidUtilJsonReader_getSnippet(AndroidUtilJsonReader *self) {
  JavaLangStringBuilder *snippet = create_JavaLangStringBuilder_init();
  jint beforePos = JavaLangMath_minWithInt_withInt_(self->pos_, 20);
  [snippet appendWithCharArray:self->buffer_ withInt:self->pos_ - beforePos withInt:beforePos];
  jint afterPos = JavaLangMath_minWithInt_withInt_(self->limit_ - self->pos_, 20);
  [snippet appendWithCharArray:self->buffer_ withInt:self->pos_ withInt:afterPos];
  return snippet;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidUtilJsonReader)
