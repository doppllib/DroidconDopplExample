//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "AndroidOsHandler.h"
#include "AndroidOsLooper.h"
#include "IoReactivexAndroidPluginsRxAndroidPlugins.h"
#include "IoReactivexAndroidSchedulersAndroidSchedulers.h"
#include "IoReactivexAndroidSchedulersHandlerScheduler.h"
#include "IoReactivexScheduler.h"
#include "J2ObjC_source.h"
#include "java/lang/AssertionError.h"
#include "java/lang/NullPointerException.h"
#include "java/util/concurrent/Callable.h"

@interface IoReactivexAndroidSchedulersAndroidSchedulers ()

- (instancetype)init;

@end

inline IoReactivexScheduler *IoReactivexAndroidSchedulersAndroidSchedulers_get_MAIN_THREAD();
static IoReactivexScheduler *IoReactivexAndroidSchedulersAndroidSchedulers_MAIN_THREAD;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexAndroidSchedulersAndroidSchedulers, MAIN_THREAD, IoReactivexScheduler *)

__attribute__((unused)) static void IoReactivexAndroidSchedulersAndroidSchedulers_init(IoReactivexAndroidSchedulersAndroidSchedulers *self);

__attribute__((unused)) static IoReactivexAndroidSchedulersAndroidSchedulers *new_IoReactivexAndroidSchedulersAndroidSchedulers_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static IoReactivexAndroidSchedulersAndroidSchedulers *create_IoReactivexAndroidSchedulersAndroidSchedulers_init();

@interface IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder : NSObject

- (instancetype)init;

@end

J2OBJC_STATIC_INIT(IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder)

inline IoReactivexScheduler *IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder_get_DEFAULT();
static IoReactivexScheduler *IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder_DEFAULT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder, DEFAULT, IoReactivexScheduler *)

__attribute__((unused)) static void IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder_init(IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder *self);

__attribute__((unused)) static IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder *new_IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder *create_IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder_init();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder)

@interface IoReactivexAndroidSchedulersAndroidSchedulers_1 : NSObject < JavaUtilConcurrentCallable >

- (instancetype)init;

- (IoReactivexScheduler *)call;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexAndroidSchedulersAndroidSchedulers_1)

__attribute__((unused)) static void IoReactivexAndroidSchedulersAndroidSchedulers_1_init(IoReactivexAndroidSchedulersAndroidSchedulers_1 *self);

__attribute__((unused)) static IoReactivexAndroidSchedulersAndroidSchedulers_1 *new_IoReactivexAndroidSchedulersAndroidSchedulers_1_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static IoReactivexAndroidSchedulersAndroidSchedulers_1 *create_IoReactivexAndroidSchedulersAndroidSchedulers_1_init();

J2OBJC_INITIALIZED_DEFN(IoReactivexAndroidSchedulersAndroidSchedulers)

@implementation IoReactivexAndroidSchedulersAndroidSchedulers

+ (IoReactivexScheduler *)mainThread {
  return IoReactivexAndroidSchedulersAndroidSchedulers_mainThread();
}

+ (IoReactivexScheduler *)fromWithAndroidOsLooper:(AndroidOsLooper *)looper {
  return IoReactivexAndroidSchedulersAndroidSchedulers_fromWithAndroidOsLooper_(looper);
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexAndroidSchedulersAndroidSchedulers_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LIoReactivexScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler;", 0x9, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(mainThread);
  methods[1].selector = @selector(fromWithAndroidOsLooper:);
  methods[2].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "MAIN_THREAD", "LIoReactivexScheduler;", .constantValue.asLong = 0, 0x1a, -1, 2, -1, -1 },
  };
  static const void *ptrTable[] = { "from", "LAndroidOsLooper;", &IoReactivexAndroidSchedulersAndroidSchedulers_MAIN_THREAD, "LIoReactivexAndroidSchedulersAndroidSchedulers_MainHolder;" };
  static const J2ObjcClassInfo _IoReactivexAndroidSchedulersAndroidSchedulers = { "AndroidSchedulers", "io.reactivex.android.schedulers", ptrTable, methods, fields, 7, 0x11, 3, 1, -1, 3, -1, -1, -1 };
  return &_IoReactivexAndroidSchedulersAndroidSchedulers;
}

+ (void)initialize {
  if (self == [IoReactivexAndroidSchedulersAndroidSchedulers class]) {
    JreStrongAssign(&IoReactivexAndroidSchedulersAndroidSchedulers_MAIN_THREAD, IoReactivexAndroidPluginsRxAndroidPlugins_initMainThreadSchedulerWithJavaUtilConcurrentCallable_(create_IoReactivexAndroidSchedulersAndroidSchedulers_1_init()));
    J2OBJC_SET_INITIALIZED(IoReactivexAndroidSchedulersAndroidSchedulers)
  }
}

@end

IoReactivexScheduler *IoReactivexAndroidSchedulersAndroidSchedulers_mainThread() {
  IoReactivexAndroidSchedulersAndroidSchedulers_initialize();
  return IoReactivexAndroidPluginsRxAndroidPlugins_onMainThreadSchedulerWithIoReactivexScheduler_(IoReactivexAndroidSchedulersAndroidSchedulers_MAIN_THREAD);
}

IoReactivexScheduler *IoReactivexAndroidSchedulersAndroidSchedulers_fromWithAndroidOsLooper_(AndroidOsLooper *looper) {
  IoReactivexAndroidSchedulersAndroidSchedulers_initialize();
  if (looper == nil) @throw create_JavaLangNullPointerException_initWithNSString_(@"looper == null");
  return create_IoReactivexAndroidSchedulersHandlerScheduler_initWithAndroidOsHandler_(create_AndroidOsHandler_initWithAndroidOsLooper_(looper));
}

void IoReactivexAndroidSchedulersAndroidSchedulers_init(IoReactivexAndroidSchedulersAndroidSchedulers *self) {
  NSObject_init(self);
  @throw create_JavaLangAssertionError_initWithId_(@"No instances.");
}

IoReactivexAndroidSchedulersAndroidSchedulers *new_IoReactivexAndroidSchedulersAndroidSchedulers_init() {
  J2OBJC_NEW_IMPL(IoReactivexAndroidSchedulersAndroidSchedulers, init)
}

IoReactivexAndroidSchedulersAndroidSchedulers *create_IoReactivexAndroidSchedulersAndroidSchedulers_init() {
  J2OBJC_CREATE_IMPL(IoReactivexAndroidSchedulersAndroidSchedulers, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexAndroidSchedulersAndroidSchedulers)

J2OBJC_INITIALIZED_DEFN(IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder)

@implementation IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEFAULT", "LIoReactivexScheduler;", .constantValue.asLong = 0, 0x18, -1, 0, -1, -1 },
  };
  static const void *ptrTable[] = { &IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder_DEFAULT, "LIoReactivexAndroidSchedulersAndroidSchedulers;" };
  static const J2ObjcClassInfo _IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder = { "MainHolder", "io.reactivex.android.schedulers", ptrTable, methods, fields, 7, 0x1a, 1, 1, 1, -1, -1, -1, -1 };
  return &_IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder;
}

+ (void)initialize {
  if (self == [IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder class]) {
    JreStrongAssignAndConsume(&IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder_DEFAULT, new_IoReactivexAndroidSchedulersHandlerScheduler_initWithAndroidOsHandler_(create_AndroidOsHandler_initWithAndroidOsLooper_(AndroidOsLooper_getMainLooper())));
    J2OBJC_SET_INITIALIZED(IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder)
  }
}

@end

void IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder_init(IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder *self) {
  NSObject_init(self);
}

IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder *new_IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder_init() {
  J2OBJC_NEW_IMPL(IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder, init)
}

IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder *create_IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder_init() {
  J2OBJC_CREATE_IMPL(IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder)

@implementation IoReactivexAndroidSchedulersAndroidSchedulers_1

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexAndroidSchedulersAndroidSchedulers_1_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (IoReactivexScheduler *)call {
  return JreLoadStatic(IoReactivexAndroidSchedulersAndroidSchedulers_MainHolder, DEFAULT);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler;", 0x1, -1, -1, 0, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(call);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LJavaLangException;", "LIoReactivexAndroidSchedulersAndroidSchedulers;", "Ljava/lang/Object;Ljava/util/concurrent/Callable<Lio/reactivex/Scheduler;>;" };
  static const J2ObjcClassInfo _IoReactivexAndroidSchedulersAndroidSchedulers_1 = { "", "io.reactivex.android.schedulers", ptrTable, methods, NULL, 7, 0x8018, 2, 0, 1, -1, -1, 2, -1 };
  return &_IoReactivexAndroidSchedulersAndroidSchedulers_1;
}

@end

void IoReactivexAndroidSchedulersAndroidSchedulers_1_init(IoReactivexAndroidSchedulersAndroidSchedulers_1 *self) {
  NSObject_init(self);
}

IoReactivexAndroidSchedulersAndroidSchedulers_1 *new_IoReactivexAndroidSchedulersAndroidSchedulers_1_init() {
  J2OBJC_NEW_IMPL(IoReactivexAndroidSchedulersAndroidSchedulers_1, init)
}

IoReactivexAndroidSchedulersAndroidSchedulers_1 *create_IoReactivexAndroidSchedulersAndroidSchedulers_1_init() {
  J2OBJC_CREATE_IMPL(IoReactivexAndroidSchedulersAndroidSchedulers_1, init)
}
