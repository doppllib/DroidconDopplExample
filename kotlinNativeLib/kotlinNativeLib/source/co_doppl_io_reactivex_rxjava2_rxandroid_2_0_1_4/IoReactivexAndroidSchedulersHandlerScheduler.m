//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "AndroidOsHandler.h"
#include "AndroidOsMessage.h"
#include "IoReactivexAndroidSchedulersHandlerScheduler.h"
#include "IoReactivexDisposablesDisposable.h"
#include "IoReactivexDisposablesDisposables.h"
#include "IoReactivexPluginsRxJavaPlugins.h"
#include "IoReactivexScheduler.h"
#include "J2ObjC_source.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Math.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/Runnable.h"
#include "java/lang/Thread.h"
#include "java/lang/Throwable.h"
#include "java/util/concurrent/TimeUnit.h"

@interface IoReactivexAndroidSchedulersHandlerScheduler () {
 @public
  AndroidOsHandler *handler_;
}

@end

J2OBJC_FIELD_SETTER(IoReactivexAndroidSchedulersHandlerScheduler, handler_, AndroidOsHandler *)

@interface IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker : IoReactivexScheduler_Worker {
 @public
  AndroidOsHandler *handler_;
  volatile_jboolean disposed_;
}

- (instancetype)initWithAndroidOsHandler:(AndroidOsHandler *)handler;

- (id<IoReactivexDisposablesDisposable>)scheduleWithJavaLangRunnable:(id<JavaLangRunnable>)run
                                                            withLong:(jlong)delay
                                      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

- (void)dispose;

- (jboolean)isDisposed;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker)

J2OBJC_FIELD_SETTER(IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker, handler_, AndroidOsHandler *)

__attribute__((unused)) static void IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker_initWithAndroidOsHandler_(IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker *self, AndroidOsHandler *handler);

__attribute__((unused)) static IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker *new_IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker_initWithAndroidOsHandler_(AndroidOsHandler *handler) NS_RETURNS_RETAINED;

__attribute__((unused)) static IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker *create_IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker_initWithAndroidOsHandler_(AndroidOsHandler *handler);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker)

@interface IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable : NSObject < JavaLangRunnable, IoReactivexDisposablesDisposable > {
 @public
  AndroidOsHandler *handler_;
  id<JavaLangRunnable> delegate_;
  volatile_jboolean disposed_;
}

- (instancetype)initWithAndroidOsHandler:(AndroidOsHandler *)handler
                    withJavaLangRunnable:(id<JavaLangRunnable>)delegate;

- (void)run;

- (void)dispose;

- (jboolean)isDisposed;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable)

J2OBJC_FIELD_SETTER(IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable, handler_, AndroidOsHandler *)
J2OBJC_FIELD_SETTER(IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable, delegate_, id<JavaLangRunnable>)

__attribute__((unused)) static void IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable_initWithAndroidOsHandler_withJavaLangRunnable_(IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable *self, AndroidOsHandler *handler, id<JavaLangRunnable> delegate);

__attribute__((unused)) static IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable *new_IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable_initWithAndroidOsHandler_withJavaLangRunnable_(AndroidOsHandler *handler, id<JavaLangRunnable> delegate) NS_RETURNS_RETAINED;

__attribute__((unused)) static IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable *create_IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable_initWithAndroidOsHandler_withJavaLangRunnable_(AndroidOsHandler *handler, id<JavaLangRunnable> delegate);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable)

@implementation IoReactivexAndroidSchedulersHandlerScheduler

- (instancetype)initWithAndroidOsHandler:(AndroidOsHandler *)handler {
  IoReactivexAndroidSchedulersHandlerScheduler_initWithAndroidOsHandler_(self, handler);
  return self;
}

- (id<IoReactivexDisposablesDisposable>)scheduleDirectWithJavaLangRunnable:(id<JavaLangRunnable>)run
                                                                  withLong:(jlong)delay
                                            withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  if (run == nil) @throw create_JavaLangNullPointerException_initWithNSString_(@"run == null");
  if (unit == nil) @throw create_JavaLangNullPointerException_initWithNSString_(@"unit == null");
  run = IoReactivexPluginsRxJavaPlugins_onScheduleWithJavaLangRunnable_(run);
  IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable *scheduled = create_IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable_initWithAndroidOsHandler_withJavaLangRunnable_(handler_, run);
  [((AndroidOsHandler *) nil_chk(handler_)) postDelayedWithJavaLangRunnable:scheduled withLong:JavaLangMath_maxWithLong_withLong_(0LL, [unit toMillisWithLong:delay])];
  return scheduled;
}

- (IoReactivexScheduler_Worker *)createWorker {
  return create_IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker_initWithAndroidOsHandler_(handler_);
}

- (void)dealloc {
  RELEASE_(handler_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler_Worker;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithAndroidOsHandler:);
  methods[1].selector = @selector(scheduleDirectWithJavaLangRunnable:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[2].selector = @selector(createWorker);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "handler_", "LAndroidOsHandler;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LAndroidOsHandler;", "scheduleDirect", "LJavaLangRunnable;JLJavaUtilConcurrentTimeUnit;", "LIoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker;LIoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable;" };
  static const J2ObjcClassInfo _IoReactivexAndroidSchedulersHandlerScheduler = { "HandlerScheduler", "io.reactivex.android.schedulers", ptrTable, methods, fields, 7, 0x10, 3, 1, -1, 3, -1, -1, -1 };
  return &_IoReactivexAndroidSchedulersHandlerScheduler;
}

@end

void IoReactivexAndroidSchedulersHandlerScheduler_initWithAndroidOsHandler_(IoReactivexAndroidSchedulersHandlerScheduler *self, AndroidOsHandler *handler) {
  IoReactivexScheduler_init(self);
  JreStrongAssign(&self->handler_, handler);
}

IoReactivexAndroidSchedulersHandlerScheduler *new_IoReactivexAndroidSchedulersHandlerScheduler_initWithAndroidOsHandler_(AndroidOsHandler *handler) {
  J2OBJC_NEW_IMPL(IoReactivexAndroidSchedulersHandlerScheduler, initWithAndroidOsHandler_, handler)
}

IoReactivexAndroidSchedulersHandlerScheduler *create_IoReactivexAndroidSchedulersHandlerScheduler_initWithAndroidOsHandler_(AndroidOsHandler *handler) {
  J2OBJC_CREATE_IMPL(IoReactivexAndroidSchedulersHandlerScheduler, initWithAndroidOsHandler_, handler)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexAndroidSchedulersHandlerScheduler)

@implementation IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker

- (instancetype)initWithAndroidOsHandler:(AndroidOsHandler *)handler {
  IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker_initWithAndroidOsHandler_(self, handler);
  return self;
}

- (id<IoReactivexDisposablesDisposable>)scheduleWithJavaLangRunnable:(id<JavaLangRunnable>)run
                                                            withLong:(jlong)delay
                                      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  if (run == nil) @throw create_JavaLangNullPointerException_initWithNSString_(@"run == null");
  if (unit == nil) @throw create_JavaLangNullPointerException_initWithNSString_(@"unit == null");
  if (JreLoadVolatileBoolean(&disposed_)) {
    return IoReactivexDisposablesDisposables_disposed();
  }
  run = IoReactivexPluginsRxJavaPlugins_onScheduleWithJavaLangRunnable_(run);
  IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable *scheduled = create_IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable_initWithAndroidOsHandler_withJavaLangRunnable_(handler_, run);
  AndroidOsMessage *message = AndroidOsMessage_obtainWithAndroidOsHandler_withJavaLangRunnable_(handler_, scheduled);
  JreStrongAssign(&((AndroidOsMessage *) nil_chk(message))->obj_, self);
  [((AndroidOsHandler *) nil_chk(handler_)) sendMessageDelayedWithAndroidOsMessage:message withLong:JavaLangMath_maxWithLong_withLong_(0LL, [unit toMillisWithLong:delay])];
  if (JreLoadVolatileBoolean(&disposed_)) {
    [handler_ removeCallbacksWithJavaLangRunnable:scheduled];
    return IoReactivexDisposablesDisposables_disposed();
  }
  return scheduled;
}

- (void)dispose {
  JreAssignVolatileBoolean(&disposed_, true);
  [((AndroidOsHandler *) nil_chk(handler_)) removeCallbacksAndMessagesWithId:self];
}

- (jboolean)isDisposed {
  return JreLoadVolatileBoolean(&disposed_);
}

- (void)dealloc {
  RELEASE_(handler_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithAndroidOsHandler:);
  methods[1].selector = @selector(scheduleWithJavaLangRunnable:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[2].selector = @selector(dispose);
  methods[3].selector = @selector(isDisposed);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "handler_", "LAndroidOsHandler;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "disposed_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LAndroidOsHandler;", "schedule", "LJavaLangRunnable;JLJavaUtilConcurrentTimeUnit;", "LIoReactivexAndroidSchedulersHandlerScheduler;" };
  static const J2ObjcClassInfo _IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker = { "HandlerWorker", "io.reactivex.android.schedulers", ptrTable, methods, fields, 7, 0x1a, 4, 2, 3, -1, -1, -1, -1 };
  return &_IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker;
}

@end

void IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker_initWithAndroidOsHandler_(IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker *self, AndroidOsHandler *handler) {
  IoReactivexScheduler_Worker_init(self);
  JreStrongAssign(&self->handler_, handler);
}

IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker *new_IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker_initWithAndroidOsHandler_(AndroidOsHandler *handler) {
  J2OBJC_NEW_IMPL(IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker, initWithAndroidOsHandler_, handler)
}

IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker *create_IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker_initWithAndroidOsHandler_(AndroidOsHandler *handler) {
  J2OBJC_CREATE_IMPL(IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker, initWithAndroidOsHandler_, handler)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexAndroidSchedulersHandlerScheduler_HandlerWorker)

@implementation IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable

- (instancetype)initWithAndroidOsHandler:(AndroidOsHandler *)handler
                    withJavaLangRunnable:(id<JavaLangRunnable>)delegate {
  IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable_initWithAndroidOsHandler_withJavaLangRunnable_(self, handler, delegate);
  return self;
}

- (void)run {
  @try {
    [((id<JavaLangRunnable>) nil_chk(delegate_)) run];
  }
  @catch (JavaLangThrowable *t) {
    JavaLangIllegalStateException *ie = create_JavaLangIllegalStateException_initWithNSString_withJavaLangThrowable_(@"Fatal Exception thrown on Scheduler.", t);
    IoReactivexPluginsRxJavaPlugins_onErrorWithJavaLangThrowable_(ie);
    JavaLangThread *thread = JavaLangThread_currentThread();
    [((id<JavaLangThread_UncaughtExceptionHandler>) nil_chk([((JavaLangThread *) nil_chk(thread)) getUncaughtExceptionHandler])) uncaughtExceptionWithJavaLangThread:thread withJavaLangThrowable:ie];
  }
}

- (void)dispose {
  JreAssignVolatileBoolean(&disposed_, true);
  [((AndroidOsHandler *) nil_chk(handler_)) removeCallbacksWithJavaLangRunnable:self];
}

- (jboolean)isDisposed {
  return JreLoadVolatileBoolean(&disposed_);
}

- (void)dealloc {
  RELEASE_(handler_);
  RELEASE_(delegate_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithAndroidOsHandler:withJavaLangRunnable:);
  methods[1].selector = @selector(run);
  methods[2].selector = @selector(dispose);
  methods[3].selector = @selector(isDisposed);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "handler_", "LAndroidOsHandler;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "delegate_", "LJavaLangRunnable;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "disposed_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LAndroidOsHandler;LJavaLangRunnable;", "LIoReactivexAndroidSchedulersHandlerScheduler;" };
  static const J2ObjcClassInfo _IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable = { "ScheduledRunnable", "io.reactivex.android.schedulers", ptrTable, methods, fields, 7, 0x1a, 4, 3, 1, -1, -1, -1, -1 };
  return &_IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable;
}

@end

void IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable_initWithAndroidOsHandler_withJavaLangRunnable_(IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable *self, AndroidOsHandler *handler, id<JavaLangRunnable> delegate) {
  NSObject_init(self);
  JreStrongAssign(&self->handler_, handler);
  JreStrongAssign(&self->delegate_, delegate);
}

IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable *new_IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable_initWithAndroidOsHandler_withJavaLangRunnable_(AndroidOsHandler *handler, id<JavaLangRunnable> delegate) {
  J2OBJC_NEW_IMPL(IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable, initWithAndroidOsHandler_withJavaLangRunnable_, handler, delegate)
}

IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable *create_IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable_initWithAndroidOsHandler_withJavaLangRunnable_(AndroidOsHandler *handler, id<JavaLangRunnable> delegate) {
  J2OBJC_CREATE_IMPL(IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable, initWithAndroidOsHandler_withJavaLangRunnable_, handler, delegate)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexAndroidSchedulersHandlerScheduler_ScheduledRunnable)
